/***********************************************************************
 *                        INTEL CONFIDENTIAL                           *
 ***********************************************************************

    Copyright 2012 Intel Corporation All Rights Reserved.
    The source code contained or described herein and all documents
    related to the source code (\"Material\") are owned by Intel
    Corporation or its suppliers or licensors. Title to the Material
    remains with Intel Corporation or its suppliers and licensors.
    The Material contains trade secrets and proprietary and
    confidential information of Intel or its suppliers and licensors.
    The Material is protected by worldwide copyright and trade secret
    laws and treaty provisions. No part of the Material may be used,
    copied, reproduced, modified, published, uploaded, posted,
    transmitted, distributed, or disclosed in any way without Intel's
    prior express written permission.

      No license under any patent, copyright, trade secret or other
    intellectual property right is granted to or conferred upon you by
    disclosure or delivery of the Materials, either expressly, by
    implication, inducement, estoppel or otherwise. Any license under
    such intellectual property rights must be express and approved by
    Intel in writing.

 **********************************************************************
    Description:

    Other:INVCAM315

    Creation time:01/02/2018 10:55:11
 **********************************************************************/

#ifndef _REGISTERS_B0_H_
#define _REGISTERS_B0_H_

#define _version_

#include <stdint.h>

#define READ_REG_VALUE(reg)               ((volatile reg*) reg##_offset)->value_read

#define WRITE_REG_VALUE(reg, val)         (((volatile reg*) reg##_offset)->value_write = val)

#define READ_REG_FIELD(reg, field)       ((reg) READ_REG_VALUE(reg)).fields_read.field

// To prevent non-32bit access to register through bit-fields
#define WRITE_REG_FIELD(reg, field, val) { register reg tmp;  tmp.value_write = READ_REG_VALUE(reg); tmp.fields_write.field = val; WRITE_REG_VALUE(reg, tmp.value_write); }

#define WRITE_REG_FIELD_RMW(reg, field, val)      { register reg tmp;  tmp.value_write = READ_REG_VALUE(reg); tmp.fields_rmw.field = val;  WRITE_REG_VALUE(reg, tmp.value_write); }
#define WRITE_SHADOWED_REG_FIELD(reg, field, val) { register reg tmp;  tmp.value_write = READ_REG_VALUE(reg); tmp.fields_read.field = val; WRITE_REG_VALUE(reg, tmp.value_write); }

#define WRITE_REG_IMM(reg_offset, val)    (*((volatile uint32_t *)(reg_offset)) = (val))
#define READ_REG_IMM(reg_offset) 		  (*((volatile uint32_t *)(reg_offset)))


//#######################################################################
//                      cam_registers area
//#######################################################################
#define RegCamCameraControl_offset                                0x18000
#define RegCamImgVsyncMasterControl_offset                        0x18004
#define RegCamImagerControl_offset                                0x18008
#define RegCamVirtualChannelControl_offset                        0x1800C
#define RegCamWebFrameLength_offset                               0x18010
#define RegCamVsyncDelayCount_offset                              0x18014
#define RegCamVsyncWidthCount_offset                              0x18018
#define RegCamLcpVsyncPulse_offset                                0x1801C
#define RegCamVsyncMasterTiming_offset                            0x18020
#define RegCamIspFrameLength_offset                               0x18024
#define RegCamEmbeddedDatatype_offset                             0x18028
#define RegCamEmbeddedSelect_offset                               0x1802C
#define RegCamEmbeddedReadAddress_offset                          0x18030
#define RegCamEmbeddedStoredData_offset                           0x18034
#define RegCamCamPathGoStop_offset                                0x18038
#define RegCamCamChiknBits_offset                                 0x1803C
#define RegCamItmControl_offset                                   0x18040
#define RegCamOtfControl_offset                                   0x18044
#define RegCamImuVsyncSelect_offset                               0x18048
#define RegCamFrameNumber_offset                                  0x18080
#define RegCamAlignAImg_offset                                    0x18084
#define RegCamAlignBImg_offset                                    0x18088
#define RegCamAlignMImg_offset                                    0x1808C
#define RegCamAlignYImg_offset                                    0x18090
#define RegCamAlignZImg_offset                                    0x18094
#define RegCamCamStatusRegister_offset                            0x18098
#define RegCamItmStatusRegister_offset                            0x1809C
#define RegCamCameraLaserControl_offset                           0x18100
#define RegCamPwmWindowCount_offset                               0x18104
#define RegCamPwmDelayCount_offset                                0x18108
#define RegCamPwmEnableCount_offset                               0x1810C
#define RegCamPwmDisableCount_offset                              0x18110
#define RegCamCamPowerControl_offset                              0x18114
#define RegCamPwmEnableCountMax_offset                            0x18118
#define RegCamPwmMaxRatio_offset                                  0x1811C

//#######################################################################
//                      csr_registers area
//#######################################################################
#define RegCsrVersionRegister_offset                              0x12000
#define RegCsrSwResetsLock_offset                                 0x12004
#define RegCsrSwPllReset_offset                                   0x12008
#define RegCsrSwClkrstCtl_offset                                  0x1200C
#define RegCsrPllSetupReg0_offset                                 0x12010
#define RegCsrPllSetupReg1_offset                                 0x12014
#define RegCsrPllSetupReg2_offset                                 0x12018
#define RegCsrPllSetupReg3_offset                                 0x1201C
#define RegCsrPllStatus_offset                                    0x12020
#define RegCsrSclkStatus_offset                                   0x1202C
#define RegCsrPllSelectedSetupReg0_offset                         0x12410
#define RegCsrPllSelectedSetupReg1_offset                         0x12414
#define RegCsrPllSelectedSetupReg2_offset                         0x12418
#define RegCsrPllSelectedSetupReg3_offset                         0x1241C
#define RegCsrCsrClkMode_offset                                   0x12024
#define RegCsrCsrClkSelect_offset                                 0x12028
#define RegCsrGpioControl_offset                                  0x12030
#define RegCsrGpioData_offset                                     0x12034
#define RegCsrGpioMux_offset                                      0x12038
#define RegCsrGpioDataInput_offset                                0x1203C
#define RegCsrGpioDataInput2_offset                               0x1204C
#define RegCsrEgpioEnable_offset                                  0x12060
#define RegCsrTsPvtEnable_offset                                  0x12070
#define RegCsrTsPvtSample_offset                                  0x12074
#define RegCsrTsPvtTrim_offset                                    0x12078
#define RegCsrTsPvtDataOut_offset                                 0x1207C
#define RegCsrTsModeSelect_offset                                 0x120E0
#define RegCsrTsTrimCmd_offset                                    0x120E4
#define RegCsrTsTrimResult_offset                                 0x120E8
#define RegCsrTsRdPeriod_offset                                   0x120EC
#define RegCsrTsEfuseRdata0_offset                                0x120B0
#define RegCsrTsEfuseRdata1_offset                                0x120B4
#define RegCsrTsEfuseRdata2_offset                                0x120B8
#define RegCsrTsEfuseRdata3_offset                                0x120BC
#define RegCsrTsEfuseRdata4_offset                                0x120C0
#define RegCsrTsEfuseRdata5_offset                                0x120C4
#define RegCsrTsEfuseRdata6_offset                                0x120C8
#define RegCsrTsEfuseRdata7_offset                                0x120CC
#define RegCsrTsEfuseRvalid_offset                                0x120D0
#define RegCsrInterruptEnable0_offset                             0x12040
#define RegCsrInterruptEnable1_offset                             0x12044
#define RegCsrInterruptEnable2_offset                             0x12048
#define RegCsrInterruptStatus0_offset                             0x12050
#define RegCsrInterruptStatus1_offset                             0x12054
#define RegCsrInterruptStatus2_offset                             0x12058
#define RegCsrInterruptEnable3_offset                             0x1205C
#define RegCsrInterruptEnable4_offset                             0x12064
#define RegCsrInterruptStatus3_offset                             0x12068
#define RegCsrInterruptStatus4_offset                             0x1206C
#define RegCsrWdtCount0_offset                                    0x12080
#define RegCsrWdtCount1_offset                                    0x12084
#define RegCsrWdtCount2_offset                                    0x12088
#define RegCsrWdtCurrentCount0_offset                             0x12090
#define RegCsrWdtCurrentCount1_offset                             0x12094
#define RegCsrWdtCurrentCount2_offset                             0x12098
#define RegCsrWdtStatus_offset                                    0x1209C
#define RegCsrWdtControl0_offset                                  0x120A0
#define RegCsrWdtControl1_offset                                  0x120A4
#define RegCsrBootstatvectorsel_offset                            0x12100
#define RegCsrBootrstsource_offset                                0x12104
#define RegCsrBootlock_offset                                     0x12108
#define RegCsrBootprogress16_offset                               0x1210C
#define RegCsrBootprogress32_offset                               0x12120
#define RegCsrBootrstcmd_offset                                   0x12110
#define RegCsrBootrststatus_offset                                0x12114
#define RegCsrBootcfg_offset                                      0x12118
#define RegCsrRegflashunlock_offset                               0x1211C
#define RegCsrSwsparescratch_offset                               0x12124
#define RegCsrCwControl0_offset                                   0x12200
#define RegCsrCwControl1_offset                                   0x12204
#define RegCsrCwControl2_offset                                   0x12208
#define RegCsrCwControl3_offset                                   0x1220C
#define RegCsrCwControl4_offset                                   0x12210
#define RegCsrCwControl5_offset                                   0x12214
#define RegCsrCwControl6_offset                                   0x12218
#define RegCsrCwControl7_offset                                   0x1221C
#define RegCsrCwControl8_offset                                   0x12220
#define RegCsrCwControl9_offset                                   0x12224
#define RegCsrCwControl10_offset                                  0x12228
#define RegCsrCwControl11_offset                                  0x1222C
#define RegCsrCwControl12_offset                                  0x12230
#define RegCsrCwControl13_offset                                  0x12234
#define RegCsrCwControl14_offset                                  0x12238
#define RegCsrCwControl15_offset                                  0x1223C
#define RegCsrCwControl16_offset                                  0x12240
#define RegCsrCwControl17_offset                                  0x12244
#define RegCsrCwControl18_offset                                  0x12248
#define RegCsrGpr0_offset                                         0x12260
#define RegCsrGpr1_offset                                         0x12264
#define RegCsrGpr2_offset                                         0x12268
#define RegCsrGpr3_offset                                         0x1226C
#define RegCsrPmuControl0_offset                                  0x12500
#define RegCsrPmuControl1_offset                                  0x12504
#define RegCsrPmuControl2_offset                                  0x12508
#define RegCsrPmuControl3_offset                                  0x1250C
#define RegCsrPmuControl4_offset                                  0x12514
#define RegCsrPmuControl5_offset                                  0x12518
#define RegCsrPmuStatus_offset                                    0x12510
#define RegCsrEfuseControl0_offset                                0x12540
#define RegCsrEfuseControl1_offset                                0x12544
#define RegCsrEfuseReadData_offset                                0x12548
#define RegCsrEfuseReadData2_offset                               0x1254C
#define RegCsrMipiphyRefFrquency_offset                           0x12570
#define RegCsrPinstrapStatus_offset                               0x12600
#define RegCsrLcpInterrupt0Control_offset                         0x12604
#define RegCsrLcpInterrupt1Control_offset                         0x12608
#define RegCsrLcpInterrupt2Control_offset                         0x1260C
#define RegCsrLcpInterrupt3Control_offset                         0x12610
#define RegCsrLcpInterrupt4Control_offset                         0x12614
#define RegCsrLcpInterrupt5Control_offset                         0x12618
#define RegCsrLcpInterrupt6Control_offset                         0x1261C
#define RegCsrLcpInterrupt7Control_offset                         0x12620
#define RegCsrLcpInterrupt8Control_offset                         0x12624
#define RegCsrLcpInterrupt9Control_offset                         0x12628
#define RegCsrLcpInterrupt10Control_offset                        0x1262C
#define RegCsrLcpInterrupt11Control_offset                        0x12630
#define RegCsrLcpInterrupt12Control_offset                        0x12634
#define RegCsrLcpInterrupt13Control_offset                        0x12638
#define RegCsrLcpInterrupt14Control_offset                        0x1263C
#define RegCsrLcpInterrupt15Control_offset                        0x12640
#define RegCsrLcpInterrupt16Control_offset                        0x12644
#define RegCsrLcpInterrupt17Control_offset                        0x12648
#define RegCsrLcpInterrupt18Control_offset                        0x1264C
#define RegCsrLcpInterrupt19Control_offset                        0x12650
#define RegCsrLcpInterrupt20Control_offset                        0x12654
#define RegCsrLcpInterrupt21Control_offset                        0x12658
#define RegCsrLcpInterrupt22Control_offset                        0x1265C
#define RegCsrLcpInterrupt23Control_offset                        0x12660
#define RegCsrLcpInterrupt24Control_offset                        0x12664
#define RegCsrLcpInterrupt25Control_offset                        0x12668
#define RegCsrLcpInterrupt26Control_offset                        0x1266C
#define RegCsrLcpInterrupt27Control_offset                        0x12670
#define RegCsrCameraAIoStrengthControl_offset                     0x12700
#define RegCsrCameraBIoStrengthControl_offset                     0x12704
#define RegCsrCameraMIoStrengthControl_offset                     0x12708
#define RegCsrCameraYIoStrengthControl_offset                     0x1270C
#define RegCsrCameraZIoStrengthControl_offset                     0x12710
#define RegCsrCameraHIoStrengthControl_offset                     0x12714
#define RegCsrGpioIoStrengthControl_offset                        0x12718
#define RegCsrEgpioIoStrengthControl_offset                       0x1271C
#define RegCsrSpiIoStrengthControl_offset                         0x12720
#define RegCsrDfuControlStatus_offset                             0x12724
#define RegCsrForceLedOn_offset                                   0x12728
#define RegCsrLcpIramDramShutdown_offset                          0x12800
#define RegCsrIoSchmittTriggerControl_offset                      0x1272C

//#######################################################################
//                      imu_registers area
//#######################################################################
#define RegImuImuI2cSlaveControl_offset                           0x11C00
#define RegImuImuFifoOwnership_offset                             0x11C04
#define RegImuImuClockAndReset_offset                             0x11C08
#define RegImuImuPowerState_offset                                0x11C20
#define RegImuImuTimestampStartCnt_offset                         0x11C24
#define RegImuImuTimestampFreqCnt_offset                          0x11C28
#define RegImuImuTimestampCorrCnt_offset                          0x11C2C
#define RegImuImuTimestampCnt_offset                              0x11C30
#define RegImuImuFifoThreshold_offset                             0x11C3C
#define RegImuImuReadFifo1_offset                                 0x11C40
#define RegImuImuReadFifo2_offset                                 0x11C44
#define RegImuImuEvent1Config_offset                              0x11C60
#define RegImuImuEvent2Config_offset                              0x11C64
#define RegImuImuEvent3Config_offset                              0x11C68
#define RegImuImuEvent4Config_offset                              0x11C6C
#define RegImuImuEvent5Config_offset                              0x11C70
#define RegImuImuEvent6Config_offset                              0x11C74
#define RegImuImuEvent7Config_offset                              0x11C78
#define RegImuImuEvent8Config_offset                              0x11C7C
#define RegImuImuInterruptEnable_offset                           0x11C80
#define RegImuImuInterruptStatus_offset                           0x11C84

//#######################################################################
//                      ldi_registers area
//#######################################################################
#define RegLdiRegId_offset                                        0x11800
#define RegLdiDriverCtl0_offset                                   0x11804
#define RegLdiDriverCtl1_offset                                   0x11808
#define RegLdiCfg_offset                                          0x1180C
#define RegLdiStatus_offset                                       0x11810
#define RegLdiSysCtl_offset                                       0x11814
#define RegLdiIrqEnable_offset                                    0x11818
#define RegLdiIrqStatus_offset                                    0x1181C
#define RegLdiLdErrIrqCnt_offset                                  0x11820
#define RegLdiMemAddr_offset                                      0x11824
#define RegLdiMemData0_offset                                     0x11828
#define RegLdiMemData1_offset                                     0x1182C
#define RegLdiTrigDelayCnt_offset                                 0x11830
#define RegLdiTrigLoopCnt_offset                                  0x11834
#define RegLdiRegFatalErrSelect_offset                            0x11838

//#######################################################################
//                    mipiA_registers area
//#######################################################################
#define RegMipiAVersion_offset                                    0x40000
#define RegMipiANumLanes_offset                                   0x40004
#define RegMipiAResetN_offset                                     0x40008
#define RegMipiAIntStMain_offset                                  0x4000C
#define RegMipiADataIds1_offset                                   0x40010
#define RegMipiADataIds2_offset                                   0x40014
#define RegMipiAPhyShutdownZ_offset                               0x40040
#define RegMipiADphyRstZ_offset                                   0x40044
#define RegMipiAPhyRx_offset                                      0x40048
#define RegMipiAPhyStopState_offset                               0x4004C
#define RegMipiAPhyTestCtrl0_offset                               0x40050
#define RegMipiAPhyTestCtrl1_offset                               0x40054
#define RegMipiAPhyCal_offset                                     0x400CC
#define RegMipiAIntStPhyFatal_offset                              0x400E0
#define RegMipiAIntMaskPhyFatal_offset                            0x400E4
#define RegMipiAIntForcePhyFatal_offset                           0x400E8
#define RegMipiAIntStPktFatal_offset                              0x400F0
#define RegMipiAIntMaskPktFatal_offset                            0x400F4
#define RegMipiAIntForcePktFatal_offset                           0x400F8
#define RegMipiAIntStFrameFatal_offset                            0x40100
#define RegMipiAIntMaskFrameFatal_offset                          0x40104
#define RegMipiAIntForceFrameFatal_offset                         0x40108
#define RegMipiAIntStPhy_offset                                   0x40110
#define RegMipiAIntMaskPhy_offset                                 0x40114
#define RegMipiAIntForcePhy_offset                                0x40118
#define RegMipiAIntStPkt_offset                                   0x40120
#define RegMipiAIntMaskPkt_offset                                 0x40124
#define RegMipiAIntForcePkt_offset                                0x40128
#define RegMipiAIntStLine_offset                                  0x40130
#define RegMipiAIntMaskLine_offset                                0x40134
#define RegMipiAIntForceLine_offset                               0x40138

//#######################################################################
//                    mipiB_registers area
//#######################################################################
#define RegMipiBVersion_offset                                    0x40400
#define RegMipiBNumLanes_offset                                   0x40404
#define RegMipiBResetN_offset                                     0x40408
#define RegMipiBIntStMain_offset                                  0x4040C
#define RegMipiBDataIds1_offset                                   0x40410
#define RegMipiBDataIds2_offset                                   0x40414
#define RegMipiBPhyShutdownZ_offset                               0x40440
#define RegMipiBDphyRstZ_offset                                   0x40444
#define RegMipiBPhyRx_offset                                      0x40448
#define RegMipiBPhyStopState_offset                               0x4044C
#define RegMipiBPhyTestCtrl0_offset                               0x40450
#define RegMipiBPhyTestCtrl1_offset                               0x40454
#define RegMipiBPhyCal_offset                                     0x404CC
#define RegMipiBIntStPhyFatal_offset                              0x404E0
#define RegMipiBIntMaskPhyFatal_offset                            0x404E4
#define RegMipiBIntForcePhyFatal_offset                           0x404E8
#define RegMipiBIntStPktFatal_offset                              0x404F0
#define RegMipiBIntMaskPktFatal_offset                            0x404F4
#define RegMipiBIntForcePktFatal_offset                           0x404F8
#define RegMipiBIntStFrameFatal_offset                            0x40500
#define RegMipiBIntMaskFrameFatal_offset                          0x40504
#define RegMipiBIntForceFrameFatal_offset                         0x40508
#define RegMipiBIntStPhy_offset                                   0x40510
#define RegMipiBIntMaskPhy_offset                                 0x40514
#define RegMipiBIntForcePhy_offset                                0x40518
#define RegMipiBIntStPkt_offset                                   0x40520
#define RegMipiBIntMaskPkt_offset                                 0x40524
#define RegMipiBIntForcePkt_offset                                0x40528
#define RegMipiBIntStLine_offset                                  0x40530
#define RegMipiBIntMaskLine_offset                                0x40534
#define RegMipiBIntForceLine_offset                               0x40538

//#######################################################################
//                    mipiM_registers area
//#######################################################################
#define RegMipiMVersion_offset                                    0x40800
#define RegMipiMNumLanes_offset                                   0x40804
#define RegMipiMResetN_offset                                     0x40808
#define RegMipiMIntStMain_offset                                  0x4080C
#define RegMipiMDataIds1_offset                                   0x40810
#define RegMipiMDataIds2_offset                                   0x40814
#define RegMipiMPhyShutdownZ_offset                               0x40840
#define RegMipiMDphyRstZ_offset                                   0x40844
#define RegMipiMPhyRx_offset                                      0x40848
#define RegMipiMPhyStopState_offset                               0x4084C
#define RegMipiMPhyTestCtrl0_offset                               0x40850
#define RegMipiMPhyTestCtrl1_offset                               0x40854
#define RegMipiMPhyCal_offset                                     0x408CC
#define RegMipiMIntStPhyFatal_offset                              0x408E0
#define RegMipiMIntMaskPhyFatal_offset                            0x408E4
#define RegMipiMIntForcePhyFatal_offset                           0x408E8
#define RegMipiMIntStPktFatal_offset                              0x408F0
#define RegMipiMIntMaskPktFatal_offset                            0x408F4
#define RegMipiMIntForcePktFatal_offset                           0x408F8
#define RegMipiMIntStFrameFatal_offset                            0x40900
#define RegMipiMIntMaskFrameFatal_offset                          0x40904
#define RegMipiMIntForceFrameFatal_offset                         0x40908
#define RegMipiMIntStPhy_offset                                   0x40910
#define RegMipiMIntMaskPhy_offset                                 0x40914
#define RegMipiMIntForcePhy_offset                                0x40918
#define RegMipiMIntStPkt_offset                                   0x40920
#define RegMipiMIntMaskPkt_offset                                 0x40924
#define RegMipiMIntForcePkt_offset                                0x40928
#define RegMipiMIntStLine_offset                                  0x40930
#define RegMipiMIntMaskLine_offset                                0x40934
#define RegMipiMIntForceLine_offset                               0x40938

//#######################################################################
//                    mipiY_registers area
//#######################################################################
#define RegMipiYVersion_offset                                    0x40C00
#define RegMipiYNumLanes_offset                                   0x40C04
#define RegMipiYResetN_offset                                     0x40C08
#define RegMipiYIntStMain_offset                                  0x40C0C
#define RegMipiYDataIds1_offset                                   0x40C10
#define RegMipiYDataIds2_offset                                   0x40C14
#define RegMipiYPhyShutdownZ_offset                               0x40C40
#define RegMipiYDphyRstZ_offset                                   0x40C44
#define RegMipiYPhyRx_offset                                      0x40C48
#define RegMipiYPhyStopState_offset                               0x40C4C
#define RegMipiYPhyTestCtrl0_offset                               0x40C50
#define RegMipiYPhyTestCtrl1_offset                               0x40C54
#define RegMipiYPhyCal_offset                                     0x40CCC
#define RegMipiYIntStPhyFatal_offset                              0x40CE0
#define RegMipiYIntMaskPhyFatal_offset                            0x40CE4
#define RegMipiYIntForcePhyFatal_offset                           0x40CE8
#define RegMipiYIntStPktFatal_offset                              0x40CF0
#define RegMipiYIntMaskPktFatal_offset                            0x40CF4
#define RegMipiYIntForcePktFatal_offset                           0x40CF8
#define RegMipiYIntStFrameFatal_offset                            0x40D00
#define RegMipiYIntMaskFrameFatal_offset                          0x40D04
#define RegMipiYIntForceFrameFatal_offset                         0x40D08
#define RegMipiYIntStPhy_offset                                   0x40D10
#define RegMipiYIntMaskPhy_offset                                 0x40D14
#define RegMipiYIntForcePhy_offset                                0x40D18
#define RegMipiYIntStPkt_offset                                   0x40D20
#define RegMipiYIntMaskPkt_offset                                 0x40D24
#define RegMipiYIntForcePkt_offset                                0x40D28
#define RegMipiYIntStLine_offset                                  0x40D30
#define RegMipiYIntMaskLine_offset                                0x40D34
#define RegMipiYIntForceLine_offset                               0x40D38

//#######################################################################
//                    mipiZ_registers area
//#######################################################################
#define RegMipiZVersion_offset                                    0x41080
#define RegMipiZNumLanes_offset                                   0x41084
#define RegMipiZResetN_offset                                     0x41088
#define RegMipiZIntStMain_offset                                  0x4108C
#define RegMipiZDataIds1_offset                                   0x41090
#define RegMipiZDataIds2_offset                                   0x41094
#define RegMipiZPhyShutdownZ_offset                               0x410C0
#define RegMipiZDphyRstZ_offset                                   0x410C4
#define RegMipiZPhyRx_offset                                      0x410C8
#define RegMipiZPhyStopState_offset                               0x410CC
#define RegMipiZPhyTestCtrl0_offset                               0x410D0
#define RegMipiZPhyTestCtrl1_offset                               0x410D4
#define RegMipiZPhyCal_offset                                     0x4114C
#define RegMipiZIntStPhyFatal_offset                              0x41160
#define RegMipiZIntMaskPhyFatal_offset                            0x41164
#define RegMipiZIntForcePhyFatal_offset                           0x41168
#define RegMipiZIntStPktFatal_offset                              0x41170
#define RegMipiZIntMaskPktFatal_offset                            0x41174
#define RegMipiZIntForcePktFatal_offset                           0x41178
#define RegMipiZIntStFrameFatal_offset                            0x41180
#define RegMipiZIntMaskFrameFatal_offset                          0x41184
#define RegMipiZIntForceFrameFatal_offset                         0x41188
#define RegMipiZIntStPhy_offset                                   0x41190
#define RegMipiZIntMaskPhy_offset                                 0x41194
#define RegMipiZIntForcePhy_offset                                0x41198
#define RegMipiZIntStPkt_offset                                   0x411A0
#define RegMipiZIntMaskPkt_offset                                 0x411A4
#define RegMipiZIntForcePkt_offset                                0x411A8
#define RegMipiZIntStLine_offset                                  0x411B0
#define RegMipiZIntMaskLine_offset                                0x411B4
#define RegMipiZIntForceLine_offset                               0x411B8

//#######################################################################
//                      mtr_registers area
//#######################################################################
#define RegMtrTransmitterControl_offset                           0x41404
#define RegMtrDphyControlStatus_offset                            0x41408
#define RegMtrDphyTestAccess_offset                               0x4140C
#define RegMtrId_offset                                           0x41400

//#######################################################################
//                mtr_tx_rx_registers area
//#######################################################################
#define RegMtr_tx_rxTransmitterControl_offset                     0x41004
#define RegMtr_tx_rxDphyControlStatus_offset                      0x41008
#define RegMtr_tx_rxDphyTestAccess_offset                         0x4100C
#define RegMtr_tx_rxId_offset                                     0x41000

//#######################################################################
//                      rec_registers area
//#######################################################################
#define RegRecCaptureFrames_offset                                0x100000
#define RegRecVerticalBlankingTime_offset                         0x100004
#define RegRecPixelBufferRightOffset_offset                       0x100008
#define RegRecRecPowerControl_offset                              0x10000C
#define RegRecRecPixelPacing_offset                               0x100010
#define RegRecRecBufferFill_offset                                0x100014
#define RegRecRecHaltLineMargin_offset                            0x100018
#define RegRecRecRunOnOff_offset                                  0x10001C
#define RegRecC0b0LeftMatrixCoefficients1_offset                  0x100020
#define RegRecC0b0LeftMatrixCoefficients2_offset                  0x100024
#define RegRecC0b0LeftMatrixCoefficients3_offset                  0x100028
#define RegRecC0b0LeftMatrixCoefficients4_offset                  0x10002C
#define RegRecC0b0LeftMatrixCoefficients5_offset                  0x100030
#define RegRecC0b0LeftMatrixCoefficients6_offset                  0x100034
#define RegRecC0b0LeftMatrixCoefficients7_offset                  0x100038
#define RegRecC0b0LeftMatrixCoefficients8_offset                  0x10003C
#define RegRecC0b0LeftMatrixCoefficients9_offset                  0x100040
#define RegRecC0b0LeftDistortionParameters1_offset                0x100044
#define RegRecC0b0LeftDistortionParameters2_offset                0x100048
#define RegRecC0b0LeftDistortionParameters3_offset                0x10004C
#define RegRecC0b0LeftDistortionParameters4_offset                0x100050
#define RegRecC0b0LeftDistortionParameters5_offset                0x100054
#define RegRecC0b0LeftFocalLengthParameters1_offset               0x100058
#define RegRecC0b0LeftFocalLengthParameters2_offset               0x10005C
#define RegRecC0b0LeftCenterParameters1_offset                    0x100060
#define RegRecC0b0LeftCenterParameters2_offset                    0x100064
#define RegRecC0b0RightMatrixCoefficients1_offset                 0x100070
#define RegRecC0b0RightMatrixCoefficients2_offset                 0x100074
#define RegRecC0b0RightMatrixCoefficients3_offset                 0x100078
#define RegRecC0b0RightMatrixCoefficients4_offset                 0x10007C
#define RegRecC0b0RightMatrixCoefficients5_offset                 0x100080
#define RegRecC0b0RightMatrixCoefficients6_offset                 0x100084
#define RegRecC0b0RightMatrixCoefficients7_offset                 0x100088
#define RegRecC0b0RightMatrixCoefficients8_offset                 0x10008C
#define RegRecC0b0RightMatrixCoefficients9_offset                 0x100090
#define RegRecC0b0RightDistortionParameters1_offset               0x100094
#define RegRecC0b0RightDistortionParameters2_offset               0x100098
#define RegRecC0b0RightDistortionParameters3_offset               0x10009C
#define RegRecC0b0RightDistortionParameters4_offset               0x1000A0
#define RegRecC0b0RightDistortionParameters5_offset               0x1000A4
#define RegRecC0b0RightFocalLengthParameters1_offset              0x1000A8
#define RegRecC0b0RightFocalLengthParameters2_offset              0x1000AC
#define RegRecC0b0RightCenterParameters1_offset                   0x1000B0
#define RegRecC0b0RightCenterParameters2_offset                   0x1000B4
#define RegRecC0b1LeftMatrixCoefficients1_offset                  0x1000C0
#define RegRecC0b1LeftMatrixCoefficients2_offset                  0x1000C4
#define RegRecC0b1LeftMatrixCoefficients3_offset                  0x1000C8
#define RegRecC0b1LeftMatrixCoefficients4_offset                  0x1000CC
#define RegRecC0b1LeftMatrixCoefficients5_offset                  0x1000D0
#define RegRecC0b1LeftMatrixCoefficients6_offset                  0x1000D4
#define RegRecC0b1LeftMatrixCoefficients7_offset                  0x1000D8
#define RegRecC0b1LeftMatrixCoefficients8_offset                  0x1000DC
#define RegRecC0b1LeftMatrixCoefficients9_offset                  0x1000E0
#define RegRecC0b1LeftDistortionParameters1_offset                0x1000E4
#define RegRecC0b1LeftDistortionParameters2_offset                0x1000E8
#define RegRecC0b1LeftDistortionParameters3_offset                0x1000EC
#define RegRecC0b1LeftDistortionParameters4_offset                0x1000F0
#define RegRecC0b1LeftDistortionParameters5_offset                0x1000F4
#define RegRecC0b1LeftFocalLengthParameters1_offset               0x1000F8
#define RegRecC0b1LeftFocalLengthParameters2_offset               0x1000FC
#define RegRecC0b1LeftCenterParameters1_offset                    0x100100
#define RegRecC0b1LeftCenterParameters2_offset                    0x100104
#define RegRecC0b1RightMatrixCoefficients1_offset                 0x100110
#define RegRecC0b1RightMatrixCoefficients2_offset                 0x100114
#define RegRecC0b1RightMatrixCoefficients3_offset                 0x100118
#define RegRecC0b1RightMatrixCoefficients4_offset                 0x10011C
#define RegRecC0b1RightMatrixCoefficients5_offset                 0x100120
#define RegRecC0b1RightMatrixCoefficients6_offset                 0x100124
#define RegRecC0b1RightMatrixCoefficients7_offset                 0x100128
#define RegRecC0b1RightMatrixCoefficients8_offset                 0x10012C
#define RegRecC0b1RightMatrixCoefficients9_offset                 0x100130
#define RegRecC0b1RightDistortionParameters1_offset               0x100134
#define RegRecC0b1RightDistortionParameters2_offset               0x100138
#define RegRecC0b1RightDistortionParameters3_offset               0x10013C
#define RegRecC0b1RightDistortionParameters4_offset               0x100140
#define RegRecC0b1RightDistortionParameters5_offset               0x100144
#define RegRecC0b1RightFocalLengthParameters1_offset              0x100148
#define RegRecC0b1RightFocalLengthParameters2_offset              0x10014C
#define RegRecC0b1RightCenterParameters1_offset                   0x100150
#define RegRecC0b1RightCenterParameters2_offset                   0x100154
#define RegRecC1b0LeftMatrixCoefficients1_offset                  0x100160
#define RegRecC1b0LeftMatrixCoefficients2_offset                  0x100164
#define RegRecC1b0LeftMatrixCoefficients3_offset                  0x100168
#define RegRecC1b0LeftMatrixCoefficients4_offset                  0x10016C
#define RegRecC1b0LeftMatrixCoefficients5_offset                  0x100170
#define RegRecC1b0LeftMatrixCoefficients6_offset                  0x100174
#define RegRecC1b0LeftMatrixCoefficients7_offset                  0x100178
#define RegRecC1b0LeftMatrixCoefficients8_offset                  0x10017C
#define RegRecC1b0LeftMatrixCoefficients9_offset                  0x100180
#define RegRecC1b0LeftDistortionParameters1_offset                0x100184
#define RegRecC1b0LeftDistortionParameters2_offset                0x100188
#define RegRecC1b0LeftDistortionParameters3_offset                0x10018C
#define RegRecC1b0LeftDistortionParameters4_offset                0x100190
#define RegRecC1b0LeftDistortionParameters5_offset                0x100194
#define RegRecC1b0LeftFocalLengthParameters1_offset               0x100198
#define RegRecC1b0LeftFocalLengthParameters2_offset               0x10019C
#define RegRecC1b0LeftCenterParameters1_offset                    0x1001A0
#define RegRecC1b0LeftCenterParameters2_offset                    0x1001A4
#define RegRecC1b0RightMatrixCoefficients1_offset                 0x1001B0
#define RegRecC1b0RightMatrixCoefficients2_offset                 0x1001B4
#define RegRecC1b0RightMatrixCoefficients3_offset                 0x1001B8
#define RegRecC1b0RightMatrixCoefficients4_offset                 0x1001BC
#define RegRecC1b0RightMatrixCoefficients5_offset                 0x1001C0
#define RegRecC1b0RightMatrixCoefficients6_offset                 0x1001C4
#define RegRecC1b0RightMatrixCoefficients7_offset                 0x1001C8
#define RegRecC1b0RightMatrixCoefficients8_offset                 0x1001CC
#define RegRecC1b0RightMatrixCoefficients9_offset                 0x1001D0
#define RegRecC1b0RightDistortionParameters1_offset               0x1001D4
#define RegRecC1b0RightDistortionParameters2_offset               0x1001D8
#define RegRecC1b0RightDistortionParameters3_offset               0x1001DC
#define RegRecC1b0RightDistortionParameters4_offset               0x1001E0
#define RegRecC1b0RightDistortionParameters5_offset               0x1001E4
#define RegRecC1b0RightFocalLengthParameters1_offset              0x1001E8
#define RegRecC1b0RightFocalLengthParameters2_offset              0x1001EC
#define RegRecC1b0RightCenterParameters1_offset                   0x1001F0
#define RegRecC1b0RightCenterParameters2_offset                   0x1001F4
#define RegRecC1b1LeftMatrixCoefficients1_offset                  0x100200
#define RegRecC1b1LeftMatrixCoefficients2_offset                  0x100204
#define RegRecC1b1LeftMatrixCoefficients3_offset                  0x100208
#define RegRecC1b1LeftMatrixCoefficients4_offset                  0x10020C
#define RegRecC1b1LeftMatrixCoefficients5_offset                  0x100210
#define RegRecC1b1LeftMatrixCoefficients6_offset                  0x100214
#define RegRecC1b1LeftMatrixCoefficients7_offset                  0x100218
#define RegRecC1b1LeftMatrixCoefficients8_offset                  0x10021C
#define RegRecC1b1LeftMatrixCoefficients9_offset                  0x100220
#define RegRecC1b1LeftDistortionParameters1_offset                0x100224
#define RegRecC1b1LeftDistortionParameters2_offset                0x100228
#define RegRecC1b1LeftDistortionParameters3_offset                0x10022C
#define RegRecC1b1LeftDistortionParameters4_offset                0x100230
#define RegRecC1b1LeftDistortionParameters5_offset                0x100234
#define RegRecC1b1LeftFocalLengthParameters1_offset               0x100238
#define RegRecC1b1LeftFocalLengthParameters2_offset               0x10023C
#define RegRecC1b1LeftCenterParameters1_offset                    0x100240
#define RegRecC1b1LeftCenterParameters2_offset                    0x100244
#define RegRecC1b1RightMatrixCoefficients1_offset                 0x100250
#define RegRecC1b1RightMatrixCoefficients2_offset                 0x100254
#define RegRecC1b1RightMatrixCoefficients3_offset                 0x100258
#define RegRecC1b1RightMatrixCoefficients4_offset                 0x10025C
#define RegRecC1b1RightMatrixCoefficients5_offset                 0x100260
#define RegRecC1b1RightMatrixCoefficients6_offset                 0x100264
#define RegRecC1b1RightMatrixCoefficients7_offset                 0x100268
#define RegRecC1b1RightMatrixCoefficients8_offset                 0x10026C
#define RegRecC1b1RightMatrixCoefficients9_offset                 0x100270
#define RegRecC1b1RightDistortionParameters1_offset               0x100274
#define RegRecC1b1RightDistortionParameters2_offset               0x100278
#define RegRecC1b1RightDistortionParameters3_offset               0x10027C
#define RegRecC1b1RightDistortionParameters4_offset               0x100280
#define RegRecC1b1RightDistortionParameters5_offset               0x100284
#define RegRecC1b1RightFocalLengthParameters1_offset              0x100288
#define RegRecC1b1RightFocalLengthParameters2_offset              0x10028C
#define RegRecC1b1RightCenterParameters1_offset                   0x100290
#define RegRecC1b1RightCenterParameters2_offset                   0x100294
#define RegRecCamera0RecControlRegister_offset                    0x1002B0
#define RegRecCamera0IdentityCoefficient_offset                   0x1002B4
#define RegRecCamera0RectifiedImageSize_offset                    0x1002B8
#define RegRecCamera0InputImageSize_offset                        0x1002BC
#define RegRecCamera0ExposureTopEdge_offset                       0x1002C0
#define RegRecCamera0ExposureBottomEdge_offset                    0x1002C4
#define RegRecCamera0ExposureLeftEdge_offset                      0x1002C8
#define RegRecCamera0ExposureRightEdge_offset                     0x1002CC
#define RegRecCamera0ExposureLeftDarkThreshold_offset             0x1002D0
#define RegRecCamera0ExposureLeftBrightThreshold_offset           0x1002D4
#define RegRecCamera0ExposureRightDarkThreshold_offset            0x1002D8
#define RegRecCamera0ExposureRightBrightThreshold_offset          0x1002DC
#define RegRecCamera0YuvMatrixEntry00_offset                      0x1002E4
#define RegRecCamera0YuvMatrixEntry10_offset                      0x1002E8
#define RegRecCamera0YuvMatrixEntry20_offset                      0x1002EC
#define RegRecCamera0YuvMatrixEntry30_offset                      0x1002F0
#define RegRecCamera0YuvMatrixEntry01_offset                      0x1002F4
#define RegRecCamera0YuvMatrixEntry11_offset                      0x1002F8
#define RegRecCamera0YuvMatrixEntry21_offset                      0x1002FC
#define RegRecCamera0YuvMatrixEntry31_offset                      0x100300
#define RegRecCamera0YuvMatrixEntry02_offset                      0x100304
#define RegRecCamera0YuvMatrixEntry12_offset                      0x100308
#define RegRecCamera0YuvMatrixEntry22_offset                      0x10030C
#define RegRecCamera0YuvMatrixEntry32_offset                      0x100310
#define RegRecCamera0YuvVector0_offset                            0x100314
#define RegRecCamera0YuvVector1_offset                            0x100318
#define RegRecCamera0YuvVector2_offset                            0x10031C
#define RegRecCamera1RecControlRegister_offset                    0x100340
#define RegRecCamera1IdentityCoefficient_offset                   0x100344
#define RegRecCamera1RectifiedImageSize_offset                    0x100348
#define RegRecCamera1InputImageSize_offset                        0x10034C
#define RegRecCamera1ExposureTopEdge_offset                       0x100350
#define RegRecCamera1ExposureBottomEdge_offset                    0x100354
#define RegRecCamera1ExposureLeftEdge_offset                      0x100358
#define RegRecCamera1ExposureRightEdge_offset                     0x10035C
#define RegRecCamera1ExposureLeftDarkThreshold_offset             0x100360
#define RegRecCamera1ExposureLeftBrightThreshold_offset           0x100364
#define RegRecCamera1ExposureRightDarkThreshold_offset            0x100368
#define RegRecCamera1ExposureRightBrightThreshold_offset          0x10036C
#define RegRecCamera1YuvMatrixEntry00_offset                      0x100374
#define RegRecCamera1YuvMatrixEntry10_offset                      0x100378
#define RegRecCamera1YuvMatrixEntry20_offset                      0x10037C
#define RegRecCamera1YuvMatrixEntry30_offset                      0x100380
#define RegRecCamera1YuvMatrixEntry01_offset                      0x100384
#define RegRecCamera1YuvMatrixEntry11_offset                      0x100388
#define RegRecCamera1YuvMatrixEntry21_offset                      0x10038C
#define RegRecCamera1YuvMatrixEntry31_offset                      0x100390
#define RegRecCamera1YuvMatrixEntry02_offset                      0x100394
#define RegRecCamera1YuvMatrixEntry12_offset                      0x100398
#define RegRecCamera1YuvMatrixEntry22_offset                      0x10039C
#define RegRecCamera1YuvMatrixEntry32_offset                      0x1003A0
#define RegRecCamera1YuvVector0_offset                            0x1003A4
#define RegRecCamera1YuvVector1_offset                            0x1003A8
#define RegRecCamera1YuvVector2_offset                            0x1003AC
#define RegRecRangeLutTranslation_offset                          0x1003C0
#define RegRecExposureLeftSum_offset                              0x100400
#define RegRecExposureRightSum_offset                             0x100404
#define RegRecExposureLeftDarkcount_offset                        0x100408
#define RegRecExposureRightDarkCount_offset                       0x10040C
#define RegRecExposureLeftBrightCount_offset                      0x100410
#define RegRecExposureRightBrightCount_offset                     0x100414
#define RegRecWhiteBalanceLeftRedSum_offset                       0x100440
#define RegRecWhiteBalanceLeftGreen1Sum_offset                    0x100444
#define RegRecWhiteBalanceLeftGreen2Sum_offset                    0x100448
#define RegRecWhiteBalanceLeftBlueSum_offset                      0x10044C
#define RegRecWhiteBalanceRightRedSum_offset                      0x100450
#define RegRecWhiteBalanceRightGreen1Sum_offset                   0x100454
#define RegRecWhiteBalanceRightGreen2Sum_offset                   0x100458
#define RegRecWhiteBalanceRightBlueSum_offset                     0x10045C
#define RegRecNoRunChangeStatus_offset                            0x100460
#define RegRecRecStatusRegister_offset                            0x100480
#define RegRecWriteRam00OfPixelData_offset                        0x100500
#define RegRecWriteRam01OfPixelData_offset                        0x100504
#define RegRecWriteRam02OfPixelData_offset                        0x100508
#define RegRecWriteRam03OfPixelData_offset                        0x10050C
#define RegRecWriteRam04OfPixelData_offset                        0x100510
#define RegRecWriteRam05OfPixelData_offset                        0x100514
#define RegRecWriteRam06OfPixelData_offset                        0x100518
#define RegRecWriteRam07OfPixelData_offset                        0x10051C
#define RegRecWriteRam08OfPixelData_offset                        0x100520
#define RegRecWriteRam09OfPixelData_offset                        0x100524
#define RegRecWriteRam10OfPixelData_offset                        0x100528
#define RegRecWriteRam11OfPixelData_offset                        0x10052C
#define RegRecWriteRam12OfPixelData_offset                        0x100530
#define RegRecWriteRam13OfPixelData_offset                        0x100534
#define RegRecWriteRam14OfPixelData_offset                        0x100538
#define RegRecWriteRam15OfPixelData_offset                        0x10053C
#define RegRecWriteRam16OfPixelData_offset                        0x100540
#define RegRecWriteRam17OfPixelData_offset                        0x100544
#define RegRecWriteRam18OfPixelData_offset                        0x100548
#define RegRecWriteRam19OfPixelData_offset                        0x10054C
#define RegRecWriteRam20OfPixelData_offset                        0x100550
#define RegRecWriteRam21OfPixelData_offset                        0x100554
#define RegRecWriteRam22OfPixelData_offset                        0x100558
#define RegRecWriteRam23OfPixelData_offset                        0x10055C
#define RegRecWriteRam24OfPixelData_offset                        0x100560
#define RegRecWriteRam25OfPixelData_offset                        0x100564
#define RegRecWriteRam26OfPixelData_offset                        0x100568
#define RegRecWriteRam27OfPixelData_offset                        0x10056C
#define RegRecWriteRam28OfPixelData_offset                        0x100570
#define RegRecWriteRam29OfPixelData_offset                        0x100574
#define RegRecWriteRam30OfPixelData_offset                        0x100578
#define RegRecWriteRam31OfPixelData_offset                        0x10057C
#define RegRecPixelBufferWriteControlBit_offset                   0x100580
#define RegRecPixelBufferWriteAddress_offset                      0x100584
#define RegRecReadRam00OfPixelData_offset                         0x100600
#define RegRecReadRam01OfPixelData_offset                         0x100604
#define RegRecReadRam02OfPixelData_offset                         0x100608
#define RegRecReadRam03OfPixelData_offset                         0x10060C
#define RegRecReadRam04OfPixelData_offset                         0x100610
#define RegRecReadRam05OfPixelData_offset                         0x100614
#define RegRecReadRam06OfPixelData_offset                         0x100618
#define RegRecReadRam07OfPixelData_offset                         0x10061C
#define RegRecReadRam08OfPixelData_offset                         0x100620
#define RegRecReadRam09OfPixelData_offset                         0x100624
#define RegRecReadRam10OfPixelData_offset                         0x100628
#define RegRecReadRam11OfPixelData_offset                         0x10062C
#define RegRecReadRam12OfPixelData_offset                         0x100630
#define RegRecReadRam13OfPixelData_offset                         0x100634
#define RegRecReadRam14OfPixelData_offset                         0x100638
#define RegRecReadRam15OfPixelData_offset                         0x10063C
#define RegRecReadRam16OfPixelData_offset                         0x100640
#define RegRecReadRam17OfPixelData_offset                         0x100644
#define RegRecReadRam18OfPixelData_offset                         0x100648
#define RegRecReadRam19OfPixelData_offset                         0x10064C
#define RegRecReadRam20OfPixelData_offset                         0x100650
#define RegRecReadRam21OfPixelData_offset                         0x100654
#define RegRecReadRam22OfPixelData_offset                         0x100658
#define RegRecReadRam23OfPixelData_offset                         0x10065C
#define RegRecReadRam24OfPixelData_offset                         0x100660
#define RegRecReadRam25OfPixelData_offset                         0x100664
#define RegRecReadRam26OfPixelData_offset                         0x100668
#define RegRecReadRam27OfPixelData_offset                         0x10066C
#define RegRecReadRam28OfPixelData_offset                         0x100670
#define RegRecReadRam29OfPixelData_offset                         0x100674
#define RegRecReadRam30OfPixelData_offset                         0x100678
#define RegRecReadRam31OfPixelData_offset                         0x10067C
#define RegRecPixelBufferReadControlBit_offset                    0x100680
#define RegRecPixelBufferReadAddress_offset                       0x100684
#define RegRecRecTestRegIf_offset                                 0x100700
#define RegRecRecTpgenVblank_offset                               0x100704
#define RegRecRecTpgenHblank_offset                               0x100708
#define RegRecRecTpgenStartValue_offset                           0x10070C
#define RegRecRecTpgenSpeed_offset                                0x100710
#define RegRecRecFrameCounter_offset                              0x100714
#define RegRecRecInframeSclkCount_offset                          0x100718
#define RegRecRecOutframeSclkCount_offset                         0x10071C

//#######################################################################
//                      scp_registers area
//#######################################################################
#define RegScpRsmControlReg_offset                                0x20000
#define RegScpAdditionalVblank_offset                             0x20004
#define RegScpLocalClkGateEnable_offset                           0x20008
#define RegScpCensusEnableReg_offset                              0x20010
#define RegScpScpImageSize_offset                                 0x2003C
#define RegScpDeepseaRobbinsMunroe_offset                         0x20718
#define RegScpDeepseaScoreThreshold_offset                        0x2071C
#define RegScpDeepseaNeighborThreshold_offset                     0x20720
#define RegScpDeepseaLrThreshold_offset                           0x20724
#define RegScpDeepseaTextureThreshold_offset                      0x20728
#define RegScpDeepseaSecondPeakThreshold_offset                   0x2072C
#define RegScpDeepseaMedianThreshold_offset                       0x20730
#define RegScpZencoderReg0_offset                                 0x2074C
#define RegScpZencoderReg1_offset                                 0x20750
#define RegScpRauSupportVectorMinima_offset                       0x20754
#define RegScpColorControl_offset                                 0x20758
#define RegScpRauThreshold_offset                                 0x20760
#define RegScpSloThreshold_offset                                 0x20764
#define RegScpSloK1penalty_offset                                 0x2076C
#define RegScpSloK2penalty_offset                                 0x20770
#define RegScpSloK1penaltymod1_offset                             0x20774
#define RegScpSloK1penaltymod2_offset                             0x20778
#define RegScpSloK2penaltymod1_offset                             0x2077C
#define RegScpSloK2penaltymod2_offset                             0x20780
#define RegScpHammingDistanceLookupTable_offset                   0x20800
#define RegScpSadLookupTable_offset                               0x20C00
#define RegScpRauInverseTable_offset                              0x21000
#define RegScpInterestLookupTable_offset                          0x22000
#define RegScpSubPixelLookupTable_offset                          0x24000
#define RegScpRangeLookupTable_offset                             0x30000
#define RegScpAlphaLookupTable_offset                             0x23000

//#######################################################################
//                      see_registers area
//#######################################################################
#define RegSeeCtrl0_offset                                        0x10400
#define RegSeeCtrl1_offset                                        0x10404
#define RegSeeSpiEnable_offset                                    0x10408
#define RegSeeShaDataWr_offset                                    0x1040C
#define RegSeeShaDataWrSwapped_offset                             0x10410
#define RegSeeBaudRateDivisor_offset                              0x10414
#define RegSeeTransmitFifoThreshold_offset                        0x10418
#define RegSeeReceiveFifoThreshold_offset                         0x1041C
#define RegSeeTransmitFifoLevel_offset                            0x10420
#define RegSeeReceiveFifoLevel_offset                             0x10424
#define RegSeeStatusRegister_offset                               0x10428
#define RegSeeInterruptMask_offset                                0x1042C
#define RegSeeInterruptStatus_offset                              0x10430
#define RegSeeRawInterruptStatus_offset                           0x10434
#define RegSeeClearTransmitFifoOverflow_offset                    0x10438
#define RegSeeClearReceiveFifoOverflow_offset                     0x1043C
#define RegSeeClearReceiveFifoUnderflow_offset                    0x10440
#define RegSeeIrqClear_offset                                     0x10448
#define RegSeeShaCmd_offset                                       0x1044C
#define RegSeeShaDigest_offset                                    0x10450
#define RegSeeShaDigestSwapped_offset                             0x10454
#define RegSeeIdentificationCode_offset                           0x10458
#define RegSeeVersion_offset                                      0x1045C
#define RegSeeDataReg0_offset                                     0x10460
#define RegSeeDataReg1_offset                                     0x10464
#define RegSeeDataReg2_offset                                     0x10468
#define RegSeeDataReg3_offset                                     0x1046C
#define RegSeeDataReg4_offset                                     0x10470
#define RegSeeDataReg5_offset                                     0x10474
#define RegSeeDataReg6_offset                                     0x10478
#define RegSeeDataReg7_offset                                     0x1047C
#define RegSeeDataReg8_offset                                     0x10480
#define RegSeeDataReg9_offset                                     0x10484
#define RegSeeDataReg10_offset                                    0x10488
#define RegSeeDataReg11_offset                                    0x1048C
#define RegSeeDataReg12_offset                                    0x10490
#define RegSeeDataReg13_offset                                    0x10494
#define RegSeeDataReg14_offset                                    0x10498
#define RegSeeDataReg15_offset                                    0x1049C
#define RegSeeDataReg16_offset                                    0x104A0
#define RegSeeDataReg17_offset                                    0x104A4
#define RegSeeDataReg18_offset                                    0x104A8
#define RegSeeDataReg19_offset                                    0x104AC
#define RegSeeDataReg20_offset                                    0x104B0
#define RegSeeDataReg21_offset                                    0x104B4
#define RegSeeDataReg22_offset                                    0x104B8
#define RegSeeDataReg23_offset                                    0x104BC
#define RegSeeDataReg24_offset                                    0x104C0
#define RegSeeDataReg25_offset                                    0x104C4
#define RegSeeDataReg26_offset                                    0x104C8
#define RegSeeDataReg27_offset                                    0x104CC
#define RegSeeDataReg28_offset                                    0x104D0
#define RegSeeDataReg29_offset                                    0x104D4
#define RegSeeDataReg30_offset                                    0x104D8
#define RegSeeDataReg31_offset                                    0x104DC
#define RegSeeDataReg32_offset                                    0x104E0
#define RegSeeDataReg33_offset                                    0x104E4
#define RegSeeDataReg34_offset                                    0x104E8
#define RegSeeDataReg35_offset                                    0x104EC
#define RegSeeFifoInfo_offset                                     0x104F0

//#######################################################################
//                    tproc_registers area
//#######################################################################
#define RegTprocRegstprocen_offset                                0x16400
#define RegTprocRegstprocbypass_offset                            0x16404
#define RegTprocRegstprocisomode_offset                           0x16408
#define RegTprocRegstprocep2framecfg_offset                       0x1640C
#define RegTprocRegstprocep3framecfg_offset                       0x16410
#define RegTprocRegstprocep4framecfg_offset                       0x16414
#define RegTprocRegstprocep2gran_offset                           0x16418
#define RegTprocRegstprocep3gran_offset                           0x1641C
#define RegTprocRegstprocep4gran_offset                           0x16420
#define RegTprocRegstprocep2trbthrsld_offset                      0x16424
#define RegTprocRegstprocep3trbthrsld_offset                      0x16428
#define RegTprocRegstprocep4trbthrsld_offset                      0x1642C
#define RegTprocRegstprocep2eventclr_offset                       0x16430
#define RegTprocRegstprocep3eventclr_offset                       0x16434
#define RegTprocRegstprocep4eventclr_offset                       0x16438
#define RegTprocRegstprocep2active_offset                         0x1643C
#define RegTprocRegstprocep3active_offset                         0x16440
#define RegTprocRegstprocep4active_offset                         0x16444
#define RegTprocRegstprocep2minaddr_offset                        0x16448
#define RegTprocRegstprocep2maxaddr_offset                        0x1644C
#define RegTprocRegstprocep3minaddr_offset                        0x16450
#define RegTprocRegstprocep3maxaddr_offset                        0x16454
#define RegTprocRegstprocep4minaddr_offset                        0x16458
#define RegTprocRegstprocep4maxaddr_offset                        0x1645C
#define RegTprocRegstprocep2hdrsize_offset                        0x16460
#define RegTprocRegstprocep3hdrsize_offset                        0x16464
#define RegTprocRegstprocep4hdrsize_offset                        0x1646C
#define RegTprocRegstprocendxferen_offset                         0x16470
#define RegTprocRegstprocep2fwhalt_offset                         0x16474
#define RegTprocRegstprocep3fwhalt_offset                         0x16478
#define RegTprocRegstprocep4fwhalt_offset                         0x1647C
#define RegTprocRegstprocep2flushfrmid_offset                     0x16480
#define RegTprocRegstprocep3flushfrmid_offset                     0x16484
#define RegTprocRegstprocep4flushfrmid_offset                     0x16488
#define RegTprocRegstprocstartxfercmd_offset                      0x1648C
#define RegTprocRegstprocupdxfercmd_offset                        0x16490
#define RegTprocRegstprocendxfercmd_offset                        0x16494
#define RegTprocRegstproceppriority_offset                        0x16498
#define RegTprocRegstproccmdqflush_offset                         0x1649C
#define RegTprocRegstprocep2tailmetaaddr_offset                   0x164A0
#define RegTprocRegstprocep3tailmetaaddr_offset                   0x164A4
#define RegTprocRegstprocep4tailmetaaddr_offset                   0x164A8
#define RegTprocRegstprocep2tdstartaddr_offset                    0x164AC
#define RegTprocRegstprocep3tdstartaddr_offset                    0x164B0
#define RegTprocRegstprocep4tdstartaddr_offset                    0x164B4
#define RegTprocRegstprocep2frmid_offset                          0x164B8
#define RegTprocRegstprocep3frmid_offset                          0x164BC
#define RegTprocRegstprocep4frmid_offset                          0x164C0
#define RegTprocRegstprocep2shadowupd_offset                      0x164C4
#define RegTprocRegstprocep3shadowupd_offset                      0x164C8
#define RegTprocRegstprocep4shadowupd_offset                      0x164CC
#define RegTprocRegstprocupdcfg_offset                            0x164D0
#define RegTprocRegstprocep2bufminaddr_offset                     0x164D4
#define RegTprocRegstprocep2bufmaxaddr_offset                     0x164D8
#define RegTprocRegstprocep3bufminaddr_offset                     0x164DC
#define RegTprocRegstprocep3bufmaxaddr_offset                     0x164E0
#define RegTprocRegstprocep4bufminaddr_offset                     0x164E4
#define RegTprocRegstprocep4bufmaxaddr_offset                     0x164E8
#define RegTprocRegstprocep2force_offset                          0x164EC
#define RegTprocRegstprocep3force_offset                          0x164F0
#define RegTprocRegstprocep4force_offset                          0x164F4
#define RegTprocRegstproceventpntr_offset                         0x164F8
#define RegTprocRegstprocep2hdrtrb0_offset                        0x16800
#define RegTprocRegstprocep2hdrtrb1_offset                        0x16804
#define RegTprocRegstprocep2hdrtrb2_offset                        0x16808
#define RegTprocRegstprocep2hdrtrb3_offset                        0x1680C
#define RegTprocRegstprocep2metatrb0_offset                       0x16810
#define RegTprocRegstprocep2metatrb1_offset                       0x16814
#define RegTprocRegstprocep2metatrb2_offset                       0x16818
#define RegTprocRegstprocep2metatrb3_offset                       0x1681C
#define RegTprocRegstprocep2nsetrb0_offset                        0x16820
#define RegTprocRegstprocep2nsetrb1_offset                        0x16824
#define RegTprocRegstprocep2nsetrb2_offset                        0x16828
#define RegTprocRegstprocep2nsetrb3_offset                        0x1682C
#define RegTprocRegstprocep2frmdattrb0_offset                     0x16830
#define RegTprocRegstprocep2frmdattrb1_offset                     0x16834
#define RegTprocRegstprocep2frmdattrb2_offset                     0x16838
#define RegTprocRegstprocep2frmdattrb3_offset                     0x1683C
#define RegTprocRegstprocep2dataltrb0_offset                      0x16840
#define RegTprocRegstprocep2dataltrb1_offset                      0x16844
#define RegTprocRegstprocep2dataltrb2_offset                      0x16848
#define RegTprocRegstprocep2dataltrb3_offset                      0x1684C
#define RegTprocRegstprocep2zlptrb0_offset                        0x16850
#define RegTprocRegstprocep2zlptrb1_offset                        0x16854
#define RegTprocRegstprocep2zlptrb2_offset                        0x16858
#define RegTprocRegstprocep2zlptrb3_offset                        0x1685C
#define RegTprocRegstprocep2event0_offset                         0x16C00
#define RegTprocRegstprocep2event1_offset                         0x16C04
#define RegTprocRegstprocep2event2_offset                         0x16C08
#define RegTprocRegstprocep2event3_offset                         0x16C0C
#define RegTprocRegstprocep2event4_offset                         0x16C10
#define RegTprocRegstprocep2event5_offset                         0x16C14
#define RegTprocRegstprocep2event6_offset                         0x16C18
#define RegTprocRegstprocep2event7_offset                         0x16C1C
#define RegTprocRegstprocep2event8_offset                         0x16C20
#define RegTprocRegstprocep2event9_offset                         0x16C24
#define RegTprocRegstprocep3hdrtrb0_offset                        0x16900
#define RegTprocRegstprocep3hdrtrb1_offset                        0x16904
#define RegTprocRegstprocep3hdrtrb2_offset                        0x16908
#define RegTprocRegstprocep3hdrtrb3_offset                        0x1690C
#define RegTprocRegstprocep3metatrb0_offset                       0x16910
#define RegTprocRegstprocep3metatrb1_offset                       0x16914
#define RegTprocRegstprocep3metatrb2_offset                       0x16918
#define RegTprocRegstprocep3metatrb3_offset                       0x1691C
#define RegTprocRegstprocep3nsetrb0_offset                        0x16920
#define RegTprocRegstprocep3nsetrb1_offset                        0x16924
#define RegTprocRegstprocep3nsetrb2_offset                        0x16928
#define RegTprocRegstprocep3nsetrb3_offset                        0x1692C
#define RegTprocRegstprocep3frmdattrb0_offset                     0x16930
#define RegTprocRegstprocep3frmdattrb1_offset                     0x16934
#define RegTprocRegstprocep3frmdattrb2_offset                     0x16938
#define RegTprocRegstprocep3frmdattrb3_offset                     0x1693C
#define RegTprocRegstprocep3dataltrb0_offset                      0x16940
#define RegTprocRegstprocep3dataltrb1_offset                      0x16944
#define RegTprocRegstprocep3dataltrb2_offset                      0x16948
#define RegTprocRegstprocep3dataltrb3_offset                      0x1694C
#define RegTprocRegstprocep3zlptrb0_offset                        0x16950
#define RegTprocRegstprocep3zlptrb1_offset                        0x16954
#define RegTprocRegstprocep3zlptrb2_offset                        0x16958
#define RegTprocRegstprocep3zlptrb3_offset                        0x1695C
#define RegTprocRegstprocep3event0_offset                         0x16D00
#define RegTprocRegstprocep3event1_offset                         0x16D04
#define RegTprocRegstprocep3event2_offset                         0x16D08
#define RegTprocRegstprocep3event3_offset                         0x16D0C
#define RegTprocRegstprocep3event4_offset                         0x16D10
#define RegTprocRegstprocep3event5_offset                         0x16D14
#define RegTprocRegstprocep3event6_offset                         0x16D18
#define RegTprocRegstprocep3event7_offset                         0x16D1C
#define RegTprocRegstprocep3event8_offset                         0x16D20
#define RegTprocRegstprocep3event9_offset                         0x16D24
#define RegTprocRegstprocep4hdrtrb0_offset                        0x16A00
#define RegTprocRegstprocep4hdrtrb1_offset                        0x16A04
#define RegTprocRegstprocep4hdrtrb2_offset                        0x16A08
#define RegTprocRegstprocep4hdrtrb3_offset                        0x16A0C
#define RegTprocRegstprocep4metatrb0_offset                       0x16A10
#define RegTprocRegstprocep4metatrb1_offset                       0x16A14
#define RegTprocRegstprocep4metatrb2_offset                       0x16A18
#define RegTprocRegstprocep4metatrb3_offset                       0x16A1C
#define RegTprocRegstprocep4nsetrb0_offset                        0x16A20
#define RegTprocRegstprocep4nsetrb1_offset                        0x16A24
#define RegTprocRegstprocep4nsetrb2_offset                        0x16A28
#define RegTprocRegstprocep4nsetrb3_offset                        0x16A2C
#define RegTprocRegstprocep4frmdattrb0_offset                     0x16A30
#define RegTprocRegstprocep4frmdattrb1_offset                     0x16A34
#define RegTprocRegstprocep4frmdattrb2_offset                     0x16A38
#define RegTprocRegstprocep4frmdattrb3_offset                     0x16A3C
#define RegTprocRegstprocep4dataltrb0_offset                      0x16A40
#define RegTprocRegstprocep4dataltrb1_offset                      0x16A44
#define RegTprocRegstprocep4dataltrb2_offset                      0x16A48
#define RegTprocRegstprocep4dataltrb3_offset                      0x16A4C
#define RegTprocRegstprocep4zlptrb0_offset                        0x16A50
#define RegTprocRegstprocep4zlptrb1_offset                        0x16A54
#define RegTprocRegstprocep4zlptrb2_offset                        0x16A58
#define RegTprocRegstprocep4zlptrb3_offset                        0x16A5C
#define RegTprocRegstprocep4event0_offset                         0x16E00
#define RegTprocRegstprocep4event1_offset                         0x16E04
#define RegTprocRegstprocep4event2_offset                         0x16E08
#define RegTprocRegstprocep4event3_offset                         0x16E0C
#define RegTprocRegstprocep4event4_offset                         0x16E10
#define RegTprocRegstprocep4event5_offset                         0x16E14
#define RegTprocRegstprocep4event6_offset                         0x16E18
#define RegTprocRegstprocep4event7_offset                         0x16E1C
#define RegTprocRegstprocep4event8_offset                         0x16E20
#define RegTprocRegstprocep4event9_offset                         0x16E24

//#######################################################################
//                      usb_registers area
//#######################################################################
#define RegUsbSquelchThresholdAdjustment_offset                   0x17000
#define RegUsbFsLsSourceImpedanceAdjustment_offset                0x17004
#define RegUsbTransmitterHighSpeedCrossoverAdjustment_offset      0x17008
#define RegUsbHsTransmitterPreemphasisCurrentControl_offset       0x1700C
#define RegUsbUsbSourceImpedanceAdjustment_offset                 0x17010
#define RegUsbHsTransmitterRiseAndFallAdjustment_offset           0x17014
#define RegUsbHsDcVoltageLevelAdjustment_offset                   0x17018
#define RegUsbPcsRxLossOfSignalMaskValue_offset                   0x1701C
#define RegUsbTxDeemphasisAt3P5Db_offset                          0x17020
#define RegUsbTxDeemphasisAt6Db_offset                            0x17024
#define RegUsbTxAmplitudeFullSwingMode_offset                     0x17028
#define RegUsbHsTransmitterPreemphasisDurationControl_offset      0x1703C
#define RegUsbSpreadSpectrumClockRange_offset                     0x17040
#define RegUsbLoopbackTestEnable_offset                           0x17044
#define RegUsbADeviceSessionValidIndicator_offset                 0x17048
#define RegUsbBDeviceSessionValidIndicator_offset                 0x1704C
#define RegUsbTxVoltageBoostLevel_offset                          0x17050
#define RegUsbLossOfSignalDetectorThresholdLevelControl_offset    0x17054
#define RegUsbDisconnectThresholdAdjustment_offset                0x17058
#define RegUsbVbusValidThresholdAdjustment_offset                 0x1705C
#define RegUsbUsb3PhyControlRegisterWriteData_offset              0x17060
#define RegUsbUsb3PhyControlRegisterReadData_offset               0x17084
#define RegUsbUsb3PhyControlRegisterAddress_offset                0x17064
#define RegUsbUsb3PhyControlRegisterWriteCommand_offset           0x17068
#define RegUsbUsb3PhyControlRegisterReadCommand_offset            0x1706C
#define RegUsbUsb3PhyControlRegisterResetCommand_offset           0x17070
#define RegUsbUsb3PhyControlRegisterBusy_offset                   0x17074
#define RegUsbBusFilterBypass_offset                              0x17078
#define RegUsbFrequencySelect_offset                              0x1707C
#define RegUsbFrameLengthAdjustment_offset                        0x17080
#define RegUsbLane0TxTermOffset_offset                            0x17088
#define RegUsbLosLevel_offset                                     0x1708C
#define RegUsbMpllRefsscClkEn_offset                              0x17090
#define RegUsbUsbRefclkSel_offset                                 0x17094

//#######################################################################
//                      vdf_registers area
//#######################################################################
#define RegVdfVideoEndpointDataEnable_offset                      0x16000
#define RegVdfTwelveBitMode_offset                                0x16004
#define RegVdfDepthDataPackingMode_offset                         0x16008
#define RegVdfLyryDataPackingMode_offset                          0x1600C
#define RegVdfDepthDataEndianSelect_offset                        0x16010
#define RegVdfLyryDataEndianSelect_offset                         0x16014
#define RegVdfDepthDataBufferWriteAddress_offset                  0x16018
#define RegVdfLyryDataBufferWriteAddress_offset                   0x1601C
#define RegVdfWebcamDataBufferWriteAddress_offset                 0x16020
#define RegVdfDepthFramePadLength_offset                          0x16024
#define RegVdfLyryFramePadLength_offset                           0x16028
#define RegVdfWebcamFramePadLength_offset                         0x1602C
#define RegVdfDepthEp2UvcHeaderBmheaderinfo_offset                0x16030
#define RegVdfLyryEp3UvcHeaderBmheaderinfo_offset                 0x16034
#define RegVdfWebcamEp4UvcHeaderBmheaderinfo_offset               0x16038
#define RegVdfDepthBufferInterruptThreshold_offset                0x1603C
#define RegVdfDepthBufferDmaPointer_offset                        0x16040
#define RegVdfLyryBufferInterruptThreshold_offset                 0x16044
#define RegVdfLyryBufferDmaPointer_offset                         0x16048
#define RegVdfWebcamBufferInterruptThreshold_offset               0x1604C
#define RegVdfWebcamBufferDmaPointer_offset                       0x16050
#define RegVdfWebcamDataMode_offset                               0x16054
#define RegVdfAxiApbSlaveErrorDisable_offset                      0x16058
#define RegVdfDepthBufferTrafficGeneratorEnable_offset            0x1605C
#define RegVdfDepthBufferTrafficGeneratorPatternSelect_offset     0x16060
#define RegVdfDepthBufferTrafficGeneratorUserWord_offset          0x16064
#define RegVdfDepthBufferTrafficGeneratorCounterReset_offset      0x16068
#define RegVdfLyryBufferTrafficGeneratorEnable_offset             0x1606C
#define RegVdfLyryBufferTrafficGeneratorPatternSelect_offset      0x16070
#define RegVdfLyryBufferTrafficGeneratorUserWord_offset           0x16074
#define RegVdfLyryBufferTrafficGeneratorCounterReset_offset       0x16078
#define RegVdfWebcamBufferTrafficGeneratorEnable_offset           0x1607C
#define RegVdfWebcamBufferTrafficGeneratorPatternSelect_offset    0x16080
#define RegVdfWebcamBufferTrafficGeneratorUserWord_offset         0x16084
#define RegVdfWebcamBufferTrafficGeneratorCounterReset_offset     0x16088
#define RegVdfUsb3ModeSelect_offset                               0x1608C
#define RegVdfDepthPixelMipiPacketType_offset                     0x16090
#define RegVdfLyryPixelMipiPacketType_offset                      0x16094
#define RegVdfWebcamPixelMipiPacketType_offset                    0x16098
#define RegVdfDepthVirtualChannel_offset                          0x1609C
#define RegVdfLyryVirtualChannel_offset                           0x160A0
#define RegVdfWebcamVirtualChannel_offset                         0x160A4
#define RegVdfDepthDinghyMipiPacketType_offset                    0x160A8
#define RegVdfLyryDinghyMipiPacketType_offset                     0x160AC
#define RegVdfWebcamDinghyMipiPacketType_offset                   0x160B0
#define RegVdfCompressedDepthDataLineLength_offset                0x160B4
#define RegVdfVdfGeneralStatus1_offset                            0x160B8
#define RegVdfVdfGeneralStatus2_offset                            0x160BC
#define RegVdfCamBufferMipiHalt_offset                            0x160C0
#define RegVdfRecBufferMipiHalt_offset                            0x160C4
#define RegVdfDepthBufferMipiHalt_offset                          0x160C8
#define RegVdfNseBufferMipiHalt_offset                            0x161E8
#define RegVdfMipiArbiterPriority_offset                          0x160CC
#define RegVdfCamBufferDataTypePassThroughEnable_offset           0x160D0
#define RegVdfRecBufferDataTypePassThroughEnable_offset           0x160D4
#define RegVdfDepthBufferEodAddr_offset                           0x160D8
#define RegVdfMipiLsLeEnable_offset                               0x160DC
#define RegVdfDepthBufferTestData_offset                          0x160E0
#define RegVdfDepthBufferTestFraming_offset                       0x160E4
#define RegVdfRecBufferTestData_offset                            0x160E8
#define RegVdfRecBufferTestFraming_offset                         0x160EC
#define RegVdfCamBufferTestData_offset                            0x160F0
#define RegVdfCamBufferTestFraming_offset                         0x160F4
#define RegVdfAxiBufferAddressMapMode_offset                      0x160F8
#define RegVdfVdfScratch0_offset                                  0x160FC
#define RegVdfVdfScratch1_offset                                  0x16100
#define RegVdfVdfScratch2_offset                                  0x16104
#define RegVdfVdfScratch3_offset                                  0x16108
#define RegVdfVdfScratch4_offset                                  0x1610C
#define RegVdfVdfScratch5_offset                                  0x16110
#define RegVdfVdfBufferMemorySdDisable_offset                     0x16114
#define RegVdfWebcamCsiASwap_offset                               0x16118
#define RegVdfWebcamCsiBSwap_offset                               0x1611C
#define RegVdfNseMipiDataPacketStartAddress_offset                0x16120
#define RegVdfNseMipiDataPacketSize_offset                        0x16124
#define RegVdfNseMipiPacketDt_offset                              0x16128
#define RegVdfNseMipiPacketVc_offset                              0x1612C
#define RegVdfNseMipiPacketStart_offset                           0x16130
#define RegVdfStcFrequencyCount_offset                            0x16134
#define RegVdfStcStartCount_offset                                0x16138
#define RegVdfStcCount_offset                                     0x1613C
#define RegVdfStcCorrectionCount_offset                           0x16140
#define RegVdfUsbCoreTrbWriteBack0_offset                         0x16144
#define RegVdfUsbCoreTrbWriteBack1_offset                         0x16148
#define RegVdfMipiCombinedDataMode_offset                         0x1614C
#define RegVdfDepthBufferMipiUvcSize_offset                       0x16150
#define RegVdfDepthBufferMipiUvcDt_offset                         0x16154
#define RegVdfDepthBufferMipiEmbeddedDataPacketEn_offset          0x16158
#define RegVdfRecBufferMipiUvcSize_offset                         0x1615C
#define RegVdfRecBufferMipiUvcDt_offset                           0x16160
#define RegVdfRecBufferMipiEmbeddedDataPacketEn_offset            0x16164
#define RegVdfCamBufferMipiUvcSize_offset                         0x16168
#define RegVdfCamBufferMipiUvcDt_offset                           0x1616C
#define RegVdfCamBufferMipiEmbeddedDataPacketEn_offset            0x16170
#define RegVdfUvcExtHdrZ04_offset                                 0x16174
#define RegVdfUvcExtHdrZ05_offset                                 0x16178
#define RegVdfUvcExtHdrZ06_offset                                 0x1617C
#define RegVdfUvcExtHdrZ07_offset                                 0x16180
#define RegVdfUvcExtHdrZ08_offset                                 0x16184
#define RegVdfUvcExtHdrZ09_offset                                 0x16188
#define RegVdfUvcExtHdrZ10_offset                                 0x1618C
#define RegVdfUvcExtHdrZ11_offset                                 0x16190
#define RegVdfUvcExtHdrZ12_offset                                 0x16194
#define RegVdfUvcExtHdrZ13_offset                                 0x16198
#define RegVdfUvcExtHdrZ14_offset                                 0x1619C
#define RegVdfUvcExtHdrZ15_offset                                 0x161A0
#define RegVdfUvcExtHdrZ16_offset                                 0x161A4
#define RegVdfUvcExtHdrC04_offset                                 0x161A8
#define RegVdfUvcExtHdrC05_offset                                 0x161AC
#define RegVdfUvcExtHdrC06_offset                                 0x161B0
#define RegVdfUvcExtHdrC07_offset                                 0x161B4
#define RegVdfUvcExtHdrC08_offset                                 0x161B8
#define RegVdfUvcExtHdrC09_offset                                 0x161BC
#define RegVdfUvcExtHdrC10_offset                                 0x161C0
#define RegVdfUvcExtHdrC11_offset                                 0x161C4
#define RegVdfUvcExtHdrC12_offset                                 0x161C8
#define RegVdfUvcExtHdrC13_offset                                 0x161CC
#define RegVdfUvcExtHdrC14_offset                                 0x161D0
#define RegVdfUvcExtHdrC15_offset                                 0x161D4
#define RegVdfUvcExtHdrC16_offset                                 0x161D8
#define RegVdfNseBufferMipiEn_offset                              0x161DC
#define RegVdfVdfRecScpHaltEn_offset                              0x161E0
#define RegVdfDepthDinghyEnable_offset                            0x161E4
#define RegVdfLyryDinghyEnable_offset                             0x161EC
#define RegVdfNseMemoryPwrControl_offset                          0x161F0
#define RegVdfCombModeFsFeControl_offset                          0x161F4
#define RegVdfVdfSpareRw1_offset                                  0x161F8
#define RegVdfVdfSpareRw2_offset                                  0x161FC
#define RegVdfUvcHdrShadowUpdate_offset                           0x16200

//##############################################################
//                      cam_registers area
//##############################################################
//Camera Control
//initial value: 0x0000000
typedef union __RegCamCameraControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfADataSelect                                    :3          ; //Bits :[0:2], initial value: 0x0. CSI to VDF A Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z
        uint32_t VdfBDataSelect                                    :3          ; //Bits :[3:5], initial value: 0x0. CSI to VDF B Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z
        uint32_t IspDataSelect                                     :3          ; //Bits :[6:8], initial value: 0x0. CSI to ISP Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y
        uint32_t Reserved1                                         :1          ; //Bits :[9:9], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t SelectImagerAI2c                                  :1          ; //Bits :[10:10], initial value: 0x0. Select Imager A I2C
        uint32_t SelectImagerBI2c                                  :1          ; //Bits :[11:11], initial value: 0x0. Select Imager B I2C
        uint32_t SelectImagerMI2c                                  :1          ; //Bits :[12:12], initial value: 0x0. Select Imager M I2C
        uint32_t SelectImagerYI2c                                  :1          ; //Bits :[13:13], initial value: 0x0. Select Imager Y I2C
        uint32_t SelectImagerZI2c                                  :1          ; //Bits :[14:14], initial value: 0x0. Select Imager Z I2C
        uint32_t Reserved2                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t Camera0LeftSelect                                 :2          ; //Bits :[16:17], initial value: 0x0. Camera 0 Left Select: 00--disabled; 01--A; 10--B; 11--M
        uint32_t Camera0RightSelect                                :2          ; //Bits :[18:19], initial value: 0x0. Camera 0 Right Select: 00--disabled; 01--A; 10--B; 11--M
        uint32_t Camera1LeftSelect                                 :2          ; //Bits :[20:21], initial value: 0x0. Camera 1 Left Select: 00--disabled; 01--Y; 10--Z; 11--M
        uint32_t Camera1RightSelect                                :2          ; //Bits :[22:23], initial value: 0x0. Camera 1 Right Select: 00--disabled; 01--Y; 10--Z; 11--M
        uint32_t CameraStaticSelect                                :1          ; //Bits :[24:24], initial value: 0x0. Camera Static Select: 0--Camera 0; 1--Camera 1;
        uint32_t DynamicCameraSelectMode                           :1          ; //Bits :[25:25], initial value: 0x0. Dynamic Camera Select Mode: 0--disabled; 1--enabled;
        uint32_t DynamicBaselineCamera0Enable                      :1          ; //Bits :[26:26], initial value: 0x0. Dynamic Baseline Camera 0: 0--disabled; 1--enabled;
        uint32_t DynamicBaselineCamera1Enable                      :1          ; //Bits :[27:27], initial value: 0x0. Dynamic Baseline Camera 1: 0--disabled; 1--enabled;
        uint32_t Camera0StaticBaseSelect                           :1          ; //Bits :[28:28], initial value: 0x0. Camera0 Static Base Select: 0--Base 0; 1--Base 1;
        uint32_t Camera1StaticBaseSelect                           :1          ; //Bits :[29:29], initial value: 0x0. Camera1 Static Base Select: 0--Base 0; 1--Base 1;
        uint32_t Reserved3                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t VdfADataSelect                                    :3          ; //Bits :[0:2], initial value: 0x0. CSI to VDF A Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z
        uint32_t VdfBDataSelect                                    :3          ; //Bits :[3:5], initial value: 0x0. CSI to VDF B Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z
        uint32_t IspDataSelect                                     :3          ; //Bits :[6:8], initial value: 0x0. CSI to ISP Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y
        uint32_t Reserved1                                         :1          ; //Bits :[9:9], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t SelectImagerAI2c                                  :1          ; //Bits :[10:10], initial value: 0x0. Select Imager A I2C
        uint32_t SelectImagerBI2c                                  :1          ; //Bits :[11:11], initial value: 0x0. Select Imager B I2C
        uint32_t SelectImagerMI2c                                  :1          ; //Bits :[12:12], initial value: 0x0. Select Imager M I2C
        uint32_t SelectImagerYI2c                                  :1          ; //Bits :[13:13], initial value: 0x0. Select Imager Y I2C
        uint32_t SelectImagerZI2c                                  :1          ; //Bits :[14:14], initial value: 0x0. Select Imager Z I2C
        uint32_t Reserved2                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t Camera0LeftSelect                                 :2          ; //Bits :[16:17], initial value: 0x0. Camera 0 Left Select: 00--disabled; 01--A; 10--B; 11--M
        uint32_t Camera0RightSelect                                :2          ; //Bits :[18:19], initial value: 0x0. Camera 0 Right Select: 00--disabled; 01--A; 10--B; 11--M
        uint32_t Camera1LeftSelect                                 :2          ; //Bits :[20:21], initial value: 0x0. Camera 1 Left Select: 00--disabled; 01--Y; 10--Z; 11--M
        uint32_t Camera1RightSelect                                :2          ; //Bits :[22:23], initial value: 0x0. Camera 1 Right Select: 00--disabled; 01--Y; 10--Z; 11--M
        uint32_t CameraStaticSelect                                :1          ; //Bits :[24:24], initial value: 0x0. Camera Static Select: 0--Camera 0; 1--Camera 1;
        uint32_t DynamicCameraSelectMode                           :1          ; //Bits :[25:25], initial value: 0x0. Dynamic Camera Select Mode: 0--disabled; 1--enabled;
        uint32_t DynamicBaselineCamera0Enable                      :1          ; //Bits :[26:26], initial value: 0x0. Dynamic Baseline Camera 0: 0--disabled; 1--enabled;
        uint32_t DynamicBaselineCamera1Enable                      :1          ; //Bits :[27:27], initial value: 0x0. Dynamic Baseline Camera 1: 0--disabled; 1--enabled;
        uint32_t Camera0StaticBaseSelect                           :1          ; //Bits :[28:28], initial value: 0x0. Camera0 Static Base Select: 0--Base 0; 1--Base 1;
        uint32_t Camera1StaticBaseSelect                           :1          ; //Bits :[29:29], initial value: 0x0. Camera1 Static Base Select: 0--Base 0; 1--Base 1;
        uint32_t Reserved3                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t VdfADataSelect                                    :3          ; //Bits :[0:2], initial value: 0x0. CSI to VDF A Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z
        uint32_t VdfBDataSelect                                    :3          ; //Bits :[3:5], initial value: 0x0. CSI to VDF B Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z
        uint32_t IspDataSelect                                     :3          ; //Bits :[6:8], initial value: 0x0. CSI to ISP Data Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y
        uint32_t Reserved1                                         :1          ; //Bits :[9:9], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t SelectImagerAI2c                                  :1          ; //Bits :[10:10], initial value: 0x0. Select Imager A I2C
        uint32_t SelectImagerBI2c                                  :1          ; //Bits :[11:11], initial value: 0x0. Select Imager B I2C
        uint32_t SelectImagerMI2c                                  :1          ; //Bits :[12:12], initial value: 0x0. Select Imager M I2C
        uint32_t SelectImagerYI2c                                  :1          ; //Bits :[13:13], initial value: 0x0. Select Imager Y I2C
        uint32_t SelectImagerZI2c                                  :1          ; //Bits :[14:14], initial value: 0x0. Select Imager Z I2C
        uint32_t Reserved2                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t Camera0LeftSelect                                 :2          ; //Bits :[16:17], initial value: 0x0. Camera 0 Left Select: 00--disabled; 01--A; 10--B; 11--M
        uint32_t Camera0RightSelect                                :2          ; //Bits :[18:19], initial value: 0x0. Camera 0 Right Select: 00--disabled; 01--A; 10--B; 11--M
        uint32_t Camera1LeftSelect                                 :2          ; //Bits :[20:21], initial value: 0x0. Camera 1 Left Select: 00--disabled; 01--Y; 10--Z; 11--M
        uint32_t Camera1RightSelect                                :2          ; //Bits :[22:23], initial value: 0x0. Camera 1 Right Select: 00--disabled; 01--Y; 10--Z; 11--M
        uint32_t CameraStaticSelect                                :1          ; //Bits :[24:24], initial value: 0x0. Camera Static Select: 0--Camera 0; 1--Camera 1;
        uint32_t DynamicCameraSelectMode                           :1          ; //Bits :[25:25], initial value: 0x0. Dynamic Camera Select Mode: 0--disabled; 1--enabled;
        uint32_t DynamicBaselineCamera0Enable                      :1          ; //Bits :[26:26], initial value: 0x0. Dynamic Baseline Camera 0: 0--disabled; 1--enabled;
        uint32_t DynamicBaselineCamera1Enable                      :1          ; //Bits :[27:27], initial value: 0x0. Dynamic Baseline Camera 1: 0--disabled; 1--enabled;
        uint32_t Camera0StaticBaseSelect                           :1          ; //Bits :[28:28], initial value: 0x0. Camera0 Static Base Select: 0--Base 0; 1--Base 1;
        uint32_t Camera1StaticBaseSelect                           :1          ; //Bits :[29:29], initial value: 0x0. Camera1 Static Base Select: 0--Base 0; 1--Base 1;
        uint32_t Reserved3                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamCameraControl, TRegCamCameraControl, *PTRegCamCameraControl;                                //0x18000

//Determine which imager is vsync master
//initial value: 0x0000
typedef union __RegCamImgVsyncMasterControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VsyncMasterSelect                                 :4          ; //Bits :[0:3], initial value: 0x0. Vsync Master Select: 0 = csi_A_vsync; 1 = csi_B_vsync; 2 = csi_M_vsync; 3 = csi_Y_vsync; 4 = csi_Z_vsync; 5 = csi_A_vvalid; 6 = csi_B_vvalid; 7 = csi_M_vvalid; 8 = csi_Y_vvalid; 9 = csi_Z_vvalid; 10 = lcp_vsync_pulse; 11 = host sync input
        uint32_t CsiAVsyncDrive                                    :1          ; //Bits :[4:4], initial value: 0x0. CSI A Vsync Drive: 1 = drive Vsync Master to imager A
        uint32_t CsiBVsyncDrive                                    :1          ; //Bits :[5:5], initial value: 0x0. CSI B Vsync Drive: 1 = drive Vsync Master to imager B
        uint32_t CsiMVsyncDrive                                    :1          ; //Bits :[6:6], initial value: 0x0. CSI M Vsync Drive: 1 = drive Vsync Master to imager M
        uint32_t CsiYVsyncDrive                                    :1          ; //Bits :[7:7], initial value: 0x0. CSI Y Vsync Drive: 1 = drive Vsync Master to imager Y
        uint32_t CsiZVsyncDrive                                    :1          ; //Bits :[8:8], initial value: 0x0. CSI Z Vsync Drive: 1 = drive Vsync Master to imager Z
        uint32_t VsyncInputEdge                                    :1          ; //Bits :[9:9], initial value: 0x0. Vsync Input Edge: 0 = respond to rising edge; 1 = respond to falling edge
        uint32_t InvertVsyncOutput                                 :1          ; //Bits :[10:10], initial value: 0x0. Invert Vsync Output: 0 = active high; 1 = active low
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t VsyncMasterSelect                                 :4          ; //Bits :[0:3], initial value: 0x0. Vsync Master Select: 0 = csi_A_vsync; 1 = csi_B_vsync; 2 = csi_M_vsync; 3 = csi_Y_vsync; 4 = csi_Z_vsync; 5 = csi_A_vvalid; 6 = csi_B_vvalid; 7 = csi_M_vvalid; 8 = csi_Y_vvalid; 9 = csi_Z_vvalid; 10 = lcp_vsync_pulse; 11 = host sync input
        uint32_t CsiAVsyncDrive                                    :1          ; //Bits :[4:4], initial value: 0x0. CSI A Vsync Drive: 1 = drive Vsync Master to imager A
        uint32_t CsiBVsyncDrive                                    :1          ; //Bits :[5:5], initial value: 0x0. CSI B Vsync Drive: 1 = drive Vsync Master to imager B
        uint32_t CsiMVsyncDrive                                    :1          ; //Bits :[6:6], initial value: 0x0. CSI M Vsync Drive: 1 = drive Vsync Master to imager M
        uint32_t CsiYVsyncDrive                                    :1          ; //Bits :[7:7], initial value: 0x0. CSI Y Vsync Drive: 1 = drive Vsync Master to imager Y
        uint32_t CsiZVsyncDrive                                    :1          ; //Bits :[8:8], initial value: 0x0. CSI Z Vsync Drive: 1 = drive Vsync Master to imager Z
        uint32_t VsyncInputEdge                                    :1          ; //Bits :[9:9], initial value: 0x0. Vsync Input Edge: 0 = respond to rising edge; 1 = respond to falling edge
        uint32_t InvertVsyncOutput                                 :1          ; //Bits :[10:10], initial value: 0x0. Invert Vsync Output: 0 = active high; 1 = active low
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t VsyncMasterSelect                                 :4          ; //Bits :[0:3], initial value: 0x0. Vsync Master Select: 0 = csi_A_vsync; 1 = csi_B_vsync; 2 = csi_M_vsync; 3 = csi_Y_vsync; 4 = csi_Z_vsync; 5 = csi_A_vvalid; 6 = csi_B_vvalid; 7 = csi_M_vvalid; 8 = csi_Y_vvalid; 9 = csi_Z_vvalid; 10 = lcp_vsync_pulse; 11 = host sync input
        uint32_t CsiAVsyncDrive                                    :1          ; //Bits :[4:4], initial value: 0x0. CSI A Vsync Drive: 1 = drive Vsync Master to imager A
        uint32_t CsiBVsyncDrive                                    :1          ; //Bits :[5:5], initial value: 0x0. CSI B Vsync Drive: 1 = drive Vsync Master to imager B
        uint32_t CsiMVsyncDrive                                    :1          ; //Bits :[6:6], initial value: 0x0. CSI M Vsync Drive: 1 = drive Vsync Master to imager M
        uint32_t CsiYVsyncDrive                                    :1          ; //Bits :[7:7], initial value: 0x0. CSI Y Vsync Drive: 1 = drive Vsync Master to imager Y
        uint32_t CsiZVsyncDrive                                    :1          ; //Bits :[8:8], initial value: 0x0. CSI Z Vsync Drive: 1 = drive Vsync Master to imager Z
        uint32_t VsyncInputEdge                                    :1          ; //Bits :[9:9], initial value: 0x0. Vsync Input Edge: 0 = respond to rising edge; 1 = respond to falling edge
        uint32_t InvertVsyncOutput                                 :1          ; //Bits :[10:10], initial value: 0x0. Invert Vsync Output: 0 = active high; 1 = active low
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamImgVsyncMasterControl, TRegCamImgVsyncMasterControl, *PTRegCamImgVsyncMasterControl;                                //0x18004

//Register bits directly control the imagers
//initial value: 0x000000
typedef union __RegCamImagerControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ImagerAReset                                      :1          ; //Bits :[0:0], initial value: 0x0. Imager A Reset: active low
        uint32_t ImagerBReset                                      :1          ; //Bits :[1:1], initial value: 0x0. Imager B Reset: active low
        uint32_t ImagerMReset                                      :1          ; //Bits :[2:2], initial value: 0x0. Imager M Reset: active low
        uint32_t ImagerYReset                                      :1          ; //Bits :[3:3], initial value: 0x0. Imager Y Reset: active low
        uint32_t ImagerZReset                                      :1          ; //Bits :[4:4], initial value: 0x0. Imager Z Reset: active low
        uint32_t Reserved1                                         :3          ; //Bits :[5:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAPowerdown                                  :1          ; //Bits :[8:8], initial value: 0x0. Imager A Powerdown: Controls the output state of the a_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_A_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerBPowerdown                                  :1          ; //Bits :[9:9], initial value: 0x0. Imager B Powerdown: Controls the output state of the b_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_B_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerMPowerdown                                  :1          ; //Bits :[10:10], initial value: 0x0. Imager M Powerdown: Controls the output state of the m_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_M_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerYPowerdown                                  :1          ; //Bits :[11:11], initial value: 0x0. Imager Y Powerdown: Controls the output state of the y_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_Y_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerZPowerdown                                  :1          ; //Bits :[12:12], initial value: 0x0. Imager Z Powerdown: Controls the output state of the z_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_Z_OUTPUT_ENABLE bit to a 0.
        uint32_t Reserved2                                         :3          ; //Bits :[13:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAOutputEnable                               :1          ; //Bits :[16:16], initial value: 0x0. Imager A Output Enable (active low): 0 = a_pdown pin is an output and the value of the IMAGER_A_POWERDOWN register bit is driven to that pin; 1 = a_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerBOutputEnable                               :1          ; //Bits :[17:17], initial value: 0x0. Imager B Output Enable (active low): 0 = b_pdown pin is an output and the value of the IMAGER_B_POWERDOWN register bit is driven to that pin; 1 = b_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerMOutputEnable                               :1          ; //Bits :[18:18], initial value: 0x0. Imager M Output Enable (active low): 0 = m_pdown pin is an output and the value of the IMAGER_M_POWERDOWN register bit is driven to that pin; 1 = m_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerYOutputEnable                               :1          ; //Bits :[19:19], initial value: 0x0. Imager Y Output Enable (active low): 0 = y_pdown pin is an output and the value of the IMAGER_Y_POWERDOWN register bit is driven to that pin; 1 = y_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerZOutputEnable                               :1          ; //Bits :[20:20], initial value: 0x0. Imager Z Output Enable (active low): 0 = z_pdown pin is an output and the value of the IMAGER_Z_POWERDOWN register bit is driven to that pin; 1 = z_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t Reserved3                                         :11         ; //Bits :[21:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t ImagerAReset                                      :1          ; //Bits :[0:0], initial value: 0x0. Imager A Reset: active low
        uint32_t ImagerBReset                                      :1          ; //Bits :[1:1], initial value: 0x0. Imager B Reset: active low
        uint32_t ImagerMReset                                      :1          ; //Bits :[2:2], initial value: 0x0. Imager M Reset: active low
        uint32_t ImagerYReset                                      :1          ; //Bits :[3:3], initial value: 0x0. Imager Y Reset: active low
        uint32_t ImagerZReset                                      :1          ; //Bits :[4:4], initial value: 0x0. Imager Z Reset: active low
        uint32_t Reserved1                                         :3          ; //Bits :[5:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAPowerdown                                  :1          ; //Bits :[8:8], initial value: 0x0. Imager A Powerdown: Controls the output state of the a_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_A_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerBPowerdown                                  :1          ; //Bits :[9:9], initial value: 0x0. Imager B Powerdown: Controls the output state of the b_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_B_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerMPowerdown                                  :1          ; //Bits :[10:10], initial value: 0x0. Imager M Powerdown: Controls the output state of the m_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_M_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerYPowerdown                                  :1          ; //Bits :[11:11], initial value: 0x0. Imager Y Powerdown: Controls the output state of the y_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_Y_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerZPowerdown                                  :1          ; //Bits :[12:12], initial value: 0x0. Imager Z Powerdown: Controls the output state of the z_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_Z_OUTPUT_ENABLE bit to a 0.
        uint32_t Reserved2                                         :3          ; //Bits :[13:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAOutputEnable                               :1          ; //Bits :[16:16], initial value: 0x0. Imager A Output Enable (active low): 0 = a_pdown pin is an output and the value of the IMAGER_A_POWERDOWN register bit is driven to that pin; 1 = a_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerBOutputEnable                               :1          ; //Bits :[17:17], initial value: 0x0. Imager B Output Enable (active low): 0 = b_pdown pin is an output and the value of the IMAGER_B_POWERDOWN register bit is driven to that pin; 1 = b_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerMOutputEnable                               :1          ; //Bits :[18:18], initial value: 0x0. Imager M Output Enable (active low): 0 = m_pdown pin is an output and the value of the IMAGER_M_POWERDOWN register bit is driven to that pin; 1 = m_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerYOutputEnable                               :1          ; //Bits :[19:19], initial value: 0x0. Imager Y Output Enable (active low): 0 = y_pdown pin is an output and the value of the IMAGER_Y_POWERDOWN register bit is driven to that pin; 1 = y_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerZOutputEnable                               :1          ; //Bits :[20:20], initial value: 0x0. Imager Z Output Enable (active low): 0 = z_pdown pin is an output and the value of the IMAGER_Z_POWERDOWN register bit is driven to that pin; 1 = z_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t Reserved3                                         :11         ; //Bits :[21:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t ImagerAReset                                      :1          ; //Bits :[0:0], initial value: 0x0. Imager A Reset: active low
        uint32_t ImagerBReset                                      :1          ; //Bits :[1:1], initial value: 0x0. Imager B Reset: active low
        uint32_t ImagerMReset                                      :1          ; //Bits :[2:2], initial value: 0x0. Imager M Reset: active low
        uint32_t ImagerYReset                                      :1          ; //Bits :[3:3], initial value: 0x0. Imager Y Reset: active low
        uint32_t ImagerZReset                                      :1          ; //Bits :[4:4], initial value: 0x0. Imager Z Reset: active low
        uint32_t Reserved1                                         :3          ; //Bits :[5:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAPowerdown                                  :1          ; //Bits :[8:8], initial value: 0x0. Imager A Powerdown: Controls the output state of the a_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_A_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerBPowerdown                                  :1          ; //Bits :[9:9], initial value: 0x0. Imager B Powerdown: Controls the output state of the b_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_B_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerMPowerdown                                  :1          ; //Bits :[10:10], initial value: 0x0. Imager M Powerdown: Controls the output state of the m_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_M_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerYPowerdown                                  :1          ; //Bits :[11:11], initial value: 0x0. Imager Y Powerdown: Controls the output state of the y_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_Y_OUTPUT_ENABLE bit to a 0.
        uint32_t ImagerZPowerdown                                  :1          ; //Bits :[12:12], initial value: 0x0. Imager Z Powerdown: Controls the output state of the z_pdown pad when the bidirectional pad is configured as an output. To drive the value of this register bit out to the pad, set the IMAGER_Z_OUTPUT_ENABLE bit to a 0.
        uint32_t Reserved2                                         :3          ; //Bits :[13:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAOutputEnable                               :1          ; //Bits :[16:16], initial value: 0x0. Imager A Output Enable (active low): 0 = a_pdown pin is an output and the value of the IMAGER_A_POWERDOWN register bit is driven to that pin; 1 = a_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerBOutputEnable                               :1          ; //Bits :[17:17], initial value: 0x0. Imager B Output Enable (active low): 0 = b_pdown pin is an output and the value of the IMAGER_B_POWERDOWN register bit is driven to that pin; 1 = b_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerMOutputEnable                               :1          ; //Bits :[18:18], initial value: 0x0. Imager M Output Enable (active low): 0 = m_pdown pin is an output and the value of the IMAGER_M_POWERDOWN register bit is driven to that pin; 1 = m_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerYOutputEnable                               :1          ; //Bits :[19:19], initial value: 0x0. Imager Y Output Enable (active low): 0 = y_pdown pin is an output and the value of the IMAGER_Y_POWERDOWN register bit is driven to that pin; 1 = y_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t ImagerZOutputEnable                               :1          ; //Bits :[20:20], initial value: 0x0. Imager Z Output Enable (active low): 0 = z_pdown pin is an output and the value of the IMAGER_Z_POWERDOWN register bit is driven to that pin; 1 = z_pdown pin is tri-stated, and the input value is treated as the strobe signal from the imager.
        uint32_t Reserved3                                         :11         ; //Bits :[21:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamImagerControl, TRegCamImagerControl, *PTRegCamImagerControl;                                //0x18008

//Virtual Channel Control
//initial value: 0x0000000
typedef union __RegCamVirtualChannelControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfAVirtualChannelSelect                          :2          ; //Bits :[0:1], initial value: 0x0. VDF A Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t VdfBVirtualChannelSelect                          :2          ; //Bits :[2:3], initial value: 0x0. VDF B Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t IspVirtualChannelSelect                           :2          ; //Bits :[4:5], initial value: 0x0. ISP Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved1                                         :2          ; //Bits :[6:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAVirtualChannelSelect                       :2          ; //Bits :[8:9], initial value: 0x0. Imager A Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved2                                         :2          ; //Bits :[10:11], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerBVirtualChannelSelect                       :2          ; //Bits :[12:13], initial value: 0x0. Imager B Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved3                                         :2          ; //Bits :[14:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerMVirtualChannelSelect                       :2          ; //Bits :[16:17], initial value: 0x0. Imager M Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved4                                         :2          ; //Bits :[18:19], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerYVirtualChannelSelect                       :2          ; //Bits :[20:21], initial value: 0x0. Imager Y Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved5                                         :2          ; //Bits :[22:23], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerZVirtualChannelSelect                       :2          ; //Bits :[24:25], initial value: 0x0. Imager Z Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved6                                         :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t VdfAVirtualChannelSelect                          :2          ; //Bits :[0:1], initial value: 0x0. VDF A Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t VdfBVirtualChannelSelect                          :2          ; //Bits :[2:3], initial value: 0x0. VDF B Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t IspVirtualChannelSelect                           :2          ; //Bits :[4:5], initial value: 0x0. ISP Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved1                                         :2          ; //Bits :[6:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAVirtualChannelSelect                       :2          ; //Bits :[8:9], initial value: 0x0. Imager A Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved2                                         :2          ; //Bits :[10:11], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerBVirtualChannelSelect                       :2          ; //Bits :[12:13], initial value: 0x0. Imager B Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved3                                         :2          ; //Bits :[14:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerMVirtualChannelSelect                       :2          ; //Bits :[16:17], initial value: 0x0. Imager M Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved4                                         :2          ; //Bits :[18:19], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerYVirtualChannelSelect                       :2          ; //Bits :[20:21], initial value: 0x0. Imager Y Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved5                                         :2          ; //Bits :[22:23], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerZVirtualChannelSelect                       :2          ; //Bits :[24:25], initial value: 0x0. Imager Z Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved6                                         :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t VdfAVirtualChannelSelect                          :2          ; //Bits :[0:1], initial value: 0x0. VDF A Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t VdfBVirtualChannelSelect                          :2          ; //Bits :[2:3], initial value: 0x0. VDF B Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t IspVirtualChannelSelect                           :2          ; //Bits :[4:5], initial value: 0x0. ISP Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved1                                         :2          ; //Bits :[6:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerAVirtualChannelSelect                       :2          ; //Bits :[8:9], initial value: 0x0. Imager A Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved2                                         :2          ; //Bits :[10:11], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerBVirtualChannelSelect                       :2          ; //Bits :[12:13], initial value: 0x0. Imager B Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved3                                         :2          ; //Bits :[14:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerMVirtualChannelSelect                       :2          ; //Bits :[16:17], initial value: 0x0. Imager M Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved4                                         :2          ; //Bits :[18:19], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerYVirtualChannelSelect                       :2          ; //Bits :[20:21], initial value: 0x0. Imager Y Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved5                                         :2          ; //Bits :[22:23], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t ImagerZVirtualChannelSelect                       :2          ; //Bits :[24:25], initial value: 0x0. Imager Z Virtual Channel Select: 00--vc0; 01--vc1; 10--vc2; 11--vc3
        uint32_t Reserved6                                         :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamVirtualChannelControl, TRegCamVirtualChannelControl, *PTRegCamVirtualChannelControl;                                //0x1800C

//Web Frame Length
//initial value: 0x000
typedef union __RegCamWebFrameLength{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfAFrameLength                                   :12         ; //Bits :[0:11], initial value: 0x0. Specifies the number of lines in a frame going to VDF A path.
        uint32_t Reserved1                                         :4          ; //Bits :[12:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t VdfBFrameLength                                   :12         ; //Bits :[16:27], initial value: 0x0. Specifies the number of lines in a frame going to VDF B path.
        uint32_t Reserved2                                         :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t VdfAFrameLength                                   :12         ; //Bits :[0:11], initial value: 0x0. Specifies the number of lines in a frame going to VDF A path.
        uint32_t Reserved1                                         :4          ; //Bits :[12:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t VdfBFrameLength                                   :12         ; //Bits :[16:27], initial value: 0x0. Specifies the number of lines in a frame going to VDF B path.
        uint32_t Reserved2                                         :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t VdfAFrameLength                                   :12         ; //Bits :[0:11], initial value: 0x0. Specifies the number of lines in a frame going to VDF A path.
        uint32_t Reserved1                                         :4          ; //Bits :[12:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t VdfBFrameLength                                   :12         ; //Bits :[16:27], initial value: 0x0. Specifies the number of lines in a frame going to VDF B path.
        uint32_t Reserved2                                         :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamWebFrameLength, TRegCamWebFrameLength, *PTRegCamWebFrameLength;                                //0x18010

//Sets the number of clocks between the vsync control input and output
//initial value: 0x00000003
typedef union __RegCamVsyncDelayCount{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VsyncDelayCount                                   :24         ; //Bits :[0:23], initial value: 0x3. Vsync Delay Count: must be set to a non-zero value.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t VsyncDelayCount                                   :24         ; //Bits :[0:23], initial value: 0x3. Vsync Delay Count: must be set to a non-zero value.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t VsyncDelayCount                                   :24         ; //Bits :[0:23], initial value: 0x3. Vsync Delay Count: must be set to a non-zero value.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamVsyncDelayCount, TRegCamVsyncDelayCount, *PTRegCamVsyncDelayCount;                                //0x18014

//Sets the number of clocks in the vsync output pulse
//initial value: 0x00000003
typedef union __RegCamVsyncWidthCount{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VsyncWidthCount                                   :16         ; //Bits :[0:15], initial value: 0x3. Vsync Width Count: must be set to a non-zero value.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t VsyncWidthCount                                   :16         ; //Bits :[0:15], initial value: 0x3. Vsync Width Count: must be set to a non-zero value.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t VsyncWidthCount                                   :16         ; //Bits :[0:15], initial value: 0x3. Vsync Width Count: must be set to a non-zero value.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamVsyncWidthCount, TRegCamVsyncWidthCount, *PTRegCamVsyncWidthCount;                                //0x18018

//The act of writing to this register generates a vsync pulse, the data is a don't care.
//initial value: 0x00000000
typedef union __RegCamLcpVsyncPulse{ //register type:WO shadowed:NO
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Reserved                                          :32         ; //Bits :[0:31], initial value: 0x0. Reserved.
     } fields_write;
    struct {
        uint32_t Reserved                                          :32         ; //Bits :[0:31], initial value: 0x0. Reserved.
     } fields_rmw; //for non-shadowed register
} RegCamLcpVsyncPulse, TRegCamLcpVsyncPulse, *PTRegCamLcpVsyncPulse;                                //0x1801C

//Determines the sync strobe rate if faster or slower than vsync_master
//initial value: 0x00000000
typedef union __RegCamVsyncMasterTiming{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SclkCount                                         :26         ; //Bits :[0:25], initial value: 0x0. number of sclk cycles between sync strobes when faster than vsync_master
        uint32_t VsyncCount                                        :6          ; //Bits :[26:31], initial value: 0x0. number of sync strobes between vsync_master when faster, number of vsync_master cycles when slower
     } fields_read;
    struct {
        uint32_t SclkCount                                         :26         ; //Bits :[0:25], initial value: 0x0. number of sclk cycles between sync strobes when faster than vsync_master
        uint32_t VsyncCount                                        :6          ; //Bits :[26:31], initial value: 0x0. number of sync strobes between vsync_master when faster, number of vsync_master cycles when slower
     } fields_write;
    struct {
        uint32_t SclkCount                                         :26         ; //Bits :[0:25], initial value: 0x0. number of sclk cycles between sync strobes when faster than vsync_master
        uint32_t VsyncCount                                        :6          ; //Bits :[26:31], initial value: 0x0. number of sync strobes between vsync_master when faster, number of vsync_master cycles when slower
     } fields_rmw; //for non-shadowed register
} RegCamVsyncMasterTiming, TRegCamVsyncMasterTiming, *PTRegCamVsyncMasterTiming;                                //0x18020

//ISP Frame Length
//initial value: 0x000
typedef union __RegCamIspFrameLength{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t IspFrameLength                                    :12         ; //Bits :[0:11], initial value: 0x0. Specifies the number of lines in a frame going to ISP.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t IspFrameLength                                    :12         ; //Bits :[0:11], initial value: 0x0. Specifies the number of lines in a frame going to ISP.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t IspFrameLength                                    :12         ; //Bits :[0:11], initial value: 0x0. Specifies the number of lines in a frame going to ISP.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamIspFrameLength, TRegCamIspFrameLength, *PTRegCamIspFrameLength;                                //0x18024

//Embedded Datatype
//initial value: 0x000
typedef union __RegCamEmbeddedDatatype{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfADatatype                                      :6          ; //Bits :[0:5], initial value: 0x0. Specifies the datatype used by the filter on the VDF A path.
        uint32_t Reserved1                                         :2          ; //Bits :[6:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t VdfBDatatype                                      :6          ; //Bits :[8:13], initial value: 0x0. Specifies the datatype used by the filter on the VDF B path.
        uint32_t Reserved2                                         :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t VdfADatatype                                      :6          ; //Bits :[0:5], initial value: 0x0. Specifies the datatype used by the filter on the VDF A path.
        uint32_t Reserved1                                         :2          ; //Bits :[6:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t VdfBDatatype                                      :6          ; //Bits :[8:13], initial value: 0x0. Specifies the datatype used by the filter on the VDF B path.
        uint32_t Reserved2                                         :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t VdfADatatype                                      :6          ; //Bits :[0:5], initial value: 0x0. Specifies the datatype used by the filter on the VDF A path.
        uint32_t Reserved1                                         :2          ; //Bits :[6:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t VdfBDatatype                                      :6          ; //Bits :[8:13], initial value: 0x0. Specifies the datatype used by the filter on the VDF B path.
        uint32_t Reserved2                                         :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamEmbeddedDatatype, TRegCamEmbeddedDatatype, *PTRegCamEmbeddedDatatype;                                //0x18028

//Select startpoint to store Embedded data
//initial value: 0x00000010
typedef union __RegCamEmbeddedSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PathSelect                                        :2          ; //Bits :[0:1], initial value: 0x0. Path select: 00--disabled; 01--Path A; 10--Path B;
        uint32_t Reserved                                          :2          ; //Bits :[2:3], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t LineSelect                                        :4          ; //Bits :[4:7], initial value: 0x1. Select which line to start storing Embedded data, default is 1.
        uint32_t DataLength                                        :8          ; //Bits :[8:15], initial value: 0x0. How many bytes to store: value of zero is 256 bytes.
        uint32_t ByteOffset                                        :16         ; //Bits :[16:31], initial value: 0x0. Select which byte of the selected line to be the startpoint.
     } fields_read;
    struct {
        uint32_t PathSelect                                        :2          ; //Bits :[0:1], initial value: 0x0. Path select: 00--disabled; 01--Path A; 10--Path B;
        uint32_t Reserved                                          :2          ; //Bits :[2:3], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t LineSelect                                        :4          ; //Bits :[4:7], initial value: 0x1. Select which line to start storing Embedded data, default is 1.
        uint32_t DataLength                                        :8          ; //Bits :[8:15], initial value: 0x0. How many bytes to store: value of zero is 256 bytes.
        uint32_t ByteOffset                                        :16         ; //Bits :[16:31], initial value: 0x0. Select which byte of the selected line to be the startpoint.
     } fields_write;
    struct {
        uint32_t PathSelect                                        :2          ; //Bits :[0:1], initial value: 0x0. Path select: 00--disabled; 01--Path A; 10--Path B;
        uint32_t Reserved                                          :2          ; //Bits :[2:3], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t LineSelect                                        :4          ; //Bits :[4:7], initial value: 0x1. Select which line to start storing Embedded data, default is 1.
        uint32_t DataLength                                        :8          ; //Bits :[8:15], initial value: 0x0. How many bytes to store: value of zero is 256 bytes.
        uint32_t ByteOffset                                        :16         ; //Bits :[16:31], initial value: 0x0. Select which byte of the selected line to be the startpoint.
     } fields_rmw; //for non-shadowed register
} RegCamEmbeddedSelect, TRegCamEmbeddedSelect, *PTRegCamEmbeddedSelect;                                //0x1802C

//Embedded read dword address.
//initial value: 0x000
typedef union __RegCamEmbeddedReadAddress{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DwordAddress                                      :6          ; //Bits :[0:5], initial value: 0x0. Specifies the dword address to read the Embedded data.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t DwordAddress                                      :6          ; //Bits :[0:5], initial value: 0x0. Specifies the dword address to read the Embedded data.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t DwordAddress                                      :6          ; //Bits :[0:5], initial value: 0x0. Specifies the dword address to read the Embedded data.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamEmbeddedReadAddress, TRegCamEmbeddedReadAddress, *PTRegCamEmbeddedReadAddress;                                //0x18030

//Embedded Data stored for Firmware.
//initial value: 0x000
typedef union __RegCamEmbeddedStoredData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EmbeddedData                                      :32         ; //Bits :[0:31], initial value: 0x0. Embedded Data for Firmware.
     } fields_read;
    struct {
        uint32_t EmbeddedData                                      :32         ; //Bits :[0:31], initial value: 0x0. Embedded Data for Firmware.
     } fields_rmw; //for non-shadowed register
} RegCamEmbeddedStoredData, TRegCamEmbeddedStoredData, *PTRegCamEmbeddedStoredData;                                //0x18034

//Bits to control start and stop transfering frames
//initial value: 0x007
typedef union __RegCamCamPathGoStop{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamVdfAGo                                         :1          ; //Bits :[0:0], initial value: 0x1. Bit to start and stop transferring frames on VDF_A path
        uint32_t CamVdfBGo                                         :1          ; //Bits :[1:1], initial value: 0x1. Bit to start and stop transferring frames on VDF_B path
        uint32_t CamIspGo                                          :1          ; //Bits :[2:2], initial value: 0x1. Bit to start and stop transferring frames on ISP path
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t CamVdfAGo                                         :1          ; //Bits :[0:0], initial value: 0x1. Bit to start and stop transferring frames on VDF_A path
        uint32_t CamVdfBGo                                         :1          ; //Bits :[1:1], initial value: 0x1. Bit to start and stop transferring frames on VDF_B path
        uint32_t CamIspGo                                          :1          ; //Bits :[2:2], initial value: 0x1. Bit to start and stop transferring frames on ISP path
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t CamVdfAGo                                         :1          ; //Bits :[0:0], initial value: 0x1. Bit to start and stop transferring frames on VDF_A path
        uint32_t CamVdfBGo                                         :1          ; //Bits :[1:1], initial value: 0x1. Bit to start and stop transferring frames on VDF_B path
        uint32_t CamIspGo                                          :1          ; //Bits :[2:2], initial value: 0x1. Bit to start and stop transferring frames on ISP path
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamCamPathGoStop, TRegCamCamPathGoStop, *PTRegCamCamPathGoStop;                                //0x18038

//Bits to enable new functionality
//initial value: 0x000
typedef union __RegCamCamChiknBits{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SyncOverflow                                      :1          ; //Bits :[0:0], initial value: 0x0. Bit to enable skipping frame if sync alignment overflow is detected at start of frame.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SyncOverflow                                      :1          ; //Bits :[0:0], initial value: 0x0. Bit to enable skipping frame if sync alignment overflow is detected at start of frame.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SyncOverflow                                      :1          ; //Bits :[0:0], initial value: 0x0. Bit to enable skipping frame if sync alignment overflow is detected at start of frame.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamCamChiknBits, TRegCamCamChiknBits, *PTRegCamCamChiknBits;                                //0x1803C

//Provides the bits for setup of the ISP to MTR (ITM) module
//initial value: 0x00000000
typedef union __RegCamItmControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WrEn                                              :1          ; //Bits :[0:0], initial value: 0x0. Software reset for the ITM module - active low.
        uint32_t MipiHalt                                          :1          ; //Bits :[1:1], initial value: 0x0. Disable reading the control fifo in buffer read logic.
        uint32_t VcPassthru                                        :2          ; //Bits :[2:3], initial value: 0x0. This is the virtual channel sent to the MTR - MIPI interface.
        uint32_t LsLeEn                                            :1          ; //Bits :[4:4], initial value: 0x0. Line Start and Line End short packet enable.
        uint32_t ByteSwapEn                                        :1          ; //Bits :[5:5], initial value: 0x0. Swaps the bytes of the image payload data.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t WrEn                                              :1          ; //Bits :[0:0], initial value: 0x0. Software reset for the ITM module - active low.
        uint32_t MipiHalt                                          :1          ; //Bits :[1:1], initial value: 0x0. Disable reading the control fifo in buffer read logic.
        uint32_t VcPassthru                                        :2          ; //Bits :[2:3], initial value: 0x0. This is the virtual channel sent to the MTR - MIPI interface.
        uint32_t LsLeEn                                            :1          ; //Bits :[4:4], initial value: 0x0. Line Start and Line End short packet enable.
        uint32_t ByteSwapEn                                        :1          ; //Bits :[5:5], initial value: 0x0. Swaps the bytes of the image payload data.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t WrEn                                              :1          ; //Bits :[0:0], initial value: 0x0. Software reset for the ITM module - active low.
        uint32_t MipiHalt                                          :1          ; //Bits :[1:1], initial value: 0x0. Disable reading the control fifo in buffer read logic.
        uint32_t VcPassthru                                        :2          ; //Bits :[2:3], initial value: 0x0. This is the virtual channel sent to the MTR - MIPI interface.
        uint32_t LsLeEn                                            :1          ; //Bits :[4:4], initial value: 0x0. Line Start and Line End short packet enable.
        uint32_t ByteSwapEn                                        :1          ; //Bits :[5:5], initial value: 0x0. Swaps the bytes of the image payload data.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamItmControl, TRegCamItmControl, *PTRegCamItmControl;                                //0x18040

//Provides the control to load the register shadow latch - On The Fly register update
//initial value: 0x00000000
typedef union __RegCamOtfControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamGroup                                          :4          ; //Bits :[0:3], initial value: 0x0. CAM group bits - each bit loads different group of latches
        uint32_t RecGroup                                          :8          ; //Bits :[4:11], initial value: 0x0. Rec group bits - each bit loads different group of latches
        uint32_t ScpGroup                                          :4          ; //Bits :[12:15], initial value: 0x0. SCP group bits - each bit loads different group of latches
        uint32_t UpdateNow                                         :1          ; //Bits :[16:16], initial value: 0x0. Force all groups with bits set to load immediately
        uint32_t Reserved                                          :14         ; //Bits :[17:30], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t Busy                                              :1          ; //Bits :[31:31], initial value: 0x0. The current update is in progress, do not write again till cleared
     } fields_read;
    struct {
        uint32_t CamGroup                                          :4          ; //Bits :[0:3], initial value: 0x0. CAM group bits - each bit loads different group of latches
        uint32_t RecGroup                                          :8          ; //Bits :[4:11], initial value: 0x0. Rec group bits - each bit loads different group of latches
        uint32_t ScpGroup                                          :4          ; //Bits :[12:15], initial value: 0x0. SCP group bits - each bit loads different group of latches
        uint32_t UpdateNow                                         :1          ; //Bits :[16:16], initial value: 0x0. Force all groups with bits set to load immediately
        uint32_t Reserved                                          :14         ; //Bits :[17:30], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t Busy                                              :1          ; //Bits :[31:31], initial value: 0x0. The current update is in progress, do not write again till cleared
     } fields_write;
    struct {
        uint32_t CamGroup                                          :4          ; //Bits :[0:3], initial value: 0x0. CAM group bits - each bit loads different group of latches
        uint32_t RecGroup                                          :8          ; //Bits :[4:11], initial value: 0x0. Rec group bits - each bit loads different group of latches
        uint32_t ScpGroup                                          :4          ; //Bits :[12:15], initial value: 0x0. SCP group bits - each bit loads different group of latches
        uint32_t UpdateNow                                         :1          ; //Bits :[16:16], initial value: 0x0. Force all groups with bits set to load immediately
        uint32_t Reserved                                          :14         ; //Bits :[17:30], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t Busy                                              :1          ; //Bits :[31:31], initial value: 0x0. The current update is in progress, do not write again till cleared
     } fields_rmw; //for non-shadowed register
} RegCamOtfControl, TRegCamOtfControl, *PTRegCamOtfControl;                                //0x18044

//Selects one of six vsync signals to become one of the IMU event inputs
//initial value: 0x00000000
typedef union __RegCamImuVsyncSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ImuVsyncSelect                                    :3          ; //Bits :[0:2], initial value: 0x0. IMU Vsync Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z; 110--Host
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t ImuVsyncSelect                                    :3          ; //Bits :[0:2], initial value: 0x0. IMU Vsync Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z; 110--Host
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t ImuVsyncSelect                                    :3          ; //Bits :[0:2], initial value: 0x0. IMU Vsync Select: 000--disabled; 001--A; 010--B; 011--M; 100--Y; 101--Z; 110--Host
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamImuVsyncSelect, TRegCamImuVsyncSelect, *PTRegCamImuVsyncSelect;                                //0x18048

//Frame Number
//initial value: 0x00000000
typedef union __RegCamFrameNumber{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FrameNumber                                       :32         ; //Bits :[0:31], initial value: 0x0. Frame Number
     } fields_read;
    struct {
        uint32_t FrameNumber                                       :32         ; //Bits :[0:31], initial value: 0x0. Frame Number
     } fields_rmw; //for non-shadowed register
} RegCamFrameNumber, TRegCamFrameNumber, *PTRegCamFrameNumber;                                //0x18080

//Cycle count between vsync_master and first data for frame from imager A
//initial value: 0x00000000
typedef union __RegCamAlignAImg{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AlignmentImagerACount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t AlignmentImagerACount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamAlignAImg, TRegCamAlignAImg, *PTRegCamAlignAImg;                                //0x18084

//Cycle count between vsync_master and first data for frame from imager B
//initial value: 0x00000000
typedef union __RegCamAlignBImg{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AlignmentImagerBCount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t AlignmentImagerBCount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamAlignBImg, TRegCamAlignBImg, *PTRegCamAlignBImg;                                //0x18088

//Cycle count between vsync_master and first data for frame from imager M
//initial value: 0x00000000
typedef union __RegCamAlignMImg{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AlignmentImagerMCount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t AlignmentImagerMCount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamAlignMImg, TRegCamAlignMImg, *PTRegCamAlignMImg;                                //0x1808C

//Cycle count between vsync_master and first data for frame from imager Y
//initial value: 0x00000000
typedef union __RegCamAlignYImg{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AlignmentImagerYCount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t AlignmentImagerYCount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamAlignYImg, TRegCamAlignYImg, *PTRegCamAlignYImg;                                //0x18090

//Cycle count between vsync_master and first data for frame from imager Z
//initial value: 0x00000000
typedef union __RegCamAlignZImg{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AlignmentImagerZCount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t AlignmentImagerZCount                             :24         ; //Bits :[0:23], initial value: 0x0. A value of all 1's indicates an overflow
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamAlignZImg, TRegCamAlignZImg, *PTRegCamAlignZImg;                                //0x18094

//Cam status register. This is a sticky register, cleared after read.
//initial value: 0x00000000
typedef union __RegCamCamStatusRegister{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamStatusReg                                      :32         ; //Bits :[0:31], initial value: 0x0. Stores values of the errors in sticky register, cleared after read.
     } fields_read;
    struct {
        uint32_t CamStatusReg                                      :32         ; //Bits :[0:31], initial value: 0x0. Stores values of the errors in sticky register, cleared after read.
     } fields_rmw; //for non-shadowed register
} RegCamCamStatusRegister, TRegCamCamStatusRegister, *PTRegCamCamStatusRegister;                                //0x18098

//ITM status register. This is a sticky register, cleared after read.
//initial value: 0x00000000
typedef union __RegCamItmStatusRegister{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ControlFifoUnderflow                              :1          ; //Bits :[0:0], initial value: 0x0. Stores value of the control fifo underflow error in sticky register, cleared after read.
        uint32_t ControlFifoOverflow                               :1          ; //Bits :[1:1], initial value: 0x0. Stores value of the control fifo overflow error in sticky register, cleared after read.
        uint32_t BufferFifoUnderflow                               :1          ; //Bits :[2:2], initial value: 0x0. Stores value of the data buffer fifo underflow error in sticky register, cleared after read.
        uint32_t BufferFifoOverflow                                :1          ; //Bits :[3:3], initial value: 0x0. Stores value of the data buffer fifo overflow error in sticky register, cleared after read.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t ControlFifoUnderflow                              :1          ; //Bits :[0:0], initial value: 0x0. Stores value of the control fifo underflow error in sticky register, cleared after read.
        uint32_t ControlFifoOverflow                               :1          ; //Bits :[1:1], initial value: 0x0. Stores value of the control fifo overflow error in sticky register, cleared after read.
        uint32_t BufferFifoUnderflow                               :1          ; //Bits :[2:2], initial value: 0x0. Stores value of the data buffer fifo underflow error in sticky register, cleared after read.
        uint32_t BufferFifoOverflow                                :1          ; //Bits :[3:3], initial value: 0x0. Stores value of the data buffer fifo overflow error in sticky register, cleared after read.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamItmStatusRegister, TRegCamItmStatusRegister, *PTRegCamItmStatusRegister;                                //0x1809C

//Camera Laser Control. Enable and disable the laser output. Select open-drain or open-source type drive on the pin,
//and select one of the 12 possible input sources to use to begin a frame cycle for modulating the laser output.
//initial value: 0x00
typedef union __RegCamCameraLaserControl{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t PwmEnable                                         :1          ; //Bits :[0:0], initial value: 0x0. Enable the PWM
        uint32_t PwmInvertOutput                                   :1          ; //Bits :[1:1], initial value: 0x0. 1 = Drive inversion of generated PWM. 0 = Drive generated PWM.
        uint32_t SelectTriggerSource                               :4          ; //Bits :[2:5], initial value: 0x0. PWM trigger source: 0 = a_vvalid; 1 = b_vvalid; 2 = m_vvalid; 3 = y_vvalid; 4 = z_vvalid; 5 = vsync_master_d; 6 = a_sync; 7 = b_sync; 8 = m_sync; 9 = y_sync; 10 = z_sync; 11 = vsync_source; 12-15 = no PWM trigger.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegCamCameraLaserControl, TRegCamCameraLaserControl, *PTRegCamCameraLaserControl;                                //0x18100

//Sets the number of clocks
//initial value: 0x00000000
typedef union __RegCamPwmWindowCount{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t PwmWindowCount                                    :32         ; //Bits :[0:31], initial value: 0x0. PWM Window Count
     } fields_read;
} RegCamPwmWindowCount, TRegCamPwmWindowCount, *PTRegCamPwmWindowCount;                                //0x18104

//Sets the number of clocks
//initial value: 0x00000000
typedef union __RegCamPwmDelayCount{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t PwmDelayCount                                     :32         ; //Bits :[0:31], initial value: 0x0. PWM Delay Count
     } fields_read;
} RegCamPwmDelayCount, TRegCamPwmDelayCount, *PTRegCamPwmDelayCount;                                //0x18108

//Sets the number of clocks during which the laser control signal will be enabled.
//initial value: 0x0000
typedef union __RegCamPwmEnableCount{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t PwmEnableCount                                    :16         ; //Bits :[0:15], initial value: 0x0. PWM Enable Count
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegCamPwmEnableCount, TRegCamPwmEnableCount, *PTRegCamPwmEnableCount;                                //0x1810C

//Sets the number of clocks during which the laser control signal will be disabled.
//initial value: 0x0000
typedef union __RegCamPwmDisableCount{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t PwmDisableCount                                   :16         ; //Bits :[0:15], initial value: 0x0. PWM Disable Count
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegCamPwmDisableCount, TRegCamPwmDisableCount, *PTRegCamPwmDisableCount;                                //0x18110

//Enables Light Sleep and sets the CAM-REC Prestart Delay.
//initial value: 0x0000
typedef union __RegCamCamPowerControl{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t EnableLightSleep                                  :1          ; //Bits :[0:0], initial value: 0x0. Enable CAM memory Light Sleep between video lines.
        uint32_t Reserved1                                         :7          ; //Bits :[1:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t PrestartDelay                                     :8          ; //Bits :[8:15], initial value: 0x0. Sets the number of clocks between cam_rec_prestart and output pixel data.
        uint32_t Reserved2                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegCamCamPowerControl, TRegCamCamPowerControl, *PTRegCamCamPowerControl;                                //0x18114

//Sets the maximum number of clocks during which the laser control signal will be enabled.
//initial value: 0xffff
typedef union __RegCamPwmEnableCountMax{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PwmEnableCountMax                                 :16         ; //Bits :[0:15], initial value: 0xFFFF. PWM Enable Count Max
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PwmEnableCountMax                                 :16         ; //Bits :[0:15], initial value: 0xFFFF. PWM Enable Count Max
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PwmEnableCountMax                                 :16         ; //Bits :[0:15], initial value: 0xFFFF. PWM Enable Count Max
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamPwmEnableCountMax, TRegCamPwmEnableCountMax, *PTRegCamPwmEnableCountMax;                                //0x18118

//Sets the maximum PWM modulation ratio
//initial value: 0x0080
typedef union __RegCamPwmMaxRatio{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PwmMaxRatio                                       :9          ; //Bits :[0:8], initial value: 0x80. PWM Max Ratio
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PwmMaxRatio                                       :9          ; //Bits :[0:8], initial value: 0x80. PWM Max Ratio
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PwmMaxRatio                                       :9          ; //Bits :[0:8], initial value: 0x80. PWM Max Ratio
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegCamPwmMaxRatio, TRegCamPwmMaxRatio, *PTRegCamPwmMaxRatio;                                //0x1811C

//##############################################################
//                      csr_registers area
//##############################################################
// Contains read-only version numbers for the chip
//initial value: 0x440003
typedef union __RegCsrVersionRegister{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ChipRevision                                      :32         ; //Bits :[0:31], initial value: 0x440003. Should be incremented for each revision
     } fields_read;
    struct {
        uint32_t ChipRevision                                      :32         ; //Bits :[0:31], initial value: 0x440003. Should be incremented for each revision
     } fields_rmw; //for non-shadowed register
} RegCsrVersionRegister, TRegCsrVersionRegister, *PTRegCsrVersionRegister;                                //0x12000

//Write 9 to this register to enable writing resets and pll registers
//initial value: 0x0
typedef union __RegCsrSwResetsLock{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Code                                              :4          ; //Bits :[0:3], initial value: 0x0. Set to zero when not writing resets or pll registers
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Code                                              :4          ; //Bits :[0:3], initial value: 0x0. Set to zero when not writing resets or pll registers
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Code                                              :4          ; //Bits :[0:3], initial value: 0x0. Set to zero when not writing resets or pll registers
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrSwResetsLock, TRegCsrSwResetsLock, *PTRegCsrSwResetsLock;                                //0x12004

//SW_PLL_Reset
//initial value: 0x0
typedef union __RegCsrSwPllReset{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Reset                                             :1          ; //Bits :[0:0], initial value: 0x0. Write 0 to this register to clear PLL Reset.  This needs to be done during chip initialization.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Reset                                             :1          ; //Bits :[0:0], initial value: 0x0. Write 0 to this register to clear PLL Reset.  This needs to be done during chip initialization.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Reset                                             :1          ; //Bits :[0:0], initial value: 0x0. Write 0 to this register to clear PLL Reset.  This needs to be done during chip initialization.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrSwPllReset, TRegCsrSwPllReset, *PTRegCsrSwPllReset;                                //0x12008

//Writing a 1 to each bit of this register will generate a one pclk cycle wide pulse to execute a combination of
// one or more of the following actions: 0) software reset, 1) software PLL reset, 2) PLL set-up parameter loading,
//3) load saved PLL set-up parameters, 4) mask power on reset when doing PLL software reset, and 5) core data path
//reset. These register bits are self-cleared. This register can only be written when PLL Reset is active and SW_Reset
//unlocked
//initial value: 0x0
typedef union __RegCsrSwClkrstCtl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SoftwareReset                                     :1          ; //Bits :[0:0], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for software reset. This will also trigger a global reset. This bit is self-cleared.
        uint32_t SoftwarePllReset                                  :1          ; //Bits :[1:1], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for software PLL reset. This enables the PLL to accept new set-up parameters. This bit is self-cleared.
        uint32_t PllSetupParameterLoading                          :1          ; //Bits :[2:2], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse to simultaneously load all setup parameters for PLL. This bit works in conjunction with bit 1 (software PLL reset) to enable the PLL to accept new set-up parameters. This bit is self-cleared.
        uint32_t PllSetupParameterSelectAtRestart                  :1          ; //Bits :[3:3], initial value: 0x0. Writing a 1 to this register bit will select setup parameters currently stored in PLL Setup Registers 0, 1, 2, 3. Default to default parameters at reset. This bit works in conjunction with bit 1 (software PLL reset) to select set-up parameters or default parameters. This bit is self-cleared
        uint32_t MaskPowerOnReset                                  :1          ; //Bits :[4:4], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse to mask power on reset when a PLL software reset is executed. This bit is used with bit 1 (PLL software reset). This bit is self-cleared.
        uint32_t DataPathReset                                     :1          ; //Bits :[5:5], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for core data path reset. This bit is self-cleared.
        uint32_t UsbReset                                          :1          ; //Bits :[6:6], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for USB path reset. This bit is self-cleared.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t SoftwareReset                                     :1          ; //Bits :[0:0], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for software reset. This will also trigger a global reset. This bit is self-cleared.
        uint32_t SoftwarePllReset                                  :1          ; //Bits :[1:1], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for software PLL reset. This enables the PLL to accept new set-up parameters. This bit is self-cleared.
        uint32_t PllSetupParameterLoading                          :1          ; //Bits :[2:2], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse to simultaneously load all setup parameters for PLL. This bit works in conjunction with bit 1 (software PLL reset) to enable the PLL to accept new set-up parameters. This bit is self-cleared.
        uint32_t PllSetupParameterSelectAtRestart                  :1          ; //Bits :[3:3], initial value: 0x0. Writing a 1 to this register bit will select setup parameters currently stored in PLL Setup Registers 0, 1, 2, 3. Default to default parameters at reset. This bit works in conjunction with bit 1 (software PLL reset) to select set-up parameters or default parameters. This bit is self-cleared
        uint32_t MaskPowerOnReset                                  :1          ; //Bits :[4:4], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse to mask power on reset when a PLL software reset is executed. This bit is used with bit 1 (PLL software reset). This bit is self-cleared.
        uint32_t DataPathReset                                     :1          ; //Bits :[5:5], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for core data path reset. This bit is self-cleared.
        uint32_t UsbReset                                          :1          ; //Bits :[6:6], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for USB path reset. This bit is self-cleared.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t SoftwareReset                                     :1          ; //Bits :[0:0], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for software reset. This will also trigger a global reset. This bit is self-cleared.
        uint32_t SoftwarePllReset                                  :1          ; //Bits :[1:1], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for software PLL reset. This enables the PLL to accept new set-up parameters. This bit is self-cleared.
        uint32_t PllSetupParameterLoading                          :1          ; //Bits :[2:2], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse to simultaneously load all setup parameters for PLL. This bit works in conjunction with bit 1 (software PLL reset) to enable the PLL to accept new set-up parameters. This bit is self-cleared.
        uint32_t PllSetupParameterSelectAtRestart                  :1          ; //Bits :[3:3], initial value: 0x0. Writing a 1 to this register bit will select setup parameters currently stored in PLL Setup Registers 0, 1, 2, 3. Default to default parameters at reset. This bit works in conjunction with bit 1 (software PLL reset) to select set-up parameters or default parameters. This bit is self-cleared
        uint32_t MaskPowerOnReset                                  :1          ; //Bits :[4:4], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse to mask power on reset when a PLL software reset is executed. This bit is used with bit 1 (PLL software reset). This bit is self-cleared.
        uint32_t DataPathReset                                     :1          ; //Bits :[5:5], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for core data path reset. This bit is self-cleared.
        uint32_t UsbReset                                          :1          ; //Bits :[6:6], initial value: 0x0. Writing a 1 to this register bit will trigger a one pclk cycle wide pulse for USB path reset. This bit is self-cleared.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrSwClkrstCtl, TRegCsrSwClkrstCtl, *PTRegCsrSwClkrstCtl;                                //0x1200C

//PLL Setup Paramaters for Control, NR, and OD. Can only be written when PLL Reset is active and SW_Reset unlocked
//initial value: 0x40040
typedef union __RegCsrPllSetupReg0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PllControl                                        :7          ; //Bits :[0:6], initial value: 0x40. 0: SSEN; 1: DITHEN; 2: PWRDN; 3: BYPASS; 4: TEST; 5: FASTEN; 6: ENSAT;
        uint32_t Reserved7                                         :1          ; //Bits :[7:7], initial value: 0x0 Reserved.
        uint32_t Nr                                                :6          ; //Bits :[8:13], initial value: 0x0. PLL Reference Divider
        uint32_t Reserved14                                        :2          ; //Bits :[14:15], initial value: 0x0 Reserved.
        uint32_t Od                                                :3          ; //Bits :[16:18], initial value: 0x4. PLL VCO Divider
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PllControl                                        :7          ; //Bits :[0:6], initial value: 0x40. 0: SSEN; 1: DITHEN; 2: PWRDN; 3: BYPASS; 4: TEST; 5: FASTEN; 6: ENSAT;
        uint32_t Reserved7                                         :1          ; //Bits :[7:7], initial value: 0x0 Reserved.
        uint32_t Nr                                                :6          ; //Bits :[8:13], initial value: 0x0. PLL Reference Divider
        uint32_t Reserved14                                        :2          ; //Bits :[14:15], initial value: 0x0 Reserved.
        uint32_t Od                                                :3          ; //Bits :[16:18], initial value: 0x4. PLL VCO Divider
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t PllControl                                        :7          ; //Bits :[0:6], initial value: 0x40. 0: SSEN; 1: DITHEN; 2: PWRDN; 3: BYPASS; 4: TEST; 5: FASTEN; 6: ENSAT;
        uint32_t Reserved7                                         :1          ; //Bits :[7:7], initial value: 0x0 Reserved.
        uint32_t Nr                                                :6          ; //Bits :[8:13], initial value: 0x0. PLL Reference Divider
        uint32_t Reserved14                                        :2          ; //Bits :[14:15], initial value: 0x0 Reserved.
        uint32_t Od                                                :3          ; //Bits :[16:18], initial value: 0x4. PLL VCO Divider
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllSetupReg0, TRegCsrPllSetupReg0, *PTRegCsrPllSetupReg0;                                //0x12010

//PLL Setup Paramaters for NB and NS. Can only be written when PLL Reset is active and SW_Reset unlocked
//initial value: 0x01900037
typedef union __RegCsrPllSetupReg1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Nb                                                :12         ; //Bits :[0:11], initial value: 0x37. PLL Bandwidth Divider
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t Ns                                                :12         ; //Bits :[16:27], initial value: 0x190. PLL Spreading Rate Divider
        uint32_t Reserved                                          :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Nb                                                :12         ; //Bits :[0:11], initial value: 0x37. PLL Bandwidth Divider
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t Ns                                                :12         ; //Bits :[16:27], initial value: 0x190. PLL Spreading Rate Divider
        uint32_t Reserved                                          :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Nb                                                :12         ; //Bits :[0:11], initial value: 0x37. PLL Bandwidth Divider
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t Ns                                                :12         ; //Bits :[16:27], initial value: 0x190. PLL Spreading Rate Divider
        uint32_t Reserved                                          :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllSetupReg1, TRegCsrPllSetupReg1, *PTRegCsrPllSetupReg1;                                //0x12014

//PLL Setup Paramaters for NF. Can only be written when PLL Reset is active and SW_Reset unlocked
//initial value: 0x1C2002
typedef union __RegCsrPllSetupReg2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Nf                                                :26         ; //Bits :[0:25], initial value: 0x1C2002. PLL Multiplication Factor
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Nf                                                :26         ; //Bits :[0:25], initial value: 0x1C2002. PLL Multiplication Factor
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Nf                                                :26         ; //Bits :[0:25], initial value: 0x1C2002. PLL Multiplication Factor
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllSetupReg2, TRegCsrPllSetupReg2, *PTRegCsrPllSetupReg2;                                //0x12018

//PLL Setup Paramaters for NV. Can only be written when PLL Reset is active and SW_Reset unlocked
//initial value: 0x0B8
typedef union __RegCsrPllSetupReg3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Nv                                                :26         ; //Bits :[0:25], initial value: 0xB8. PLL Spreading Amount
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Nv                                                :26         ; //Bits :[0:25], initial value: 0xB8. PLL Spreading Amount
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Nv                                                :26         ; //Bits :[0:25], initial value: 0xB8. PLL Spreading Amount
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllSetupReg3, TRegCsrPllSetupReg3, *PTRegCsrPllSetupReg3;                                //0x1201C

//Read Only, presents status of PLL. Initial Value = X (Don't Care);
//initial value: 0x0
typedef union __RegCsrPllStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PllStatus                                         :7          ; //Bits :[0:6], initial value: 0x0. 0: LOCK; 1: SSSYNC; 2: FBEN; 3: RFEN; 4: FBSLIP; 5: RFSLIP; 6: fsm_pll_stable
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PllStatus                                         :7          ; //Bits :[0:6], initial value: 0x0. 0: LOCK; 1: SSSYNC; 2: FBEN; 3: RFEN; 4: FBSLIP; 5: RFSLIP; 6: fsm_pll_stable
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllStatus, TRegCsrPllStatus, *PTRegCsrPllStatus;                                //0x12020

//Read Only, presents status of sclk. Initial Value = 0 ;
//initial value: 0x0
typedef union __RegCsrSclkStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SclkStatus                                        :2          ; //Bits :[0:1], initial value: 0x0. 0: 24 MHz refclk; 1: PLL sclk; 2: 1 MHz oscclk;
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t SclkStatus                                        :2          ; //Bits :[0:1], initial value: 0x0. 0: 24 MHz refclk; 1: PLL sclk; 2: 1 MHz oscclk;
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrSclkStatus, TRegCsrSclkStatus, *PTRegCsrSclkStatus;                                //0x1202C

//PLL Selected Setup Paramaters for Control, NR, and OD. This register is read-only and shows the values being submitted
//to the PLL.
//initial value: 0x40040
typedef union __RegCsrPllSelectedSetupReg0{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PllControl                                        :7          ; //Bits :[0:6], initial value: 0x40. 0: SSEN; 1: DITHEN; 2: PWRDN; 3: BYPASS; 4: TEST; 5: FASTEN; 6: ENSAT;
        uint32_t Reserved                                          :1          ; //Bits :[7:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Nr                                                :6          ; //Bits :[8:13], initial value: 0x0. PLL Reference Divider
        uint32_t Reserved1                                         :2          ; //Bits :[14:15], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Od                                                :3          ; //Bits :[16:18], initial value: 0x4. PLL VCO Divider
        uint32_t Reserved2                                         :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PllControl                                        :7          ; //Bits :[0:6], initial value: 0x40. 0: SSEN; 1: DITHEN; 2: PWRDN; 3: BYPASS; 4: TEST; 5: FASTEN; 6: ENSAT;
        uint32_t Reserved                                          :1          ; //Bits :[7:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Nr                                                :6          ; //Bits :[8:13], initial value: 0x0. PLL Reference Divider
        uint32_t Reserved1                                         :2          ; //Bits :[14:15], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Od                                                :3          ; //Bits :[16:18], initial value: 0x4. PLL VCO Divider
        uint32_t Reserved2                                         :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllSelectedSetupReg0, TRegCsrPllSelectedSetupReg0, *PTRegCsrPllSelectedSetupReg0;                                //0x12410

//PLL Selected Setup Paramaters for NB and NS. This register is read-only and shows the values being submitted to
//the PLL.
//initial value: 0x01900037
typedef union __RegCsrPllSelectedSetupReg1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Nb                                                :12         ; //Bits :[0:11], initial value: 0x37. PLL Bandwidth Divider
        uint32_t Reserved                                          :4          ; //Bits :[12:15], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Ns                                                :12         ; //Bits :[16:27], initial value: 0x190. PLL Spreading Rate Divider
        uint32_t Reserved1                                         :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Nb                                                :12         ; //Bits :[0:11], initial value: 0x37. PLL Bandwidth Divider
        uint32_t Reserved                                          :4          ; //Bits :[12:15], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Ns                                                :12         ; //Bits :[16:27], initial value: 0x190. PLL Spreading Rate Divider
        uint32_t Reserved1                                         :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllSelectedSetupReg1, TRegCsrPllSelectedSetupReg1, *PTRegCsrPllSelectedSetupReg1;                                //0x12414

//PLL Selected Setup Paramaters for NF. This register is read-only and shows the value being submitted to the PLL.
//initial value: 0x001C2002
typedef union __RegCsrPllSelectedSetupReg2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Nf                                                :26         ; //Bits :[0:25], initial value: 0x1C2002. PLL Multiplication Factor
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Nf                                                :26         ; //Bits :[0:25], initial value: 0x1C2002. PLL Multiplication Factor
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllSelectedSetupReg2, TRegCsrPllSelectedSetupReg2, *PTRegCsrPllSelectedSetupReg2;                                //0x12418

//PLL Selected Setup Paramaters for NV. This register is read-only and shows the value being submitted to the PLL.
//initial value: 0x0B8
typedef union __RegCsrPllSelectedSetupReg3{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Nv                                                :26         ; //Bits :[0:25], initial value: 0xB8. PLL Spreading Amount
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Nv                                                :26         ; //Bits :[0:25], initial value: 0xB8. PLL Spreading Amount
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPllSelectedSetupReg3, TRegCsrPllSelectedSetupReg3, *PTRegCsrPllSelectedSetupReg3;                                //0x1241C

//Set clock modes to operate the chip.
//initial value: 0x18
typedef union __RegCsrCsrClkMode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MainClkmuxSelect                                  :1          ; //Bits :[0:0], initial value: 0x0. 0: multiplexed refclk or pmu_oscclk; 1: multiplexed refclk or pll_sclk
        uint32_t PllEnable                                         :1          ; //Bits :[1:1], initial value: 0x0. 0: PLL is disabled; 1: PLL is enabled.
        uint32_t PllSclkSwitchEnable                               :1          ; //Bits :[2:2], initial value: 0x0. 0: using refclk even if PLL is enabled; 1: enable HW to switch from refclk to PLL sclk only when PLL is enabled and stable.
        uint32_t SclkClockGate                                     :1          ; //Bits :[3:3], initial value: 0x1. 0: disable sclk to 0; 1: enable sclk to run.
        uint32_t PllMask                                           :1          ; //Bits :[4:4], initial value: 0x1. 0: use PLL stability as qualifier condition; 1: mask PLL stability condition.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t MainClkmuxSelect                                  :1          ; //Bits :[0:0], initial value: 0x0. 0: multiplexed refclk or pmu_oscclk; 1: multiplexed refclk or pll_sclk
        uint32_t PllEnable                                         :1          ; //Bits :[1:1], initial value: 0x0. 0: PLL is disabled; 1: PLL is enabled.
        uint32_t PllSclkSwitchEnable                               :1          ; //Bits :[2:2], initial value: 0x0. 0: using refclk even if PLL is enabled; 1: enable HW to switch from refclk to PLL sclk only when PLL is enabled and stable.
        uint32_t SclkClockGate                                     :1          ; //Bits :[3:3], initial value: 0x1. 0: disable sclk to 0; 1: enable sclk to run.
        uint32_t PllMask                                           :1          ; //Bits :[4:4], initial value: 0x1. 0: use PLL stability as qualifier condition; 1: mask PLL stability condition.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t MainClkmuxSelect                                  :1          ; //Bits :[0:0], initial value: 0x0. 0: multiplexed refclk or pmu_oscclk; 1: multiplexed refclk or pll_sclk
        uint32_t PllEnable                                         :1          ; //Bits :[1:1], initial value: 0x0. 0: PLL is disabled; 1: PLL is enabled.
        uint32_t PllSclkSwitchEnable                               :1          ; //Bits :[2:2], initial value: 0x0. 0: using refclk even if PLL is enabled; 1: enable HW to switch from refclk to PLL sclk only when PLL is enabled and stable.
        uint32_t SclkClockGate                                     :1          ; //Bits :[3:3], initial value: 0x1. 0: disable sclk to 0; 1: enable sclk to run.
        uint32_t PllMask                                           :1          ; //Bits :[4:4], initial value: 0x1. 0: use PLL stability as qualifier condition; 1: mask PLL stability condition.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCsrClkMode, TRegCsrCsrClkMode, *PTRegCsrCsrClkMode;                                //0x12024

//Selecting clock ranges for SCLK, LCPCLK, and PCLK. Can only be written when PLL Reset is active and SW_Reset unlocked.
//initial value: 0x0
typedef union __RegCsrCsrClkSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SclkSelect                                        :2          ; //Bits :[0:1], initial value: 0x0. SCLK select; [00]: 333 MHz; [01]: 166.5 MHz; [10]: 83.25 MHz; [11]: Reserved;
        uint32_t LcpclkSelect                                      :2          ; //Bits :[2:3], initial value: 0x0. LCPCLK select; [00]: 333 MHz; [01]: 166.5 MHz; [10]: 83.25 MHz; [11]: Reserved;
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t SclkSelect                                        :2          ; //Bits :[0:1], initial value: 0x0. SCLK select; [00]: 333 MHz; [01]: 166.5 MHz; [10]: 83.25 MHz; [11]: Reserved;
        uint32_t LcpclkSelect                                      :2          ; //Bits :[2:3], initial value: 0x0. LCPCLK select; [00]: 333 MHz; [01]: 166.5 MHz; [10]: 83.25 MHz; [11]: Reserved;
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t SclkSelect                                        :2          ; //Bits :[0:1], initial value: 0x0. SCLK select; [00]: 333 MHz; [01]: 166.5 MHz; [10]: 83.25 MHz; [11]: Reserved;
        uint32_t LcpclkSelect                                      :2          ; //Bits :[2:3], initial value: 0x0. LCPCLK select; [00]: 333 MHz; [01]: 166.5 MHz; [10]: 83.25 MHz; [11]: Reserved;
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCsrClkSelect, TRegCsrCsrClkSelect, *PTRegCsrCsrClkSelect;                                //0x12028

//Controls the GPIO and Expanded GPIO direction
//initial value: 0x0
typedef union __RegCsrGpioControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t GpioDir10                                         :2          ; //Bits :[0:1], initial value: 0x0. Direction of each bit of GPIO[1:0] pin: 0: input; 1 = output
        uint32_t GpioDir2                                          :1          ; //Bits :[2:2], initial value: 0x0. If bit [2] of GPIO_Mux (Select PWM Output) is 0: Direction of GPIO[2] pin: 0: input; 1 = output. If bit [2] of GPIO_Mux is 1: Direction of GPIO[2] is the polarity of Laser PWM Drive generated by Camera Laser Control.
        uint32_t GpioDir63                                         :4          ; //Bits :[3:6], initial value: 0x0. Direction of each bit of GPIO[6:3] pin: 0: input; 1 = output
        uint32_t GpioDir7                                          :1          ; //Bits :[7:7], initial value: 0x0. If video is active, GPIO[7] is used as an output. If video is not active, GPIO[7] direction is: 0 = input; 1 = output.
        uint32_t ExpandedGpioDir130                                :14         ; //Bits :[8:21], initial value: 0x0. Direction of each bit of Expanded GPIO[13:0] pin: 0: input; 1 = output.                     Expanded GPIO[5:0] are TP [5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t GpioDir10                                         :2          ; //Bits :[0:1], initial value: 0x0. Direction of each bit of GPIO[1:0] pin: 0: input; 1 = output
        uint32_t GpioDir2                                          :1          ; //Bits :[2:2], initial value: 0x0. If bit [2] of GPIO_Mux (Select PWM Output) is 0: Direction of GPIO[2] pin: 0: input; 1 = output. If bit [2] of GPIO_Mux is 1: Direction of GPIO[2] is the polarity of Laser PWM Drive generated by Camera Laser Control.
        uint32_t GpioDir63                                         :4          ; //Bits :[3:6], initial value: 0x0. Direction of each bit of GPIO[6:3] pin: 0: input; 1 = output
        uint32_t GpioDir7                                          :1          ; //Bits :[7:7], initial value: 0x0. If video is active, GPIO[7] is used as an output. If video is not active, GPIO[7] direction is: 0 = input; 1 = output.
        uint32_t ExpandedGpioDir130                                :14         ; //Bits :[8:21], initial value: 0x0. Direction of each bit of Expanded GPIO[13:0] pin: 0: input; 1 = output.                     Expanded GPIO[5:0] are TP [5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t GpioDir10                                         :2          ; //Bits :[0:1], initial value: 0x0. Direction of each bit of GPIO[1:0] pin: 0: input; 1 = output
        uint32_t GpioDir2                                          :1          ; //Bits :[2:2], initial value: 0x0. If bit [2] of GPIO_Mux (Select PWM Output) is 0: Direction of GPIO[2] pin: 0: input; 1 = output. If bit [2] of GPIO_Mux is 1: Direction of GPIO[2] is the polarity of Laser PWM Drive generated by Camera Laser Control.
        uint32_t GpioDir63                                         :4          ; //Bits :[3:6], initial value: 0x0. Direction of each bit of GPIO[6:3] pin: 0: input; 1 = output
        uint32_t GpioDir7                                          :1          ; //Bits :[7:7], initial value: 0x0. If video is active, GPIO[7] is used as an output. If video is not active, GPIO[7] direction is: 0 = input; 1 = output.
        uint32_t ExpandedGpioDir130                                :14         ; //Bits :[8:21], initial value: 0x0. Direction of each bit of Expanded GPIO[13:0] pin: 0: input; 1 = output.                     Expanded GPIO[5:0] are TP [5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrGpioControl, TRegCsrGpioControl, *PTRegCsrGpioControl;                                //0x12030

//The GPIO and Expanded GPIO data value
//initial value: 0x0
typedef union __RegCsrGpioData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t GpioData                                          :8          ; //Bits :[0:7], initial value: 0x0. For each pin when direction = Out, this register sets the pin value according to corresponding GPIO data value, which might be multiplexed between the value written by LCP and other peripherals. Reading this register returns the value of GPIO data being programmed by LCP and sent out to GPIO output
        uint32_t ExpandedGpioData130                               :14         ; //Bits :[8:21], initial value: 0x0. For each pin when direction = Out, this register sets the pin value according to corresponding Expanded GPIO data value.                    Expanded GPIO[5:0] are TP [5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t GpioData                                          :8          ; //Bits :[0:7], initial value: 0x0. For each pin when direction = Out, this register sets the pin value according to corresponding GPIO data value, which might be multiplexed between the value written by LCP and other peripherals. Reading this register returns the value of GPIO data being programmed by LCP and sent out to GPIO output
        uint32_t ExpandedGpioData130                               :14         ; //Bits :[8:21], initial value: 0x0. For each pin when direction = Out, this register sets the pin value according to corresponding Expanded GPIO data value.                    Expanded GPIO[5:0] are TP [5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t GpioData                                          :8          ; //Bits :[0:7], initial value: 0x0. For each pin when direction = Out, this register sets the pin value according to corresponding GPIO data value, which might be multiplexed between the value written by LCP and other peripherals. Reading this register returns the value of GPIO data being programmed by LCP and sent out to GPIO output
        uint32_t ExpandedGpioData130                               :14         ; //Bits :[8:21], initial value: 0x0. For each pin when direction = Out, this register sets the pin value according to corresponding Expanded GPIO data value.                    Expanded GPIO[5:0] are TP [5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrGpioData, TRegCsrGpioData, *PTRegCsrGpioData;                                //0x12034

//Multiplexing the GPIO data value
//initial value: 0x0
typedef union __RegCsrGpioMux{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t GpioDataBit0OrUartTxSelector                      :1          ; //Bits :[0:0], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [0]: 0, GPIO Data[0];  1, UART Tx.
        uint32_t GpioDataBit1OrUartRxSelector                      :1          ; //Bits :[1:1], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [1]: 0, GPIO Data[1];  1, UART Rx.
        uint32_t GpioDataBit2OrPwmOutSelector                      :1          ; //Bits :[2:2], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [2]: 0, GPIO Data[2];  1, PWM Out.
        uint32_t Reserved1                                         :4          ; //Bits :[3:6], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t GpioDataBit7OrLedOn                               :1          ; //Bits :[7:7], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [7]: 0, GPIO Data[7];  1, LED_OUTPUT
        uint32_t EgpioDataBit0OrImuInterruptOutSelector            :1          ; //Bits :[8:8], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at EGPIO Port [0]: 0, EGPIO Data[0];  1, IMU Interrupt Out.
        uint32_t EgpioDataBit1OrHostVsyncOutSelector               :1          ; //Bits :[9:9], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at EGPIO Port [1]: 0, EGPIO Data[1];  1, Host Vsync Out.
        uint32_t Reserved2                                         :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t GpioDataBit0OrUartTxSelector                      :1          ; //Bits :[0:0], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [0]: 0, GPIO Data[0];  1, UART Tx.
        uint32_t GpioDataBit1OrUartRxSelector                      :1          ; //Bits :[1:1], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [1]: 0, GPIO Data[1];  1, UART Rx.
        uint32_t GpioDataBit2OrPwmOutSelector                      :1          ; //Bits :[2:2], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [2]: 0, GPIO Data[2];  1, PWM Out.
        uint32_t Reserved1                                         :4          ; //Bits :[3:6], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t GpioDataBit7OrLedOn                               :1          ; //Bits :[7:7], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [7]: 0, GPIO Data[7];  1, LED_OUTPUT
        uint32_t EgpioDataBit0OrImuInterruptOutSelector            :1          ; //Bits :[8:8], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at EGPIO Port [0]: 0, EGPIO Data[0];  1, IMU Interrupt Out.
        uint32_t EgpioDataBit1OrHostVsyncOutSelector               :1          ; //Bits :[9:9], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at EGPIO Port [1]: 0, EGPIO Data[1];  1, Host Vsync Out.
        uint32_t Reserved2                                         :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t GpioDataBit0OrUartTxSelector                      :1          ; //Bits :[0:0], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [0]: 0, GPIO Data[0];  1, UART Tx.
        uint32_t GpioDataBit1OrUartRxSelector                      :1          ; //Bits :[1:1], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [1]: 0, GPIO Data[1];  1, UART Rx.
        uint32_t GpioDataBit2OrPwmOutSelector                      :1          ; //Bits :[2:2], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [2]: 0, GPIO Data[2];  1, PWM Out.
        uint32_t Reserved1                                         :4          ; //Bits :[3:6], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t GpioDataBit7OrLedOn                               :1          ; //Bits :[7:7], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at GPIO Port [7]: 0, GPIO Data[7];  1, LED_OUTPUT
        uint32_t EgpioDataBit0OrImuInterruptOutSelector            :1          ; //Bits :[8:8], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at EGPIO Port [0]: 0, EGPIO Data[0];  1, IMU Interrupt Out.
        uint32_t EgpioDataBit1OrHostVsyncOutSelector               :1          ; //Bits :[9:9], initial value: 0x0. The polarity of this bit selects which of the following two data bits is output at EGPIO Port [1]: 0, EGPIO Data[1];  1, Host Vsync Out.
        uint32_t Reserved2                                         :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrGpioMux, TRegCsrGpioMux, *PTRegCsrGpioMux;                                //0x12038

//The captured GPIO and Expanded GPIO data input value
//initial value: 0x0
typedef union __RegCsrGpioDataInput{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DataInput                                         :8          ; //Bits :[0:7], initial value: 0x0. Reading this register yields the captured value of the input of the GPIO port. To capture GPIO DI, set GPIO Control register to input direction, write to GPIO Data register (with any value), then read GPIO DI register (this register). Every write to GPIO Data register captures a GPIO DI value at that time. Initial value = 0x0.
        uint32_t ExpandedGpioDataInput130                          :14         ; //Bits :[8:21], initial value: 0x0. Similarly to GPIO operation as described above; when Expanded GPIO is enabled;                     Expanded GPIO[5:0]  are TP[5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t DataInput                                         :8          ; //Bits :[0:7], initial value: 0x0. Reading this register yields the captured value of the input of the GPIO port. To capture GPIO DI, set GPIO Control register to input direction, write to GPIO Data register (with any value), then read GPIO DI register (this register). Every write to GPIO Data register captures a GPIO DI value at that time. Initial value = 0x0.
        uint32_t ExpandedGpioDataInput130                          :14         ; //Bits :[8:21], initial value: 0x0. Similarly to GPIO operation as described above; when Expanded GPIO is enabled;                     Expanded GPIO[5:0]  are TP[5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrGpioDataInput, TRegCsrGpioDataInput, *PTRegCsrGpioDataInput;                                //0x1203C

//The free-running GPIO and Expanded GPIO data input value
//initial value: 0x0
typedef union __RegCsrGpioDataInput2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DataInput2                                        :8          ; //Bits :[0:7], initial value: 0x0. Reading this register yields the free-running value being input at the GPIO port. Initial Value = X; it depends on the current drivers of GPIO at power on reset;
        uint32_t ExpandedGpioDataInput2170                         :14         ; //Bits :[8:21], initial value: 0x0. Similarly to GPIO operation as described above; when Expanded GPIO is enabled;                     Expanded GPIO[5:0]  are TP[5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t DataInput2                                        :8          ; //Bits :[0:7], initial value: 0x0. Reading this register yields the free-running value being input at the GPIO port. Initial Value = X; it depends on the current drivers of GPIO at power on reset;
        uint32_t ExpandedGpioDataInput2170                         :14         ; //Bits :[8:21], initial value: 0x0. Similarly to GPIO operation as described above; when Expanded GPIO is enabled;                     Expanded GPIO[5:0]  are TP[5:0] respectively;                     Expanded GPIO[13:6] are CW[7:0] respectively
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrGpioDataInput2, TRegCsrGpioDataInput2, *PTRegCsrGpioDataInput2;                                //0x1204C

//Each bit in this register when set enables a pin as an expanded GPIO; when cleared the pin still retains its primary
//default function.
//initial value: 0x0
typedef union __RegCsrEgpioEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EgpioEnable07                                     :8          ; //Bits :[0:7], initial value: 0x0. Each bit of this range [0:7] individually and respectively enables a pin in Chip Watch bus [0:7] as Expanded_GPIO[0:7] when set (1); when cleared (0) each Chip Watch pin retains its primary default function.
        uint32_t EgpioEnable813                                    :6          ; //Bits :[8:13], initial value: 0x0. Each bit of this range [8:13] individually and respectively enables a pin in Test Pin bus [0:5] as Expanded_GPIO[8:13] when set (1); when cleared (0) each Test Pin retains its primary default function.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t EgpioEnable07                                     :8          ; //Bits :[0:7], initial value: 0x0. Each bit of this range [0:7] individually and respectively enables a pin in Chip Watch bus [0:7] as Expanded_GPIO[0:7] when set (1); when cleared (0) each Chip Watch pin retains its primary default function.
        uint32_t EgpioEnable813                                    :6          ; //Bits :[8:13], initial value: 0x0. Each bit of this range [8:13] individually and respectively enables a pin in Test Pin bus [0:5] as Expanded_GPIO[8:13] when set (1); when cleared (0) each Test Pin retains its primary default function.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t EgpioEnable07                                     :8          ; //Bits :[0:7], initial value: 0x0. Each bit of this range [0:7] individually and respectively enables a pin in Chip Watch bus [0:7] as Expanded_GPIO[0:7] when set (1); when cleared (0) each Chip Watch pin retains its primary default function.
        uint32_t EgpioEnable813                                    :6          ; //Bits :[8:13], initial value: 0x0. Each bit of this range [8:13] individually and respectively enables a pin in Test Pin bus [0:5] as Expanded_GPIO[8:13] when set (1); when cleared (0) each Test Pin retains its primary default function.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrEgpioEnable, TRegCsrEgpioEnable, *PTRegCsrEgpioEnable;                                //0x12060

//Temperature Sensor PVT ENA register.
//initial value: 0x0
typedef union __RegCsrTsPvtEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PvtEna                                            :1          ; //Bits :[0:0], initial value: 0x0. Writing 0 resets temperature sensor. FW writes zero first and then re-writes 1 to deassert. This bit controls ENA pin of IP
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PvtEna                                            :1          ; //Bits :[0:0], initial value: 0x0. Writing 0 resets temperature sensor. FW writes zero first and then re-writes 1 to deassert. This bit controls ENA pin of IP
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t PvtEna                                            :1          ; //Bits :[0:0], initial value: 0x0. Writing 0 resets temperature sensor. FW writes zero first and then re-writes 1 to deassert. This bit controls ENA pin of IP
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrTsPvtEnable, TRegCsrTsPvtEnable, *PTRegCsrTsPvtEnable;                                //0x12070

//Temperature Sensor PVT SAMPLE register.
//initial value: 0x0
typedef union __RegCsrTsPvtSample{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PvtSample                                         :3          ; //Bits :[0:2], initial value: 0x0. These 3 bits [2:0] respectively control VSAMPLE, PSAMPLE[1:0] of the Temperature Sensor IP
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PvtSample                                         :3          ; //Bits :[0:2], initial value: 0x0. These 3 bits [2:0] respectively control VSAMPLE, PSAMPLE[1:0] of the Temperature Sensor IP
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t PvtSample                                         :3          ; //Bits :[0:2], initial value: 0x0. These 3 bits [2:0] respectively control VSAMPLE, PSAMPLE[1:0] of the Temperature Sensor IP
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrTsPvtSample, TRegCsrTsPvtSample, *PTRegCsrTsPvtSample;                                //0x12074

//Temperature Sensor PVT TRIM register.
//initial value: 0x0
typedef union __RegCsrTsPvtTrim{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PvtTrim                                           :5          ; //Bits :[0:4], initial value: 0x0. These 5 bits [4:0] control PVT_TRIM[4:0] pins of the Temperature Sensor IP
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PvtTrim                                           :5          ; //Bits :[0:4], initial value: 0x0. These 5 bits [4:0] control PVT_TRIM[4:0] pins of the Temperature Sensor IP
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t PvtTrim                                           :5          ; //Bits :[0:4], initial value: 0x0. These 5 bits [4:0] control PVT_TRIM[4:0] pins of the Temperature Sensor IP
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrTsPvtTrim, TRegCsrTsPvtTrim, *PTRegCsrTsPvtTrim;                                //0x12078

//Temperature Sensor PVT DATA OUT register.
//initial value: 0x0
typedef union __RegCsrTsPvtDataOut{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PvtDataOut                                        :10         ; //Bits :[0:9], initial value: 0x0. These 10 bits [9:0] are the output of PVT_DATA_OUT[9:0] register of the Temperature Sensor IP
        uint32_t PvtDataValid                                      :1          ; //Bits :[10:10], initial value: 0x0. Asserted when there is a data valid output in Temperature Sensor IP
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PvtDataOut                                        :10         ; //Bits :[0:9], initial value: 0x0. These 10 bits [9:0] are the output of PVT_DATA_OUT[9:0] register of the Temperature Sensor IP
        uint32_t PvtDataValid                                      :1          ; //Bits :[10:10], initial value: 0x0. Asserted when there is a data valid output in Temperature Sensor IP
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrTsPvtDataOut, TRegCsrTsPvtDataOut, *PTRegCsrTsPvtDataOut;                                //0x1207C

//Selecting PVT trimming mode.
//initial value: 0x0
typedef union __RegCsrTsModeSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PvtTrimModeSelect                                 :1          ; //Bits :[0:0], initial value: 0x0. Selecting PVT trimming mode. 0: JTAG; 1: HW
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PvtTrimModeSelect                                 :1          ; //Bits :[0:0], initial value: 0x0. Selecting PVT trimming mode. 0: JTAG; 1: HW
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t PvtTrimModeSelect                                 :1          ; //Bits :[0:0], initial value: 0x0. Selecting PVT trimming mode. 0: JTAG; 1: HW
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrTsModeSelect, TRegCsrTsModeSelect, *PTRegCsrTsModeSelect;                                //0x120E0

//This register contains command for HW Trim FSM.
//initial value: 0x0
typedef union __RegCsrTsTrimCmd{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ExpDataOutHw                                      :10         ; //Bits :[0:9], initial value: 0x0. Expected Data Out for HW Trim FSM
        uint32_t EnTrimCmd                                         :1          ; //Bits :[10:10], initial value: 0x0. Enable trim command when set to 1.
        uint32_t HwTrimValue                                       :5          ; //Bits :[11:15], initial value: 0x0. This is the Trim value for the temperature evaluation FSM
        uint32_t ExpDataOutThresholdHw                             :10         ; //Bits :[16:25], initial value: 0x0. Expected Data Out Threshold above which TSM will generate an interrupt
        uint32_t CalibrationEnable                                 :1          ; //Bits :[26:26], initial value: 0x0. Calibration enable when set to 1. When 0 the FSM will do temperature evaluation.
        uint32_t Reserved                                          :5          ; //Bits :[27:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t ExpDataOutHw                                      :10         ; //Bits :[0:9], initial value: 0x0. Expected Data Out for HW Trim FSM
        uint32_t EnTrimCmd                                         :1          ; //Bits :[10:10], initial value: 0x0. Enable trim command when set to 1.
        uint32_t HwTrimValue                                       :5          ; //Bits :[11:15], initial value: 0x0. This is the Trim value for the temperature evaluation FSM
        uint32_t ExpDataOutThresholdHw                             :10         ; //Bits :[16:25], initial value: 0x0. Expected Data Out Threshold above which TSM will generate an interrupt
        uint32_t CalibrationEnable                                 :1          ; //Bits :[26:26], initial value: 0x0. Calibration enable when set to 1. When 0 the FSM will do temperature evaluation.
        uint32_t Reserved                                          :5          ; //Bits :[27:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t ExpDataOutHw                                      :10         ; //Bits :[0:9], initial value: 0x0. Expected Data Out for HW Trim FSM
        uint32_t EnTrimCmd                                         :1          ; //Bits :[10:10], initial value: 0x0. Enable trim command when set to 1.
        uint32_t HwTrimValue                                       :5          ; //Bits :[11:15], initial value: 0x0. This is the Trim value for the temperature evaluation FSM
        uint32_t ExpDataOutThresholdHw                             :10         ; //Bits :[16:25], initial value: 0x0. Expected Data Out Threshold above which TSM will generate an interrupt
        uint32_t CalibrationEnable                                 :1          ; //Bits :[26:26], initial value: 0x0. Calibration enable when set to 1. When 0 the FSM will do temperature evaluation.
        uint32_t Reserved                                          :5          ; //Bits :[27:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrTsTrimCmd, TRegCsrTsTrimCmd, *PTRegCsrTsTrimCmd;                                //0x120E4

//This register contains results of HW Trim operation.
//initial value: 0x0
typedef union __RegCsrTsTrimResult{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DataOutHw                                         :10         ; //Bits :[0:9], initial value: 0x0. Resultant Data Out for HW Trim FSM
        uint32_t TrimResultHw                                      :5          ; //Bits :[10:14], initial value: 0x0. Trim result retrieved by HW Trim FSM
        uint32_t DataValidHw                                       :1          ; //Bits :[15:15], initial value: 0x0. When set this bit indictates the validity of data_out. FW writes 1 to clear the valid status to wait for the next valid status.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t DataOutHw                                         :10         ; //Bits :[0:9], initial value: 0x0. Resultant Data Out for HW Trim FSM
        uint32_t TrimResultHw                                      :5          ; //Bits :[10:14], initial value: 0x0. Trim result retrieved by HW Trim FSM
        uint32_t DataValidHw                                       :1          ; //Bits :[15:15], initial value: 0x0. When set this bit indictates the validity of data_out. FW writes 1 to clear the valid status to wait for the next valid status.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t DataOutHw                                         :10         ; //Bits :[0:9], initial value: 0x0. Resultant Data Out for HW Trim FSM
        uint32_t TrimResultHw                                      :5          ; //Bits :[10:14], initial value: 0x0. Trim result retrieved by HW Trim FSM
        uint32_t DataValidHw                                       :1          ; //Bits :[15:15], initial value: 0x0. When set this bit indictates the validity of data_out. FW writes 1 to clear the valid status to wait for the next valid status.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrTsTrimResult, TRegCsrTsTrimResult, *PTRegCsrTsTrimResult;                                //0x120E8

//This register contains the number of tsclk cycles used in temperature evaluation FSM.
//initial value: 0x0
typedef union __RegCsrTsRdPeriod{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsRdPeriod                                        :32         ; //Bits :[0:31], initial value: 0x0. This register contains the number of tsclk cycles used in temperature evaluation FSM
     } fields_read;
    struct {
        uint32_t TsRdPeriod                                        :32         ; //Bits :[0:31], initial value: 0x0. This register contains the number of tsclk cycles used in temperature evaluation FSM
     } fields_write;
    struct {
        uint32_t TsRdPeriod                                        :32         ; //Bits :[0:31], initial value: 0x0. This register contains the number of tsclk cycles used in temperature evaluation FSM
     } fields_rmw; //for non-shadowed register
} RegCsrTsRdPeriod, TRegCsrTsRdPeriod, *PTRegCsrTsRdPeriod;                                //0x120EC

//This register shows the value of efuses [31:0]
//initial value: 0x0
typedef union __RegCsrTsEfuseRdata0{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsEf0                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [31:0]
     } fields_read;
    struct {
        uint32_t TsEf0                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [31:0]
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRdata0, TRegCsrTsEfuseRdata0, *PTRegCsrTsEfuseRdata0;                                //0x120B0

//This register shows the value of efuses [63:32]
//initial value: 0x0
typedef union __RegCsrTsEfuseRdata1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsEf1                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [63:32]
     } fields_read;
    struct {
        uint32_t TsEf1                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [63:32]
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRdata1, TRegCsrTsEfuseRdata1, *PTRegCsrTsEfuseRdata1;                                //0x120B4

//This register shows the value of efuses [95:64]
//initial value: 0x0
typedef union __RegCsrTsEfuseRdata2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsEf2                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [95:64]
     } fields_read;
    struct {
        uint32_t TsEf2                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [95:64]
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRdata2, TRegCsrTsEfuseRdata2, *PTRegCsrTsEfuseRdata2;                                //0x120B8

//This register shows the value of efuses [127:96]
//initial value: 0x0
typedef union __RegCsrTsEfuseRdata3{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsEf3                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [127:96]
     } fields_read;
    struct {
        uint32_t TsEf3                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [127:96]
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRdata3, TRegCsrTsEfuseRdata3, *PTRegCsrTsEfuseRdata3;                                //0x120BC

//This register shows the value of efuses [159:128]
//initial value: 0x0
typedef union __RegCsrTsEfuseRdata4{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsEf4                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [159:128]
     } fields_read;
    struct {
        uint32_t TsEf4                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [159:128]
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRdata4, TRegCsrTsEfuseRdata4, *PTRegCsrTsEfuseRdata4;                                //0x120C0

//This register shows the value of efuses [191:160]
//initial value: 0x0
typedef union __RegCsrTsEfuseRdata5{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsEf5                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [191:160]
     } fields_read;
    struct {
        uint32_t TsEf5                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [191:160]
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRdata5, TRegCsrTsEfuseRdata5, *PTRegCsrTsEfuseRdata5;                                //0x120C4

//This register shows the value of efuses [223:192]
//initial value: 0x0
typedef union __RegCsrTsEfuseRdata6{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsEf6                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [223:192]
     } fields_read;
    struct {
        uint32_t TsEf6                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [223:192]
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRdata6, TRegCsrTsEfuseRdata6, *PTRegCsrTsEfuseRdata6;                                //0x120C8

//This register shows the value of efuses [255:224]
//initial value: 0x0
typedef union __RegCsrTsEfuseRdata7{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TsEf7                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [255:224]
     } fields_read;
    struct {
        uint32_t TsEf7                                             :32         ; //Bits :[0:31], initial value: 0x0. Efuse read data [255:224]
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRdata7, TRegCsrTsEfuseRdata7, *PTRegCsrTsEfuseRdata7;                                //0x120CC

//This register indicates the validity status of efuse read data.
//initial value: 0x0
typedef union __RegCsrTsEfuseRvalid{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EfuseRdataValid                                   :1          ; //Bits :[0:0], initial value: 0x0. When set to 1 this bit indicates the validity of efuse read data
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t EfuseRdataValid                                   :1          ; //Bits :[0:0], initial value: 0x0. When set to 1 this bit indicates the validity of efuse read data
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrTsEfuseRvalid, TRegCsrTsEfuseRvalid, *PTRegCsrTsEfuseRvalid;                                //0x120D0

//Enable individual interrupting conditions. Setting a bit to 1 will enable the interrupt assertion.  Setting it
// to 0 will disable the interrupt assertion but has no effect on the Status Register bit.
//initial value: 0x0
typedef union __RegCsrInterruptEnable0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t GpioInterruptVector                               :8          ; //Bits :[0:7], initial value: 0x0. Indicates GPIO interrupt
        uint32_t VdfZbufferThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates VDF zbuffer threshold interrupt
        uint32_t VdfYbufferThresholdInterrupt                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates VDF ybuffer threshold interrupt
        uint32_t VdfCbufferThresholdInterrupt                      :1          ; //Bits :[10:10], initial value: 0x0. Indicates VDF cbuffer threshold interrupt
        uint32_t VdfZbufferDmaOverflowInterrupt                    :1          ; //Bits :[11:11], initial value: 0x0. Indicates VDF zbuffer dma_overflow interrupt
        uint32_t VdfYbufferDmaOverflowInterrupt                    :1          ; //Bits :[12:12], initial value: 0x0. Indicates VDF ybuffer dma_overflow interrupt
        uint32_t VdfCbufferDmaOverflowInterrupt                    :1          ; //Bits :[13:13], initial value: 0x0. Indicates VDF cbuffer dma_overflow interrupt
        uint32_t VdfZbufferFrameErrorInterrupt                     :1          ; //Bits :[14:14], initial value: 0x0. Indicates VDF zbuffer frame_error interrupt
        uint32_t VdfYbufferFrameErrorInterrupt                     :1          ; //Bits :[15:15], initial value: 0x0. Indicates VDF ybuffer frame_error interrupt
        uint32_t VdfCbufferFrameErrorInterrupt                     :1          ; //Bits :[16:16], initial value: 0x0. Indicates VDF cbuffer frame_error interrupt
        uint32_t VdfCompressedDataFrameInterrupt                   :1          ; //Bits :[17:17], initial value: 0x0. Indicates VDF compressed_data_frame interrupt
        uint32_t VdfMipiNseEmbeddedDataPacketTxCompletion          :1          ; //Bits :[18:18], initial value: 0x0. Indicates VDF MIPI NSE  Embedded Data packet TX completion
        uint32_t SofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[19:19], initial value: 0x0. Indicates SOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t EofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[20:20], initial value: 0x0. Indicates EOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t SofForTheActiveYRecBufferStreamUsbEndpoint3       :1          ; //Bits :[21:21], initial value: 0x0. Indicates SOF for the active Y (Rec) buffer stream USB Endpoint 3
        uint32_t EofForTheActiveZRecBufferStreamUsbEndpoint3       :1          ; //Bits :[22:22], initial value: 0x0. Indicates EOF for the active Z (Rec) buffer stream USB Endpoint 3
        uint32_t SofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[23:23], initial value: 0x0. Indicates SOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t EofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[24:24], initial value: 0x0. Indicates EOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t Egpio60InterruptVector                            :7          ; //Bits :[25:31], initial value: 0x0. Indicates EGPIO[6:0] interrupt
     } fields_read;
    struct {
        uint32_t GpioInterruptVector                               :8          ; //Bits :[0:7], initial value: 0x0. Indicates GPIO interrupt
        uint32_t VdfZbufferThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates VDF zbuffer threshold interrupt
        uint32_t VdfYbufferThresholdInterrupt                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates VDF ybuffer threshold interrupt
        uint32_t VdfCbufferThresholdInterrupt                      :1          ; //Bits :[10:10], initial value: 0x0. Indicates VDF cbuffer threshold interrupt
        uint32_t VdfZbufferDmaOverflowInterrupt                    :1          ; //Bits :[11:11], initial value: 0x0. Indicates VDF zbuffer dma_overflow interrupt
        uint32_t VdfYbufferDmaOverflowInterrupt                    :1          ; //Bits :[12:12], initial value: 0x0. Indicates VDF ybuffer dma_overflow interrupt
        uint32_t VdfCbufferDmaOverflowInterrupt                    :1          ; //Bits :[13:13], initial value: 0x0. Indicates VDF cbuffer dma_overflow interrupt
        uint32_t VdfZbufferFrameErrorInterrupt                     :1          ; //Bits :[14:14], initial value: 0x0. Indicates VDF zbuffer frame_error interrupt
        uint32_t VdfYbufferFrameErrorInterrupt                     :1          ; //Bits :[15:15], initial value: 0x0. Indicates VDF ybuffer frame_error interrupt
        uint32_t VdfCbufferFrameErrorInterrupt                     :1          ; //Bits :[16:16], initial value: 0x0. Indicates VDF cbuffer frame_error interrupt
        uint32_t VdfCompressedDataFrameInterrupt                   :1          ; //Bits :[17:17], initial value: 0x0. Indicates VDF compressed_data_frame interrupt
        uint32_t VdfMipiNseEmbeddedDataPacketTxCompletion          :1          ; //Bits :[18:18], initial value: 0x0. Indicates VDF MIPI NSE  Embedded Data packet TX completion
        uint32_t SofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[19:19], initial value: 0x0. Indicates SOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t EofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[20:20], initial value: 0x0. Indicates EOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t SofForTheActiveYRecBufferStreamUsbEndpoint3       :1          ; //Bits :[21:21], initial value: 0x0. Indicates SOF for the active Y (Rec) buffer stream USB Endpoint 3
        uint32_t EofForTheActiveZRecBufferStreamUsbEndpoint3       :1          ; //Bits :[22:22], initial value: 0x0. Indicates EOF for the active Z (Rec) buffer stream USB Endpoint 3
        uint32_t SofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[23:23], initial value: 0x0. Indicates SOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t EofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[24:24], initial value: 0x0. Indicates EOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t Egpio60InterruptVector                            :7          ; //Bits :[25:31], initial value: 0x0. Indicates EGPIO[6:0] interrupt
     } fields_write;
    struct {
        uint32_t GpioInterruptVector                               :8          ; //Bits :[0:7], initial value: 0x0. Indicates GPIO interrupt
        uint32_t VdfZbufferThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates VDF zbuffer threshold interrupt
        uint32_t VdfYbufferThresholdInterrupt                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates VDF ybuffer threshold interrupt
        uint32_t VdfCbufferThresholdInterrupt                      :1          ; //Bits :[10:10], initial value: 0x0. Indicates VDF cbuffer threshold interrupt
        uint32_t VdfZbufferDmaOverflowInterrupt                    :1          ; //Bits :[11:11], initial value: 0x0. Indicates VDF zbuffer dma_overflow interrupt
        uint32_t VdfYbufferDmaOverflowInterrupt                    :1          ; //Bits :[12:12], initial value: 0x0. Indicates VDF ybuffer dma_overflow interrupt
        uint32_t VdfCbufferDmaOverflowInterrupt                    :1          ; //Bits :[13:13], initial value: 0x0. Indicates VDF cbuffer dma_overflow interrupt
        uint32_t VdfZbufferFrameErrorInterrupt                     :1          ; //Bits :[14:14], initial value: 0x0. Indicates VDF zbuffer frame_error interrupt
        uint32_t VdfYbufferFrameErrorInterrupt                     :1          ; //Bits :[15:15], initial value: 0x0. Indicates VDF ybuffer frame_error interrupt
        uint32_t VdfCbufferFrameErrorInterrupt                     :1          ; //Bits :[16:16], initial value: 0x0. Indicates VDF cbuffer frame_error interrupt
        uint32_t VdfCompressedDataFrameInterrupt                   :1          ; //Bits :[17:17], initial value: 0x0. Indicates VDF compressed_data_frame interrupt
        uint32_t VdfMipiNseEmbeddedDataPacketTxCompletion          :1          ; //Bits :[18:18], initial value: 0x0. Indicates VDF MIPI NSE  Embedded Data packet TX completion
        uint32_t SofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[19:19], initial value: 0x0. Indicates SOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t EofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[20:20], initial value: 0x0. Indicates EOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t SofForTheActiveYRecBufferStreamUsbEndpoint3       :1          ; //Bits :[21:21], initial value: 0x0. Indicates SOF for the active Y (Rec) buffer stream USB Endpoint 3
        uint32_t EofForTheActiveZRecBufferStreamUsbEndpoint3       :1          ; //Bits :[22:22], initial value: 0x0. Indicates EOF for the active Z (Rec) buffer stream USB Endpoint 3
        uint32_t SofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[23:23], initial value: 0x0. Indicates SOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t EofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[24:24], initial value: 0x0. Indicates EOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t Egpio60InterruptVector                            :7          ; //Bits :[25:31], initial value: 0x0. Indicates EGPIO[6:0] interrupt
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptEnable0, TRegCsrInterruptEnable0, *PTRegCsrInterruptEnable0;                                //0x12040

//Enable individual interrupting conditions. Setting a bit to 1 will enable the interrupt assertion.  Setting it
// to 0 will disable the interrupt assertion but has no effect on the Status Register bit.
//initial value: 0x0
typedef union __RegCsrInterruptEnable1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MipiAInterrupt1                                   :1          ; //Bits :[0:0], initial value: 0x0. Indicates MIPI_A_Interrupt_1
        uint32_t MipiBInterrupt1                                   :1          ; //Bits :[1:1], initial value: 0x0. Indicates MIPI_B_Interrupt_1
        uint32_t MipiMInterrupt1                                   :1          ; //Bits :[2:2], initial value: 0x0. Indicates MIPI_M_Interrupt_1
        uint32_t MipiYInterrupt1                                   :1          ; //Bits :[3:3], initial value: 0x0. Indicates MIPI_Y_Interrupt_1
        uint32_t MipiZInterrupt1                                   :1          ; //Bits :[4:4], initial value: 0x0. Indicates MIPI_Z_Interrupt_1
        uint32_t ImagerAVsync                                      :1          ; //Bits :[5:5], initial value: 0x0. Indicates Imager A Vsync
        uint32_t ImagerBVsync                                      :1          ; //Bits :[6:6], initial value: 0x0. Indicates Imager B Vsync
        uint32_t ImagerMVsync                                      :1          ; //Bits :[7:7], initial value: 0x0. Indicates Imager M Vsync
        uint32_t ImagerYVsync                                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates Imager Y Vsync
        uint32_t ImagerZVsync                                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates Imager Z Vsync
        uint32_t WebPathCoreZFifoUnderflow                         :1          ; //Bits :[10:10], initial value: 0x0. Web path core Z fifo underflow
        uint32_t WebPathCoreZFifoOverflow                          :1          ; //Bits :[11:11], initial value: 0x0. Web path core Z fifo overflow
        uint32_t WebPathCoreYFifoUnderflow                         :1          ; //Bits :[12:12], initial value: 0x0. Web path core Y fifo underflow
        uint32_t WebPathCoreYFifoOverflow                          :1          ; //Bits :[13:13], initial value: 0x0. Web path core Y fifo overflow
        uint32_t WebPathCoreMFifoUnderflow                         :1          ; //Bits :[14:14], initial value: 0x0. Web path core M fifo underflow
        uint32_t WebPathCoreMFifoOverflow                          :1          ; //Bits :[15:15], initial value: 0x0. Web path core M fifo overflow
        uint32_t WebPathCoreBFifoUnderflow                         :1          ; //Bits :[16:16], initial value: 0x0. Web path core B fifo underflow
        uint32_t WebPathCoreBFifoOverflow                          :1          ; //Bits :[17:17], initial value: 0x0. Web path core B fifo overflow
        uint32_t WebPathCoreAFifoUnderflow                         :1          ; //Bits :[18:18], initial value: 0x0. Web path core A fifo underflow
        uint32_t WebPathCoreAFifoOverflow                          :1          ; //Bits :[19:19], initial value: 0x0. Web path core A fifo overflow
        uint32_t MissedMasterStrobe                                :1          ; //Bits :[20:20], initial value: 0x0. Fast vsync – missed master strobe – config too long
        uint32_t EmbeddedDataReadyToRead                           :1          ; //Bits :[21:21], initial value: 0x0. Embedded data ready to read
        uint32_t DepthSof                                          :1          ; //Bits :[22:22], initial value: 0x0. Depth SOF – rising edge of vvalid going to Rec
        uint32_t DepthEof                                          :1          ; //Bits :[23:23], initial value: 0x0. Depth EOF – falling edge of vvalid going to Rec
        uint32_t WebSof                                            :1          ; //Bits :[24:24], initial value: 0x0.  Web SOF – rising edge of vvalid on Cam to VDF A
        uint32_t WebEof                                            :1          ; //Bits :[25:25], initial value: 0x0. falling edge of vvalid on Cam to VDF A
        uint32_t IspEof                                            :1          ; //Bits :[26:26], initial value: 0x0. ISP EOF – falling edge of vvalid on path to ITM – MIPI out
        uint32_t TempsenseThresholdOverflow                        :1          ; //Bits :[27:27], initial value: 0x0. Indicates Tempsense Threshold Overflow
        uint32_t PmuBobReservedAtBit31PowerenableAtBit30ClockEnableBit29AndWakupAtBit28Interrupt:4          ; //Bits :[28:31], initial value: 0x0. Indicates PMU BOB Reserved (31) PowerEnable (30), Clock enable (29) and Wakup(28)  Interrupt
     } fields_read;
    struct {
        uint32_t MipiAInterrupt1                                   :1          ; //Bits :[0:0], initial value: 0x0. Indicates MIPI_A_Interrupt_1
        uint32_t MipiBInterrupt1                                   :1          ; //Bits :[1:1], initial value: 0x0. Indicates MIPI_B_Interrupt_1
        uint32_t MipiMInterrupt1                                   :1          ; //Bits :[2:2], initial value: 0x0. Indicates MIPI_M_Interrupt_1
        uint32_t MipiYInterrupt1                                   :1          ; //Bits :[3:3], initial value: 0x0. Indicates MIPI_Y_Interrupt_1
        uint32_t MipiZInterrupt1                                   :1          ; //Bits :[4:4], initial value: 0x0. Indicates MIPI_Z_Interrupt_1
        uint32_t ImagerAVsync                                      :1          ; //Bits :[5:5], initial value: 0x0. Indicates Imager A Vsync
        uint32_t ImagerBVsync                                      :1          ; //Bits :[6:6], initial value: 0x0. Indicates Imager B Vsync
        uint32_t ImagerMVsync                                      :1          ; //Bits :[7:7], initial value: 0x0. Indicates Imager M Vsync
        uint32_t ImagerYVsync                                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates Imager Y Vsync
        uint32_t ImagerZVsync                                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates Imager Z Vsync
        uint32_t WebPathCoreZFifoUnderflow                         :1          ; //Bits :[10:10], initial value: 0x0. Web path core Z fifo underflow
        uint32_t WebPathCoreZFifoOverflow                          :1          ; //Bits :[11:11], initial value: 0x0. Web path core Z fifo overflow
        uint32_t WebPathCoreYFifoUnderflow                         :1          ; //Bits :[12:12], initial value: 0x0. Web path core Y fifo underflow
        uint32_t WebPathCoreYFifoOverflow                          :1          ; //Bits :[13:13], initial value: 0x0. Web path core Y fifo overflow
        uint32_t WebPathCoreMFifoUnderflow                         :1          ; //Bits :[14:14], initial value: 0x0. Web path core M fifo underflow
        uint32_t WebPathCoreMFifoOverflow                          :1          ; //Bits :[15:15], initial value: 0x0. Web path core M fifo overflow
        uint32_t WebPathCoreBFifoUnderflow                         :1          ; //Bits :[16:16], initial value: 0x0. Web path core B fifo underflow
        uint32_t WebPathCoreBFifoOverflow                          :1          ; //Bits :[17:17], initial value: 0x0. Web path core B fifo overflow
        uint32_t WebPathCoreAFifoUnderflow                         :1          ; //Bits :[18:18], initial value: 0x0. Web path core A fifo underflow
        uint32_t WebPathCoreAFifoOverflow                          :1          ; //Bits :[19:19], initial value: 0x0. Web path core A fifo overflow
        uint32_t MissedMasterStrobe                                :1          ; //Bits :[20:20], initial value: 0x0. Fast vsync – missed master strobe – config too long
        uint32_t EmbeddedDataReadyToRead                           :1          ; //Bits :[21:21], initial value: 0x0. Embedded data ready to read
        uint32_t DepthSof                                          :1          ; //Bits :[22:22], initial value: 0x0. Depth SOF – rising edge of vvalid going to Rec
        uint32_t DepthEof                                          :1          ; //Bits :[23:23], initial value: 0x0. Depth EOF – falling edge of vvalid going to Rec
        uint32_t WebSof                                            :1          ; //Bits :[24:24], initial value: 0x0.  Web SOF – rising edge of vvalid on Cam to VDF A
        uint32_t WebEof                                            :1          ; //Bits :[25:25], initial value: 0x0. falling edge of vvalid on Cam to VDF A
        uint32_t IspEof                                            :1          ; //Bits :[26:26], initial value: 0x0. ISP EOF – falling edge of vvalid on path to ITM – MIPI out
        uint32_t TempsenseThresholdOverflow                        :1          ; //Bits :[27:27], initial value: 0x0. Indicates Tempsense Threshold Overflow
        uint32_t PmuBobReservedAtBit31PowerenableAtBit30ClockEnableBit29AndWakupAtBit28Interrupt:4          ; //Bits :[28:31], initial value: 0x0. Indicates PMU BOB Reserved (31) PowerEnable (30), Clock enable (29) and Wakup(28)  Interrupt
     } fields_write;
    struct {
        uint32_t MipiAInterrupt1                                   :1          ; //Bits :[0:0], initial value: 0x0. Indicates MIPI_A_Interrupt_1
        uint32_t MipiBInterrupt1                                   :1          ; //Bits :[1:1], initial value: 0x0. Indicates MIPI_B_Interrupt_1
        uint32_t MipiMInterrupt1                                   :1          ; //Bits :[2:2], initial value: 0x0. Indicates MIPI_M_Interrupt_1
        uint32_t MipiYInterrupt1                                   :1          ; //Bits :[3:3], initial value: 0x0. Indicates MIPI_Y_Interrupt_1
        uint32_t MipiZInterrupt1                                   :1          ; //Bits :[4:4], initial value: 0x0. Indicates MIPI_Z_Interrupt_1
        uint32_t ImagerAVsync                                      :1          ; //Bits :[5:5], initial value: 0x0. Indicates Imager A Vsync
        uint32_t ImagerBVsync                                      :1          ; //Bits :[6:6], initial value: 0x0. Indicates Imager B Vsync
        uint32_t ImagerMVsync                                      :1          ; //Bits :[7:7], initial value: 0x0. Indicates Imager M Vsync
        uint32_t ImagerYVsync                                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates Imager Y Vsync
        uint32_t ImagerZVsync                                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates Imager Z Vsync
        uint32_t WebPathCoreZFifoUnderflow                         :1          ; //Bits :[10:10], initial value: 0x0. Web path core Z fifo underflow
        uint32_t WebPathCoreZFifoOverflow                          :1          ; //Bits :[11:11], initial value: 0x0. Web path core Z fifo overflow
        uint32_t WebPathCoreYFifoUnderflow                         :1          ; //Bits :[12:12], initial value: 0x0. Web path core Y fifo underflow
        uint32_t WebPathCoreYFifoOverflow                          :1          ; //Bits :[13:13], initial value: 0x0. Web path core Y fifo overflow
        uint32_t WebPathCoreMFifoUnderflow                         :1          ; //Bits :[14:14], initial value: 0x0. Web path core M fifo underflow
        uint32_t WebPathCoreMFifoOverflow                          :1          ; //Bits :[15:15], initial value: 0x0. Web path core M fifo overflow
        uint32_t WebPathCoreBFifoUnderflow                         :1          ; //Bits :[16:16], initial value: 0x0. Web path core B fifo underflow
        uint32_t WebPathCoreBFifoOverflow                          :1          ; //Bits :[17:17], initial value: 0x0. Web path core B fifo overflow
        uint32_t WebPathCoreAFifoUnderflow                         :1          ; //Bits :[18:18], initial value: 0x0. Web path core A fifo underflow
        uint32_t WebPathCoreAFifoOverflow                          :1          ; //Bits :[19:19], initial value: 0x0. Web path core A fifo overflow
        uint32_t MissedMasterStrobe                                :1          ; //Bits :[20:20], initial value: 0x0. Fast vsync – missed master strobe – config too long
        uint32_t EmbeddedDataReadyToRead                           :1          ; //Bits :[21:21], initial value: 0x0. Embedded data ready to read
        uint32_t DepthSof                                          :1          ; //Bits :[22:22], initial value: 0x0. Depth SOF – rising edge of vvalid going to Rec
        uint32_t DepthEof                                          :1          ; //Bits :[23:23], initial value: 0x0. Depth EOF – falling edge of vvalid going to Rec
        uint32_t WebSof                                            :1          ; //Bits :[24:24], initial value: 0x0.  Web SOF – rising edge of vvalid on Cam to VDF A
        uint32_t WebEof                                            :1          ; //Bits :[25:25], initial value: 0x0. falling edge of vvalid on Cam to VDF A
        uint32_t IspEof                                            :1          ; //Bits :[26:26], initial value: 0x0. ISP EOF – falling edge of vvalid on path to ITM – MIPI out
        uint32_t TempsenseThresholdOverflow                        :1          ; //Bits :[27:27], initial value: 0x0. Indicates Tempsense Threshold Overflow
        uint32_t PmuBobReservedAtBit31PowerenableAtBit30ClockEnableBit29AndWakupAtBit28Interrupt:4          ; //Bits :[28:31], initial value: 0x0. Indicates PMU BOB Reserved (31) PowerEnable (30), Clock enable (29) and Wakup(28)  Interrupt
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptEnable1, TRegCsrInterruptEnable1, *PTRegCsrInterruptEnable1;                                //0x12044

//Enable individual interrupting conditions. Setting a bit to 1 will enable the interrupt assertion.  Setting it
// to 0 will disable the interrupt assertion but has no effect on the Status Register bit.
//initial value: 0x0
typedef union __RegCsrInterruptEnable2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelStreamerZFifoUnderflow                       :1          ; //Bits :[0:0], initial value: 0x0.  Pixel streamer Z fifo underflow
        uint32_t PixelStreamerZFifoOverflow                        :1          ; //Bits :[1:1], initial value: 0x0. Pixel streamer Z fifo overflow
        uint32_t PixelStreamerYFifoUnderflow                       :1          ; //Bits :[2:2], initial value: 0x0.  Pixel streamer Y fifo underflow
        uint32_t PixelStreamerYFifoOverflow                        :1          ; //Bits :[3:3], initial value: 0x0. Pixel streamer Y fifo overflow
        uint32_t PixelStreamerMFifoUnderflow                       :1          ; //Bits :[4:4], initial value: 0x0.  Pixel streamer M fifo underflow
        uint32_t PixelStreamerMFifoOverflow                        :1          ; //Bits :[5:5], initial value: 0x0. Pixel streamer M fifo overflow
        uint32_t PixelStreamerBFifoUnderflow                       :1          ; //Bits :[6:6], initial value: 0x0.  Pixel streamer B fifo underflow
        uint32_t PixelStreamerBFifoOverflow                        :1          ; //Bits :[7:7], initial value: 0x0. Pixel streamer B fifo overflow
        uint32_t PixelStreamerAFifoUnderflow                       :1          ; //Bits :[8:8], initial value: 0x0.  Pixel streamer A fifo underflow
        uint32_t PixelStreamerAFifoOverflow                        :1          ; //Bits :[9:9], initial value: 0x0. Pixel streamer A fifo overflow
        uint32_t SyncAlignRightFifoUnderflow                       :1          ; //Bits :[10:10], initial value: 0x0. Sync align right fifo underflow
        uint32_t SyncAlignRightFifoOverflow                        :1          ; //Bits :[11:11], initial value: 0x0. Sync align right fifo overflow
        uint32_t SyncAlignLeftFifoUnderflow                        :1          ; //Bits :[12:12], initial value: 0x0. Sync align left fifo underflow
        uint32_t SyncAlignLeftFifoOverflow                         :1          ; //Bits :[13:13], initial value: 0x0. Sync align left fifo overflow
        uint32_t VyncMasterRisingEdge                              :1          ; //Bits :[14:14], initial value: 0x0. Vsync master rising edge
        uint32_t RecInterruptVector                                :9          ; //Bits :[15:23], initial value: 0x0. Indicates REC interrupt
        uint32_t ItmInterruptVector                                :4          ; //Bits :[24:27], initial value: 0x0. Indicates ITM interrupt
        uint32_t MtrIspUnderflowIntr                               :1          ; //Bits :[28:28], initial value: 0x0. Indicates MTR ISP underflow interrupt
        uint32_t MtrHostUnderflowIntr                              :1          ; //Bits :[29:29], initial value: 0x0. Indicates MTR host underflow interrupt
        uint32_t LaserInterrupt                                    :1          ; //Bits :[30:30], initial value: 0x0. Indicates Laser Interrupt
        uint32_t Reserved                                          :1          ; //Bits :[31:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PixelStreamerZFifoUnderflow                       :1          ; //Bits :[0:0], initial value: 0x0.  Pixel streamer Z fifo underflow
        uint32_t PixelStreamerZFifoOverflow                        :1          ; //Bits :[1:1], initial value: 0x0. Pixel streamer Z fifo overflow
        uint32_t PixelStreamerYFifoUnderflow                       :1          ; //Bits :[2:2], initial value: 0x0.  Pixel streamer Y fifo underflow
        uint32_t PixelStreamerYFifoOverflow                        :1          ; //Bits :[3:3], initial value: 0x0. Pixel streamer Y fifo overflow
        uint32_t PixelStreamerMFifoUnderflow                       :1          ; //Bits :[4:4], initial value: 0x0.  Pixel streamer M fifo underflow
        uint32_t PixelStreamerMFifoOverflow                        :1          ; //Bits :[5:5], initial value: 0x0. Pixel streamer M fifo overflow
        uint32_t PixelStreamerBFifoUnderflow                       :1          ; //Bits :[6:6], initial value: 0x0.  Pixel streamer B fifo underflow
        uint32_t PixelStreamerBFifoOverflow                        :1          ; //Bits :[7:7], initial value: 0x0. Pixel streamer B fifo overflow
        uint32_t PixelStreamerAFifoUnderflow                       :1          ; //Bits :[8:8], initial value: 0x0.  Pixel streamer A fifo underflow
        uint32_t PixelStreamerAFifoOverflow                        :1          ; //Bits :[9:9], initial value: 0x0. Pixel streamer A fifo overflow
        uint32_t SyncAlignRightFifoUnderflow                       :1          ; //Bits :[10:10], initial value: 0x0. Sync align right fifo underflow
        uint32_t SyncAlignRightFifoOverflow                        :1          ; //Bits :[11:11], initial value: 0x0. Sync align right fifo overflow
        uint32_t SyncAlignLeftFifoUnderflow                        :1          ; //Bits :[12:12], initial value: 0x0. Sync align left fifo underflow
        uint32_t SyncAlignLeftFifoOverflow                         :1          ; //Bits :[13:13], initial value: 0x0. Sync align left fifo overflow
        uint32_t VyncMasterRisingEdge                              :1          ; //Bits :[14:14], initial value: 0x0. Vsync master rising edge
        uint32_t RecInterruptVector                                :9          ; //Bits :[15:23], initial value: 0x0. Indicates REC interrupt
        uint32_t ItmInterruptVector                                :4          ; //Bits :[24:27], initial value: 0x0. Indicates ITM interrupt
        uint32_t MtrIspUnderflowIntr                               :1          ; //Bits :[28:28], initial value: 0x0. Indicates MTR ISP underflow interrupt
        uint32_t MtrHostUnderflowIntr                              :1          ; //Bits :[29:29], initial value: 0x0. Indicates MTR host underflow interrupt
        uint32_t LaserInterrupt                                    :1          ; //Bits :[30:30], initial value: 0x0. Indicates Laser Interrupt
        uint32_t Reserved                                          :1          ; //Bits :[31:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t PixelStreamerZFifoUnderflow                       :1          ; //Bits :[0:0], initial value: 0x0.  Pixel streamer Z fifo underflow
        uint32_t PixelStreamerZFifoOverflow                        :1          ; //Bits :[1:1], initial value: 0x0. Pixel streamer Z fifo overflow
        uint32_t PixelStreamerYFifoUnderflow                       :1          ; //Bits :[2:2], initial value: 0x0.  Pixel streamer Y fifo underflow
        uint32_t PixelStreamerYFifoOverflow                        :1          ; //Bits :[3:3], initial value: 0x0. Pixel streamer Y fifo overflow
        uint32_t PixelStreamerMFifoUnderflow                       :1          ; //Bits :[4:4], initial value: 0x0.  Pixel streamer M fifo underflow
        uint32_t PixelStreamerMFifoOverflow                        :1          ; //Bits :[5:5], initial value: 0x0. Pixel streamer M fifo overflow
        uint32_t PixelStreamerBFifoUnderflow                       :1          ; //Bits :[6:6], initial value: 0x0.  Pixel streamer B fifo underflow
        uint32_t PixelStreamerBFifoOverflow                        :1          ; //Bits :[7:7], initial value: 0x0. Pixel streamer B fifo overflow
        uint32_t PixelStreamerAFifoUnderflow                       :1          ; //Bits :[8:8], initial value: 0x0.  Pixel streamer A fifo underflow
        uint32_t PixelStreamerAFifoOverflow                        :1          ; //Bits :[9:9], initial value: 0x0. Pixel streamer A fifo overflow
        uint32_t SyncAlignRightFifoUnderflow                       :1          ; //Bits :[10:10], initial value: 0x0. Sync align right fifo underflow
        uint32_t SyncAlignRightFifoOverflow                        :1          ; //Bits :[11:11], initial value: 0x0. Sync align right fifo overflow
        uint32_t SyncAlignLeftFifoUnderflow                        :1          ; //Bits :[12:12], initial value: 0x0. Sync align left fifo underflow
        uint32_t SyncAlignLeftFifoOverflow                         :1          ; //Bits :[13:13], initial value: 0x0. Sync align left fifo overflow
        uint32_t VyncMasterRisingEdge                              :1          ; //Bits :[14:14], initial value: 0x0. Vsync master rising edge
        uint32_t RecInterruptVector                                :9          ; //Bits :[15:23], initial value: 0x0. Indicates REC interrupt
        uint32_t ItmInterruptVector                                :4          ; //Bits :[24:27], initial value: 0x0. Indicates ITM interrupt
        uint32_t MtrIspUnderflowIntr                               :1          ; //Bits :[28:28], initial value: 0x0. Indicates MTR ISP underflow interrupt
        uint32_t MtrHostUnderflowIntr                              :1          ; //Bits :[29:29], initial value: 0x0. Indicates MTR host underflow interrupt
        uint32_t LaserInterrupt                                    :1          ; //Bits :[30:30], initial value: 0x0. Indicates Laser Interrupt
        uint32_t Reserved                                          :1          ; //Bits :[31:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptEnable2, TRegCsrInterruptEnable2, *PTRegCsrInterruptEnable2;                                //0x12048

//Reading this register yields the current status of the interrupt. Writing 1 to a bit in this register will clear
//the corresponding interrupt.
//initial value: 0x080
typedef union __RegCsrInterruptStatus0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t GpioInterruptVector                               :8          ; //Bits :[0:7], initial value: 0x80. Indicates GPIO interrupt
        uint32_t VdfZbufferThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates VDF zbuffer threshold interrupt
        uint32_t VdfYbufferThresholdInterrupt                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates VDF ybuffer threshold interrupt
        uint32_t VdfCbufferThresholdInterrupt                      :1          ; //Bits :[10:10], initial value: 0x0. Indicates VDF cbuffer threshold interrupt
        uint32_t VdfZbufferDmaOverflowInterrupt                    :1          ; //Bits :[11:11], initial value: 0x0. Indicates VDF zbuffer dma_overflow interrupt
        uint32_t VdfYbufferDmaOverflowInterrupt                    :1          ; //Bits :[12:12], initial value: 0x0. Indicates VDF ybuffer dma_overflow interrupt
        uint32_t VdfCbufferDmaOverflowInterrupt                    :1          ; //Bits :[13:13], initial value: 0x0. Indicates VDF cbuffer dma_overflow interrupt
        uint32_t VdfZbufferFrameErrorInterrupt                     :1          ; //Bits :[14:14], initial value: 0x0. Indicates VDF zbuffer frame_error interrupt
        uint32_t VdfYbufferFrameErrorInterrupt                     :1          ; //Bits :[15:15], initial value: 0x0. Indicates VDF ybuffer frame_error interrupt
        uint32_t VdfCbufferFrameErrorInterrupt                     :1          ; //Bits :[16:16], initial value: 0x0. Indicates VDF cbuffer frame_error interrupt
        uint32_t VdfCompressedDataFrameInterrupt                   :1          ; //Bits :[17:17], initial value: 0x0. Indicates VDF compressed_data_frame interrupt
        uint32_t VdfMipiNseEmbeddedDataPacketTxCompletion          :1          ; //Bits :[18:18], initial value: 0x0. Indicates VDF MIPI NSE  Embedded Data packet TX completion
        uint32_t SofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[19:19], initial value: 0x0. Indicates SOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t EofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[20:20], initial value: 0x0. Indicates EOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t SofForTheActiveYRecBufferStreamUsbEndpoint3       :1          ; //Bits :[21:21], initial value: 0x0. Indicates SOF for the active Y (Rec) buffer stream USB Endpoint 3
        uint32_t EofForTheActiveZRecBufferStreamUsbEndpoint3       :1          ; //Bits :[22:22], initial value: 0x0. Indicates EOF for the active Z (Rec) buffer stream USB Endpoint 3
        uint32_t SofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[23:23], initial value: 0x0. Indicates SOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t EofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[24:24], initial value: 0x0. Indicates EOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t Egpio60InterruptVector                            :7          ; //Bits :[25:31], initial value: 0x0. Indicates EGPIO[6:0] interrupt
     } fields_read;
    struct {
        uint32_t GpioInterruptVector                               :8          ; //Bits :[0:7], initial value: 0x80. Indicates GPIO interrupt
        uint32_t VdfZbufferThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates VDF zbuffer threshold interrupt
        uint32_t VdfYbufferThresholdInterrupt                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates VDF ybuffer threshold interrupt
        uint32_t VdfCbufferThresholdInterrupt                      :1          ; //Bits :[10:10], initial value: 0x0. Indicates VDF cbuffer threshold interrupt
        uint32_t VdfZbufferDmaOverflowInterrupt                    :1          ; //Bits :[11:11], initial value: 0x0. Indicates VDF zbuffer dma_overflow interrupt
        uint32_t VdfYbufferDmaOverflowInterrupt                    :1          ; //Bits :[12:12], initial value: 0x0. Indicates VDF ybuffer dma_overflow interrupt
        uint32_t VdfCbufferDmaOverflowInterrupt                    :1          ; //Bits :[13:13], initial value: 0x0. Indicates VDF cbuffer dma_overflow interrupt
        uint32_t VdfZbufferFrameErrorInterrupt                     :1          ; //Bits :[14:14], initial value: 0x0. Indicates VDF zbuffer frame_error interrupt
        uint32_t VdfYbufferFrameErrorInterrupt                     :1          ; //Bits :[15:15], initial value: 0x0. Indicates VDF ybuffer frame_error interrupt
        uint32_t VdfCbufferFrameErrorInterrupt                     :1          ; //Bits :[16:16], initial value: 0x0. Indicates VDF cbuffer frame_error interrupt
        uint32_t VdfCompressedDataFrameInterrupt                   :1          ; //Bits :[17:17], initial value: 0x0. Indicates VDF compressed_data_frame interrupt
        uint32_t VdfMipiNseEmbeddedDataPacketTxCompletion          :1          ; //Bits :[18:18], initial value: 0x0. Indicates VDF MIPI NSE  Embedded Data packet TX completion
        uint32_t SofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[19:19], initial value: 0x0. Indicates SOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t EofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[20:20], initial value: 0x0. Indicates EOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t SofForTheActiveYRecBufferStreamUsbEndpoint3       :1          ; //Bits :[21:21], initial value: 0x0. Indicates SOF for the active Y (Rec) buffer stream USB Endpoint 3
        uint32_t EofForTheActiveZRecBufferStreamUsbEndpoint3       :1          ; //Bits :[22:22], initial value: 0x0. Indicates EOF for the active Z (Rec) buffer stream USB Endpoint 3
        uint32_t SofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[23:23], initial value: 0x0. Indicates SOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t EofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[24:24], initial value: 0x0. Indicates EOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t Egpio60InterruptVector                            :7          ; //Bits :[25:31], initial value: 0x0. Indicates EGPIO[6:0] interrupt
     } fields_write;
    struct {
        uint32_t GpioInterruptVector                               :8          ; //Bits :[0:7], initial value: 0x80. Indicates GPIO interrupt
        uint32_t VdfZbufferThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates VDF zbuffer threshold interrupt
        uint32_t VdfYbufferThresholdInterrupt                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates VDF ybuffer threshold interrupt
        uint32_t VdfCbufferThresholdInterrupt                      :1          ; //Bits :[10:10], initial value: 0x0. Indicates VDF cbuffer threshold interrupt
        uint32_t VdfZbufferDmaOverflowInterrupt                    :1          ; //Bits :[11:11], initial value: 0x0. Indicates VDF zbuffer dma_overflow interrupt
        uint32_t VdfYbufferDmaOverflowInterrupt                    :1          ; //Bits :[12:12], initial value: 0x0. Indicates VDF ybuffer dma_overflow interrupt
        uint32_t VdfCbufferDmaOverflowInterrupt                    :1          ; //Bits :[13:13], initial value: 0x0. Indicates VDF cbuffer dma_overflow interrupt
        uint32_t VdfZbufferFrameErrorInterrupt                     :1          ; //Bits :[14:14], initial value: 0x0. Indicates VDF zbuffer frame_error interrupt
        uint32_t VdfYbufferFrameErrorInterrupt                     :1          ; //Bits :[15:15], initial value: 0x0. Indicates VDF ybuffer frame_error interrupt
        uint32_t VdfCbufferFrameErrorInterrupt                     :1          ; //Bits :[16:16], initial value: 0x0. Indicates VDF cbuffer frame_error interrupt
        uint32_t VdfCompressedDataFrameInterrupt                   :1          ; //Bits :[17:17], initial value: 0x0. Indicates VDF compressed_data_frame interrupt
        uint32_t VdfMipiNseEmbeddedDataPacketTxCompletion          :1          ; //Bits :[18:18], initial value: 0x0. Indicates VDF MIPI NSE  Embedded Data packet TX completion
        uint32_t SofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[19:19], initial value: 0x0. Indicates SOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t EofForTheActiveZDepthBufferStreamUsbEndpoint2     :1          ; //Bits :[20:20], initial value: 0x0. Indicates EOF for the active Z (Depth) buffer stream USB Endpoint 2
        uint32_t SofForTheActiveYRecBufferStreamUsbEndpoint3       :1          ; //Bits :[21:21], initial value: 0x0. Indicates SOF for the active Y (Rec) buffer stream USB Endpoint 3
        uint32_t EofForTheActiveZRecBufferStreamUsbEndpoint3       :1          ; //Bits :[22:22], initial value: 0x0. Indicates EOF for the active Z (Rec) buffer stream USB Endpoint 3
        uint32_t SofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[23:23], initial value: 0x0. Indicates SOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t EofForTheActiveZWebcamBufferStreamUsbEndpoint4    :1          ; //Bits :[24:24], initial value: 0x0. Indicates EOF for the active Z (WebCam) buffer stream USB Endpoint 4
        uint32_t Egpio60InterruptVector                            :7          ; //Bits :[25:31], initial value: 0x0. Indicates EGPIO[6:0] interrupt
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptStatus0, TRegCsrInterruptStatus0, *PTRegCsrInterruptStatus0;                                //0x12050

//Reading this register yields the current status of the interrupt. Writing 1 to a bit in this register will clear
//the corresponding interrupt.
//initial value: 0x0
typedef union __RegCsrInterruptStatus1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MipiAInterrupt1                                   :1          ; //Bits :[0:0], initial value: 0x0. Indicates MIPI_A_Interrupt_1
        uint32_t MipiBInterrupt1                                   :1          ; //Bits :[1:1], initial value: 0x0. Indicates MIPI_B_Interrupt_1
        uint32_t MipiMInterrupt1                                   :1          ; //Bits :[2:2], initial value: 0x0. Indicates MIPI_M_Interrupt_1
        uint32_t MipiYInterrupt1                                   :1          ; //Bits :[3:3], initial value: 0x0. Indicates MIPI_Y_Interrupt_1
        uint32_t MipiZInterrupt1                                   :1          ; //Bits :[4:4], initial value: 0x0. Indicates MIPI_Z_Interrupt_1
        uint32_t ImagerAVsync                                      :1          ; //Bits :[5:5], initial value: 0x0. Indicates Imager A Vsync
        uint32_t ImagerBVsync                                      :1          ; //Bits :[6:6], initial value: 0x0. Indicates Imager B Vsync
        uint32_t ImagerMVsync                                      :1          ; //Bits :[7:7], initial value: 0x0. Indicates Imager M Vsync
        uint32_t ImagerYVsync                                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates Imager Y Vsync
        uint32_t ImagerZVsync                                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates Imager Z Vsync
        uint32_t WebPathCoreZFifoUnderflow                         :1          ; //Bits :[10:10], initial value: 0x0. Web path core Z fifo underflow
        uint32_t WebPathCoreZFifoOverflow                          :1          ; //Bits :[11:11], initial value: 0x0. Web path core Z fifo overflow
        uint32_t WebPathCoreYFifoUnderflow                         :1          ; //Bits :[12:12], initial value: 0x0. Web path core Y fifo underflow
        uint32_t WebPathCoreYFifoOverflow                          :1          ; //Bits :[13:13], initial value: 0x0. Web path core Y fifo overflow
        uint32_t WebPathCoreMFifoUnderflow                         :1          ; //Bits :[14:14], initial value: 0x0. Web path core M fifo underflow
        uint32_t WebPathCoreMFifoOverflow                          :1          ; //Bits :[15:15], initial value: 0x0. Web path core M fifo overflow
        uint32_t WebPathCoreBFifoUnderflow                         :1          ; //Bits :[16:16], initial value: 0x0. Web path core B fifo underflow
        uint32_t WebPathCoreBFifoOverflow                          :1          ; //Bits :[17:17], initial value: 0x0. Web path core B fifo overflow
        uint32_t WebPathCoreAFifoUnderflow                         :1          ; //Bits :[18:18], initial value: 0x0. Web path core A fifo underflow
        uint32_t WebPathCoreAFifoOverflow                          :1          ; //Bits :[19:19], initial value: 0x0. Web path core A fifo overflow
        uint32_t MissedMasterStrobe                                :1          ; //Bits :[20:20], initial value: 0x0. Fast vsync – missed master strobe – config too long
        uint32_t EmbeddedDataReadyToRead                           :1          ; //Bits :[21:21], initial value: 0x0. Embedded data ready to read
        uint32_t DepthSof                                          :1          ; //Bits :[22:22], initial value: 0x0. Depth SOF – rising edge of vvalid going to Rec
        uint32_t DepthEof                                          :1          ; //Bits :[23:23], initial value: 0x0. Depth EOF – falling edge of vvalid going to Rec
        uint32_t WebSof                                            :1          ; //Bits :[24:24], initial value: 0x0.  Web SOF – rising edge of vvalid on Cam to VDF A
        uint32_t WebEof                                            :1          ; //Bits :[25:25], initial value: 0x0. falling edge of vvalid on Cam to VDF A
        uint32_t IspEof                                            :1          ; //Bits :[26:26], initial value: 0x0. ISP EOF – falling edge of vvalid on path to ITM – MIPI out
        uint32_t TempsenseThresholdOverflow                        :1          ; //Bits :[27:27], initial value: 0x0. Indicates Tempsense Threshold Overflow
        uint32_t PmuBobReservedAtBit31PowerenableAtBit30ClockEnableBit29AndWakupAtBit28Interrupt:4          ; //Bits :[28:31], initial value: 0x0. Indicates PMU BOB Reserved (31) PowerEnable (30), Clock enable (29) and Wakup(28)  Interrupt
     } fields_read;
    struct {
        uint32_t MipiAInterrupt1                                   :1          ; //Bits :[0:0], initial value: 0x0. Indicates MIPI_A_Interrupt_1
        uint32_t MipiBInterrupt1                                   :1          ; //Bits :[1:1], initial value: 0x0. Indicates MIPI_B_Interrupt_1
        uint32_t MipiMInterrupt1                                   :1          ; //Bits :[2:2], initial value: 0x0. Indicates MIPI_M_Interrupt_1
        uint32_t MipiYInterrupt1                                   :1          ; //Bits :[3:3], initial value: 0x0. Indicates MIPI_Y_Interrupt_1
        uint32_t MipiZInterrupt1                                   :1          ; //Bits :[4:4], initial value: 0x0. Indicates MIPI_Z_Interrupt_1
        uint32_t ImagerAVsync                                      :1          ; //Bits :[5:5], initial value: 0x0. Indicates Imager A Vsync
        uint32_t ImagerBVsync                                      :1          ; //Bits :[6:6], initial value: 0x0. Indicates Imager B Vsync
        uint32_t ImagerMVsync                                      :1          ; //Bits :[7:7], initial value: 0x0. Indicates Imager M Vsync
        uint32_t ImagerYVsync                                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates Imager Y Vsync
        uint32_t ImagerZVsync                                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates Imager Z Vsync
        uint32_t WebPathCoreZFifoUnderflow                         :1          ; //Bits :[10:10], initial value: 0x0. Web path core Z fifo underflow
        uint32_t WebPathCoreZFifoOverflow                          :1          ; //Bits :[11:11], initial value: 0x0. Web path core Z fifo overflow
        uint32_t WebPathCoreYFifoUnderflow                         :1          ; //Bits :[12:12], initial value: 0x0. Web path core Y fifo underflow
        uint32_t WebPathCoreYFifoOverflow                          :1          ; //Bits :[13:13], initial value: 0x0. Web path core Y fifo overflow
        uint32_t WebPathCoreMFifoUnderflow                         :1          ; //Bits :[14:14], initial value: 0x0. Web path core M fifo underflow
        uint32_t WebPathCoreMFifoOverflow                          :1          ; //Bits :[15:15], initial value: 0x0. Web path core M fifo overflow
        uint32_t WebPathCoreBFifoUnderflow                         :1          ; //Bits :[16:16], initial value: 0x0. Web path core B fifo underflow
        uint32_t WebPathCoreBFifoOverflow                          :1          ; //Bits :[17:17], initial value: 0x0. Web path core B fifo overflow
        uint32_t WebPathCoreAFifoUnderflow                         :1          ; //Bits :[18:18], initial value: 0x0. Web path core A fifo underflow
        uint32_t WebPathCoreAFifoOverflow                          :1          ; //Bits :[19:19], initial value: 0x0. Web path core A fifo overflow
        uint32_t MissedMasterStrobe                                :1          ; //Bits :[20:20], initial value: 0x0. Fast vsync – missed master strobe – config too long
        uint32_t EmbeddedDataReadyToRead                           :1          ; //Bits :[21:21], initial value: 0x0. Embedded data ready to read
        uint32_t DepthSof                                          :1          ; //Bits :[22:22], initial value: 0x0. Depth SOF – rising edge of vvalid going to Rec
        uint32_t DepthEof                                          :1          ; //Bits :[23:23], initial value: 0x0. Depth EOF – falling edge of vvalid going to Rec
        uint32_t WebSof                                            :1          ; //Bits :[24:24], initial value: 0x0.  Web SOF – rising edge of vvalid on Cam to VDF A
        uint32_t WebEof                                            :1          ; //Bits :[25:25], initial value: 0x0. falling edge of vvalid on Cam to VDF A
        uint32_t IspEof                                            :1          ; //Bits :[26:26], initial value: 0x0. ISP EOF – falling edge of vvalid on path to ITM – MIPI out
        uint32_t TempsenseThresholdOverflow                        :1          ; //Bits :[27:27], initial value: 0x0. Indicates Tempsense Threshold Overflow
        uint32_t PmuBobReservedAtBit31PowerenableAtBit30ClockEnableBit29AndWakupAtBit28Interrupt:4          ; //Bits :[28:31], initial value: 0x0. Indicates PMU BOB Reserved (31) PowerEnable (30), Clock enable (29) and Wakup(28)  Interrupt
     } fields_write;
    struct {
        uint32_t MipiAInterrupt1                                   :1          ; //Bits :[0:0], initial value: 0x0. Indicates MIPI_A_Interrupt_1
        uint32_t MipiBInterrupt1                                   :1          ; //Bits :[1:1], initial value: 0x0. Indicates MIPI_B_Interrupt_1
        uint32_t MipiMInterrupt1                                   :1          ; //Bits :[2:2], initial value: 0x0. Indicates MIPI_M_Interrupt_1
        uint32_t MipiYInterrupt1                                   :1          ; //Bits :[3:3], initial value: 0x0. Indicates MIPI_Y_Interrupt_1
        uint32_t MipiZInterrupt1                                   :1          ; //Bits :[4:4], initial value: 0x0. Indicates MIPI_Z_Interrupt_1
        uint32_t ImagerAVsync                                      :1          ; //Bits :[5:5], initial value: 0x0. Indicates Imager A Vsync
        uint32_t ImagerBVsync                                      :1          ; //Bits :[6:6], initial value: 0x0. Indicates Imager B Vsync
        uint32_t ImagerMVsync                                      :1          ; //Bits :[7:7], initial value: 0x0. Indicates Imager M Vsync
        uint32_t ImagerYVsync                                      :1          ; //Bits :[8:8], initial value: 0x0. Indicates Imager Y Vsync
        uint32_t ImagerZVsync                                      :1          ; //Bits :[9:9], initial value: 0x0. Indicates Imager Z Vsync
        uint32_t WebPathCoreZFifoUnderflow                         :1          ; //Bits :[10:10], initial value: 0x0. Web path core Z fifo underflow
        uint32_t WebPathCoreZFifoOverflow                          :1          ; //Bits :[11:11], initial value: 0x0. Web path core Z fifo overflow
        uint32_t WebPathCoreYFifoUnderflow                         :1          ; //Bits :[12:12], initial value: 0x0. Web path core Y fifo underflow
        uint32_t WebPathCoreYFifoOverflow                          :1          ; //Bits :[13:13], initial value: 0x0. Web path core Y fifo overflow
        uint32_t WebPathCoreMFifoUnderflow                         :1          ; //Bits :[14:14], initial value: 0x0. Web path core M fifo underflow
        uint32_t WebPathCoreMFifoOverflow                          :1          ; //Bits :[15:15], initial value: 0x0. Web path core M fifo overflow
        uint32_t WebPathCoreBFifoUnderflow                         :1          ; //Bits :[16:16], initial value: 0x0. Web path core B fifo underflow
        uint32_t WebPathCoreBFifoOverflow                          :1          ; //Bits :[17:17], initial value: 0x0. Web path core B fifo overflow
        uint32_t WebPathCoreAFifoUnderflow                         :1          ; //Bits :[18:18], initial value: 0x0. Web path core A fifo underflow
        uint32_t WebPathCoreAFifoOverflow                          :1          ; //Bits :[19:19], initial value: 0x0. Web path core A fifo overflow
        uint32_t MissedMasterStrobe                                :1          ; //Bits :[20:20], initial value: 0x0. Fast vsync – missed master strobe – config too long
        uint32_t EmbeddedDataReadyToRead                           :1          ; //Bits :[21:21], initial value: 0x0. Embedded data ready to read
        uint32_t DepthSof                                          :1          ; //Bits :[22:22], initial value: 0x0. Depth SOF – rising edge of vvalid going to Rec
        uint32_t DepthEof                                          :1          ; //Bits :[23:23], initial value: 0x0. Depth EOF – falling edge of vvalid going to Rec
        uint32_t WebSof                                            :1          ; //Bits :[24:24], initial value: 0x0.  Web SOF – rising edge of vvalid on Cam to VDF A
        uint32_t WebEof                                            :1          ; //Bits :[25:25], initial value: 0x0. falling edge of vvalid on Cam to VDF A
        uint32_t IspEof                                            :1          ; //Bits :[26:26], initial value: 0x0. ISP EOF – falling edge of vvalid on path to ITM – MIPI out
        uint32_t TempsenseThresholdOverflow                        :1          ; //Bits :[27:27], initial value: 0x0. Indicates Tempsense Threshold Overflow
        uint32_t PmuBobReservedAtBit31PowerenableAtBit30ClockEnableBit29AndWakupAtBit28Interrupt:4          ; //Bits :[28:31], initial value: 0x0. Indicates PMU BOB Reserved (31) PowerEnable (30), Clock enable (29) and Wakup(28)  Interrupt
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptStatus1, TRegCsrInterruptStatus1, *PTRegCsrInterruptStatus1;                                //0x12054

//Reading this register yields the current status of the interrupt. Writing 1 to a bit in this register will clear
//the corresponding interrupt.
//initial value: 0x0
typedef union __RegCsrInterruptStatus2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelStreamerZFifoUnderflow                       :1          ; //Bits :[0:0], initial value: 0x0.  Pixel streamer Z fifo underflow
        uint32_t PixelStreamerZFifoOverflow                        :1          ; //Bits :[1:1], initial value: 0x0. Pixel streamer Z fifo overflow
        uint32_t PixelStreamerYFifoUnderflow                       :1          ; //Bits :[2:2], initial value: 0x0.  Pixel streamer Y fifo underflow
        uint32_t PixelStreamerYFifoOverflow                        :1          ; //Bits :[3:3], initial value: 0x0. Pixel streamer Y fifo overflow
        uint32_t PixelStreamerMFifoUnderflow                       :1          ; //Bits :[4:4], initial value: 0x0.  Pixel streamer M fifo underflow
        uint32_t PixelStreamerMFifoOverflow                        :1          ; //Bits :[5:5], initial value: 0x0. Pixel streamer M fifo overflow
        uint32_t PixelStreamerBFifoUnderflow                       :1          ; //Bits :[6:6], initial value: 0x0.  Pixel streamer B fifo underflow
        uint32_t PixelStreamerBFifoOverflow                        :1          ; //Bits :[7:7], initial value: 0x0. Pixel streamer B fifo overflow
        uint32_t PixelStreamerAFifoUnderflow                       :1          ; //Bits :[8:8], initial value: 0x0.  Pixel streamer A fifo underflow
        uint32_t PixelStreamerAFifoOverflow                        :1          ; //Bits :[9:9], initial value: 0x0. Pixel streamer A fifo overflow
        uint32_t SyncAlignRightFifoUnderflow                       :1          ; //Bits :[10:10], initial value: 0x0. Sync align right fifo underflow
        uint32_t SyncAlignRightFifoOverflow                        :1          ; //Bits :[11:11], initial value: 0x0. Sync align right fifo overflow
        uint32_t SyncAlignLeftFifoUnderflow                        :1          ; //Bits :[12:12], initial value: 0x0. Sync align left fifo underflow
        uint32_t SyncAlignLeftFifoOverflow                         :1          ; //Bits :[13:13], initial value: 0x0. Sync align left fifo overflow
        uint32_t VyncMasterRisingEdge                              :1          ; //Bits :[14:14], initial value: 0x0. Vsync master rising edge
        uint32_t RecInterruptVector                                :9          ; //Bits :[15:23], initial value: 0x0. Indicates REC interrupt
        uint32_t ItmInterruptVector                                :4          ; //Bits :[24:27], initial value: 0x0. Indicates ITM interrupt
        uint32_t MtrIspUnderflowIntr                               :1          ; //Bits :[28:28], initial value: 0x0. Indicates MTR ISP underflow interrupt
        uint32_t MtrHostUnderflowIntr                              :1          ; //Bits :[29:29], initial value: 0x0. Indicates MTR host underflow interrupt
        uint32_t LaserInterrupt                                    :1          ; //Bits :[30:30], initial value: 0x0. Indicates Laser Interrupt
        uint32_t Reserved                                          :1          ; //Bits :[31:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t PixelStreamerZFifoUnderflow                       :1          ; //Bits :[0:0], initial value: 0x0.  Pixel streamer Z fifo underflow
        uint32_t PixelStreamerZFifoOverflow                        :1          ; //Bits :[1:1], initial value: 0x0. Pixel streamer Z fifo overflow
        uint32_t PixelStreamerYFifoUnderflow                       :1          ; //Bits :[2:2], initial value: 0x0.  Pixel streamer Y fifo underflow
        uint32_t PixelStreamerYFifoOverflow                        :1          ; //Bits :[3:3], initial value: 0x0. Pixel streamer Y fifo overflow
        uint32_t PixelStreamerMFifoUnderflow                       :1          ; //Bits :[4:4], initial value: 0x0.  Pixel streamer M fifo underflow
        uint32_t PixelStreamerMFifoOverflow                        :1          ; //Bits :[5:5], initial value: 0x0. Pixel streamer M fifo overflow
        uint32_t PixelStreamerBFifoUnderflow                       :1          ; //Bits :[6:6], initial value: 0x0.  Pixel streamer B fifo underflow
        uint32_t PixelStreamerBFifoOverflow                        :1          ; //Bits :[7:7], initial value: 0x0. Pixel streamer B fifo overflow
        uint32_t PixelStreamerAFifoUnderflow                       :1          ; //Bits :[8:8], initial value: 0x0.  Pixel streamer A fifo underflow
        uint32_t PixelStreamerAFifoOverflow                        :1          ; //Bits :[9:9], initial value: 0x0. Pixel streamer A fifo overflow
        uint32_t SyncAlignRightFifoUnderflow                       :1          ; //Bits :[10:10], initial value: 0x0. Sync align right fifo underflow
        uint32_t SyncAlignRightFifoOverflow                        :1          ; //Bits :[11:11], initial value: 0x0. Sync align right fifo overflow
        uint32_t SyncAlignLeftFifoUnderflow                        :1          ; //Bits :[12:12], initial value: 0x0. Sync align left fifo underflow
        uint32_t SyncAlignLeftFifoOverflow                         :1          ; //Bits :[13:13], initial value: 0x0. Sync align left fifo overflow
        uint32_t VyncMasterRisingEdge                              :1          ; //Bits :[14:14], initial value: 0x0. Vsync master rising edge
        uint32_t RecInterruptVector                                :9          ; //Bits :[15:23], initial value: 0x0. Indicates REC interrupt
        uint32_t ItmInterruptVector                                :4          ; //Bits :[24:27], initial value: 0x0. Indicates ITM interrupt
        uint32_t MtrIspUnderflowIntr                               :1          ; //Bits :[28:28], initial value: 0x0. Indicates MTR ISP underflow interrupt
        uint32_t MtrHostUnderflowIntr                              :1          ; //Bits :[29:29], initial value: 0x0. Indicates MTR host underflow interrupt
        uint32_t LaserInterrupt                                    :1          ; //Bits :[30:30], initial value: 0x0. Indicates Laser Interrupt
        uint32_t Reserved                                          :1          ; //Bits :[31:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t PixelStreamerZFifoUnderflow                       :1          ; //Bits :[0:0], initial value: 0x0.  Pixel streamer Z fifo underflow
        uint32_t PixelStreamerZFifoOverflow                        :1          ; //Bits :[1:1], initial value: 0x0. Pixel streamer Z fifo overflow
        uint32_t PixelStreamerYFifoUnderflow                       :1          ; //Bits :[2:2], initial value: 0x0.  Pixel streamer Y fifo underflow
        uint32_t PixelStreamerYFifoOverflow                        :1          ; //Bits :[3:3], initial value: 0x0. Pixel streamer Y fifo overflow
        uint32_t PixelStreamerMFifoUnderflow                       :1          ; //Bits :[4:4], initial value: 0x0.  Pixel streamer M fifo underflow
        uint32_t PixelStreamerMFifoOverflow                        :1          ; //Bits :[5:5], initial value: 0x0. Pixel streamer M fifo overflow
        uint32_t PixelStreamerBFifoUnderflow                       :1          ; //Bits :[6:6], initial value: 0x0.  Pixel streamer B fifo underflow
        uint32_t PixelStreamerBFifoOverflow                        :1          ; //Bits :[7:7], initial value: 0x0. Pixel streamer B fifo overflow
        uint32_t PixelStreamerAFifoUnderflow                       :1          ; //Bits :[8:8], initial value: 0x0.  Pixel streamer A fifo underflow
        uint32_t PixelStreamerAFifoOverflow                        :1          ; //Bits :[9:9], initial value: 0x0. Pixel streamer A fifo overflow
        uint32_t SyncAlignRightFifoUnderflow                       :1          ; //Bits :[10:10], initial value: 0x0. Sync align right fifo underflow
        uint32_t SyncAlignRightFifoOverflow                        :1          ; //Bits :[11:11], initial value: 0x0. Sync align right fifo overflow
        uint32_t SyncAlignLeftFifoUnderflow                        :1          ; //Bits :[12:12], initial value: 0x0. Sync align left fifo underflow
        uint32_t SyncAlignLeftFifoOverflow                         :1          ; //Bits :[13:13], initial value: 0x0. Sync align left fifo overflow
        uint32_t VyncMasterRisingEdge                              :1          ; //Bits :[14:14], initial value: 0x0. Vsync master rising edge
        uint32_t RecInterruptVector                                :9          ; //Bits :[15:23], initial value: 0x0. Indicates REC interrupt
        uint32_t ItmInterruptVector                                :4          ; //Bits :[24:27], initial value: 0x0. Indicates ITM interrupt
        uint32_t MtrIspUnderflowIntr                               :1          ; //Bits :[28:28], initial value: 0x0. Indicates MTR ISP underflow interrupt
        uint32_t MtrHostUnderflowIntr                              :1          ; //Bits :[29:29], initial value: 0x0. Indicates MTR host underflow interrupt
        uint32_t LaserInterrupt                                    :1          ; //Bits :[30:30], initial value: 0x0. Indicates Laser Interrupt
        uint32_t Reserved                                          :1          ; //Bits :[31:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptStatus2, TRegCsrInterruptStatus2, *PTRegCsrInterruptStatus2;                                //0x12058

//Enable individual interrupting conditions. Setting a bit to 1 will enable the interrupt assertion.  Setting it
// to 0 will disable the interrupt assertion but has no effect on the Status Register bit.
//initial value: 0x0
typedef union __RegCsrInterruptEnable3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Ep2BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep2FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep2FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep2FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep2FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep2TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep2OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep2_occupancy_unf
        uint32_t Ep22SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep2VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep2UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep2TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep2ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep2ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep2HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep2HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep2ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Ep3BufferWriteIsDisabled                          :1          ; //Bits :[16:16], initial value: 0x0. Buffer write is disabled
        uint32_t Ep3FwHoldActive                                   :1          ; //Bits :[17:17], initial value: 0x0. FW hold active
        uint32_t Ep3FirstTransferDone                              :1          ; //Bits :[18:18], initial value: 0x0. First transfer done
        uint32_t Ep3FlushDone                                      :1          ; //Bits :[19:19], initial value: 0x0. Flush done
        uint32_t Ep3FrameDone                                      :1          ; //Bits :[20:20], initial value: 0x0. Frame done
        uint32_t Ep3TrbFifoPull                                    :1          ; //Bits :[21:21], initial value: 0x0. TRB FIFO pull
        uint32_t Ep3OccupancyUnf                                   :1          ; //Bits :[22:22], initial value: 0x0. ep3_occupancy_unf
        uint32_t Ep32SofErrorNoEof                                 :1          ; //Bits :[23:23], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep3VdfBufferOverflow                              :1          ; //Bits :[24:24], initial value: 0x0. VDF buffer overflow
        uint32_t Ep3UvcFifoOverflow                                :1          ; //Bits :[25:25], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep3TrbFifoOverflow                                :1          ; //Bits :[26:26], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep3ReadEventCountIssued                           :1          ; //Bits :[27:27], initial value: 0x0. Read event count issued
        uint32_t Ep3ClearEventsIssued                              :1          ; //Bits :[28:28], initial value: 0x0. Clear events issued
        uint32_t Ep3HwoBitReset                                    :1          ; //Bits :[29:29], initial value: 0x0. HWO bit reset
        uint32_t Ep3HwoBitSet                                      :1          ; //Bits :[30:30], initial value: 0x0. HWO bit set
        uint32_t Ep3ShadowUpdateDone                               :1          ; //Bits :[31:31], initial value: 0x0. Shadow update done
     } fields_read;
    struct {
        uint32_t Ep2BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep2FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep2FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep2FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep2FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep2TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep2OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep2_occupancy_unf
        uint32_t Ep22SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep2VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep2UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep2TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep2ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep2ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep2HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep2HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep2ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Ep3BufferWriteIsDisabled                          :1          ; //Bits :[16:16], initial value: 0x0. Buffer write is disabled
        uint32_t Ep3FwHoldActive                                   :1          ; //Bits :[17:17], initial value: 0x0. FW hold active
        uint32_t Ep3FirstTransferDone                              :1          ; //Bits :[18:18], initial value: 0x0. First transfer done
        uint32_t Ep3FlushDone                                      :1          ; //Bits :[19:19], initial value: 0x0. Flush done
        uint32_t Ep3FrameDone                                      :1          ; //Bits :[20:20], initial value: 0x0. Frame done
        uint32_t Ep3TrbFifoPull                                    :1          ; //Bits :[21:21], initial value: 0x0. TRB FIFO pull
        uint32_t Ep3OccupancyUnf                                   :1          ; //Bits :[22:22], initial value: 0x0. ep3_occupancy_unf
        uint32_t Ep32SofErrorNoEof                                 :1          ; //Bits :[23:23], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep3VdfBufferOverflow                              :1          ; //Bits :[24:24], initial value: 0x0. VDF buffer overflow
        uint32_t Ep3UvcFifoOverflow                                :1          ; //Bits :[25:25], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep3TrbFifoOverflow                                :1          ; //Bits :[26:26], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep3ReadEventCountIssued                           :1          ; //Bits :[27:27], initial value: 0x0. Read event count issued
        uint32_t Ep3ClearEventsIssued                              :1          ; //Bits :[28:28], initial value: 0x0. Clear events issued
        uint32_t Ep3HwoBitReset                                    :1          ; //Bits :[29:29], initial value: 0x0. HWO bit reset
        uint32_t Ep3HwoBitSet                                      :1          ; //Bits :[30:30], initial value: 0x0. HWO bit set
        uint32_t Ep3ShadowUpdateDone                               :1          ; //Bits :[31:31], initial value: 0x0. Shadow update done
     } fields_write;
    struct {
        uint32_t Ep2BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep2FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep2FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep2FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep2FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep2TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep2OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep2_occupancy_unf
        uint32_t Ep22SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep2VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep2UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep2TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep2ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep2ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep2HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep2HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep2ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Ep3BufferWriteIsDisabled                          :1          ; //Bits :[16:16], initial value: 0x0. Buffer write is disabled
        uint32_t Ep3FwHoldActive                                   :1          ; //Bits :[17:17], initial value: 0x0. FW hold active
        uint32_t Ep3FirstTransferDone                              :1          ; //Bits :[18:18], initial value: 0x0. First transfer done
        uint32_t Ep3FlushDone                                      :1          ; //Bits :[19:19], initial value: 0x0. Flush done
        uint32_t Ep3FrameDone                                      :1          ; //Bits :[20:20], initial value: 0x0. Frame done
        uint32_t Ep3TrbFifoPull                                    :1          ; //Bits :[21:21], initial value: 0x0. TRB FIFO pull
        uint32_t Ep3OccupancyUnf                                   :1          ; //Bits :[22:22], initial value: 0x0. ep3_occupancy_unf
        uint32_t Ep32SofErrorNoEof                                 :1          ; //Bits :[23:23], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep3VdfBufferOverflow                              :1          ; //Bits :[24:24], initial value: 0x0. VDF buffer overflow
        uint32_t Ep3UvcFifoOverflow                                :1          ; //Bits :[25:25], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep3TrbFifoOverflow                                :1          ; //Bits :[26:26], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep3ReadEventCountIssued                           :1          ; //Bits :[27:27], initial value: 0x0. Read event count issued
        uint32_t Ep3ClearEventsIssued                              :1          ; //Bits :[28:28], initial value: 0x0. Clear events issued
        uint32_t Ep3HwoBitReset                                    :1          ; //Bits :[29:29], initial value: 0x0. HWO bit reset
        uint32_t Ep3HwoBitSet                                      :1          ; //Bits :[30:30], initial value: 0x0. HWO bit set
        uint32_t Ep3ShadowUpdateDone                               :1          ; //Bits :[31:31], initial value: 0x0. Shadow update done
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptEnable3, TRegCsrInterruptEnable3, *PTRegCsrInterruptEnable3;                                //0x1205C

//Enable individual interrupting conditions. Setting a bit to 1 will enable the interrupt assertion.  Setting it
// to 0 will disable the interrupt assertion but has no effect on the Status Register bit.
//initial value: 0x0
typedef union __RegCsrInterruptEnable4{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Ep4BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep4FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep4FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep4FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep4FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep4TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep4OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep4_occupancy_unf
        uint32_t Ep42SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep4VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep4UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep4TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep4ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep4ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep4HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep4HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep4ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Reserved1                                         :12         ; //Bits :[16:27], initial value: 0x0. Reserved1
        uint32_t PwmIgnoreTrigger                                  :1          ; //Bits :[28:28], initial value: 0x0. PWM ignore trigger
        uint32_t PwmLaserSafety                                    :1          ; //Bits :[29:29], initial value: 0x0. PWM lazer safety
        uint32_t Reserved2                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved2
     } fields_read;
    struct {
        uint32_t Ep4BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep4FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep4FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep4FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep4FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep4TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep4OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep4_occupancy_unf
        uint32_t Ep42SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep4VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep4UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep4TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep4ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep4ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep4HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep4HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep4ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Reserved1                                         :12         ; //Bits :[16:27], initial value: 0x0. Reserved1
        uint32_t PwmIgnoreTrigger                                  :1          ; //Bits :[28:28], initial value: 0x0. PWM ignore trigger
        uint32_t PwmLaserSafety                                    :1          ; //Bits :[29:29], initial value: 0x0. PWM lazer safety
        uint32_t Reserved2                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved2
     } fields_write;
    struct {
        uint32_t Ep4BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep4FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep4FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep4FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep4FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep4TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep4OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep4_occupancy_unf
        uint32_t Ep42SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep4VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep4UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep4TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep4ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep4ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep4HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep4HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep4ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Reserved1                                         :12         ; //Bits :[16:27], initial value: 0x0. Reserved1
        uint32_t PwmIgnoreTrigger                                  :1          ; //Bits :[28:28], initial value: 0x0. PWM ignore trigger
        uint32_t PwmLaserSafety                                    :1          ; //Bits :[29:29], initial value: 0x0. PWM lazer safety
        uint32_t Reserved2                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved2
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptEnable4, TRegCsrInterruptEnable4, *PTRegCsrInterruptEnable4;                                //0x12064

//Reading this register yields the current status of the interrupt. Writing 1 to a bit in this register will clear
//the corresponding interrupt.
//initial value: 0x0
typedef union __RegCsrInterruptStatus3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Ep2BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep2FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep2FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep2FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep2FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep2TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep2OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep2_occupancy_unf
        uint32_t Ep22SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep2VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep2UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep2TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep2ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep2ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep2HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep2HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep2ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Ep3BufferWriteIsDisabled                          :1          ; //Bits :[16:16], initial value: 0x0. Buffer write is disabled
        uint32_t Ep3FwHoldActive                                   :1          ; //Bits :[17:17], initial value: 0x0. FW hold active
        uint32_t Ep3FirstTransferDone                              :1          ; //Bits :[18:18], initial value: 0x0. First transfer done
        uint32_t Ep3FlushDone                                      :1          ; //Bits :[19:19], initial value: 0x0. Flush done
        uint32_t Ep3FrameDone                                      :1          ; //Bits :[20:20], initial value: 0x0. Frame done
        uint32_t Ep3TrbFifoPull                                    :1          ; //Bits :[21:21], initial value: 0x0. TRB FIFO pull
        uint32_t Ep3OccupancyUnf                                   :1          ; //Bits :[22:22], initial value: 0x0. ep3_occupancy_unf
        uint32_t Ep32SofErrorNoEof                                 :1          ; //Bits :[23:23], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep3VdfBufferOverflow                              :1          ; //Bits :[24:24], initial value: 0x0. VDF buffer overflow
        uint32_t Ep3UvcFifoOverflow                                :1          ; //Bits :[25:25], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep3TrbFifoOverflow                                :1          ; //Bits :[26:26], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep3ReadEventCountIssued                           :1          ; //Bits :[27:27], initial value: 0x0. Read event count issued
        uint32_t Ep3ClearEventsIssued                              :1          ; //Bits :[28:28], initial value: 0x0. Clear events issued
        uint32_t Ep3HwoBitReset                                    :1          ; //Bits :[29:29], initial value: 0x0. HWO bit reset
        uint32_t Ep3HwoBitSet                                      :1          ; //Bits :[30:30], initial value: 0x0. HWO bit set
        uint32_t Ep3ShadowUpdateDone                               :1          ; //Bits :[31:31], initial value: 0x0. Shadow update done
     } fields_read;
    struct {
        uint32_t Ep2BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep2FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep2FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep2FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep2FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep2TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep2OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep2_occupancy_unf
        uint32_t Ep22SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep2VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep2UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep2TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep2ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep2ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep2HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep2HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep2ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Ep3BufferWriteIsDisabled                          :1          ; //Bits :[16:16], initial value: 0x0. Buffer write is disabled
        uint32_t Ep3FwHoldActive                                   :1          ; //Bits :[17:17], initial value: 0x0. FW hold active
        uint32_t Ep3FirstTransferDone                              :1          ; //Bits :[18:18], initial value: 0x0. First transfer done
        uint32_t Ep3FlushDone                                      :1          ; //Bits :[19:19], initial value: 0x0. Flush done
        uint32_t Ep3FrameDone                                      :1          ; //Bits :[20:20], initial value: 0x0. Frame done
        uint32_t Ep3TrbFifoPull                                    :1          ; //Bits :[21:21], initial value: 0x0. TRB FIFO pull
        uint32_t Ep3OccupancyUnf                                   :1          ; //Bits :[22:22], initial value: 0x0. ep3_occupancy_unf
        uint32_t Ep32SofErrorNoEof                                 :1          ; //Bits :[23:23], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep3VdfBufferOverflow                              :1          ; //Bits :[24:24], initial value: 0x0. VDF buffer overflow
        uint32_t Ep3UvcFifoOverflow                                :1          ; //Bits :[25:25], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep3TrbFifoOverflow                                :1          ; //Bits :[26:26], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep3ReadEventCountIssued                           :1          ; //Bits :[27:27], initial value: 0x0. Read event count issued
        uint32_t Ep3ClearEventsIssued                              :1          ; //Bits :[28:28], initial value: 0x0. Clear events issued
        uint32_t Ep3HwoBitReset                                    :1          ; //Bits :[29:29], initial value: 0x0. HWO bit reset
        uint32_t Ep3HwoBitSet                                      :1          ; //Bits :[30:30], initial value: 0x0. HWO bit set
        uint32_t Ep3ShadowUpdateDone                               :1          ; //Bits :[31:31], initial value: 0x0. Shadow update done
     } fields_write;
    struct {
        uint32_t Ep2BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep2FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep2FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep2FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep2FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep2TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep2OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep2_occupancy_unf
        uint32_t Ep22SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep2VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep2UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep2TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep2ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep2ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep2HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep2HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep2ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Ep3BufferWriteIsDisabled                          :1          ; //Bits :[16:16], initial value: 0x0. Buffer write is disabled
        uint32_t Ep3FwHoldActive                                   :1          ; //Bits :[17:17], initial value: 0x0. FW hold active
        uint32_t Ep3FirstTransferDone                              :1          ; //Bits :[18:18], initial value: 0x0. First transfer done
        uint32_t Ep3FlushDone                                      :1          ; //Bits :[19:19], initial value: 0x0. Flush done
        uint32_t Ep3FrameDone                                      :1          ; //Bits :[20:20], initial value: 0x0. Frame done
        uint32_t Ep3TrbFifoPull                                    :1          ; //Bits :[21:21], initial value: 0x0. TRB FIFO pull
        uint32_t Ep3OccupancyUnf                                   :1          ; //Bits :[22:22], initial value: 0x0. ep3_occupancy_unf
        uint32_t Ep32SofErrorNoEof                                 :1          ; //Bits :[23:23], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep3VdfBufferOverflow                              :1          ; //Bits :[24:24], initial value: 0x0. VDF buffer overflow
        uint32_t Ep3UvcFifoOverflow                                :1          ; //Bits :[25:25], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep3TrbFifoOverflow                                :1          ; //Bits :[26:26], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep3ReadEventCountIssued                           :1          ; //Bits :[27:27], initial value: 0x0. Read event count issued
        uint32_t Ep3ClearEventsIssued                              :1          ; //Bits :[28:28], initial value: 0x0. Clear events issued
        uint32_t Ep3HwoBitReset                                    :1          ; //Bits :[29:29], initial value: 0x0. HWO bit reset
        uint32_t Ep3HwoBitSet                                      :1          ; //Bits :[30:30], initial value: 0x0. HWO bit set
        uint32_t Ep3ShadowUpdateDone                               :1          ; //Bits :[31:31], initial value: 0x0. Shadow update done
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptStatus3, TRegCsrInterruptStatus3, *PTRegCsrInterruptStatus3;                                //0x12068

//Reading this register yields the current status of the interrupt. Writing 1 to a bit in this register will clear
//the corresponding interrupt.
//initial value: 0x0
typedef union __RegCsrInterruptStatus4{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Ep4BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep4FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep4FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep4FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep4FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep4TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep4OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep4_occupancy_unf
        uint32_t Ep42SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep4VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep4UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep4TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep4ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep4ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep4HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep4HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep4ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Reserved1                                         :12         ; //Bits :[16:27], initial value: 0x0. Reserved1
        uint32_t PwmIgnoreTrigger                                  :1          ; //Bits :[28:28], initial value: 0x0. PWM ignore trigger
        uint32_t PwmLaserSafety                                    :1          ; //Bits :[29:29], initial value: 0x0. PWM lazer safety
        uint32_t Reserved2                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved2
     } fields_read;
    struct {
        uint32_t Ep4BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep4FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep4FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep4FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep4FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep4TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep4OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep4_occupancy_unf
        uint32_t Ep42SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep4VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep4UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep4TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep4ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep4ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep4HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep4HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep4ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Reserved1                                         :12         ; //Bits :[16:27], initial value: 0x0. Reserved1
        uint32_t PwmIgnoreTrigger                                  :1          ; //Bits :[28:28], initial value: 0x0. PWM ignore trigger
        uint32_t PwmLaserSafety                                    :1          ; //Bits :[29:29], initial value: 0x0. PWM lazer safety
        uint32_t Reserved2                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved2
     } fields_write;
    struct {
        uint32_t Ep4BufferWriteIsDisabled                          :1          ; //Bits :[0:0], initial value: 0x0. Buffer write is disabled
        uint32_t Ep4FwHoldActive                                   :1          ; //Bits :[1:1], initial value: 0x0. FW hold active
        uint32_t Ep4FirstTransferDone                              :1          ; //Bits :[2:2], initial value: 0x0. First transfer done
        uint32_t Ep4FlushDone                                      :1          ; //Bits :[3:3], initial value: 0x0. Flush done
        uint32_t Ep4FrameDone                                      :1          ; //Bits :[4:4], initial value: 0x0. Frame done
        uint32_t Ep4TrbFifoPull                                    :1          ; //Bits :[5:5], initial value: 0x0. TRB FIFO pull
        uint32_t Ep4OccupancyUnf                                   :1          ; //Bits :[6:6], initial value: 0x0. ep4_occupancy_unf
        uint32_t Ep42SofErrorNoEof                                 :1          ; //Bits :[7:7], initial value: 0x0. 2 SOF error (no EOF)
        uint32_t Ep4VdfBufferOverflow                              :1          ; //Bits :[8:8], initial value: 0x0. VDF buffer overflow
        uint32_t Ep4UvcFifoOverflow                                :1          ; //Bits :[9:9], initial value: 0x0. UVC FIFO overflow
        uint32_t Ep4TrbFifoOverflow                                :1          ; //Bits :[10:10], initial value: 0x0. TRB FIFO overflow
        uint32_t Ep4ReadEventCountIssued                           :1          ; //Bits :[11:11], initial value: 0x0. Read event count issued
        uint32_t Ep4ClearEventsIssued                              :1          ; //Bits :[12:12], initial value: 0x0. Clear events issued
        uint32_t Ep4HwoBitReset                                    :1          ; //Bits :[13:13], initial value: 0x0. HWO bit reset
        uint32_t Ep4HwoBitSet                                      :1          ; //Bits :[14:14], initial value: 0x0. HWO bit set
        uint32_t Ep4ShadowUpdateDone                               :1          ; //Bits :[15:15], initial value: 0x0. Shadow update done
        uint32_t Reserved1                                         :12         ; //Bits :[16:27], initial value: 0x0. Reserved1
        uint32_t PwmIgnoreTrigger                                  :1          ; //Bits :[28:28], initial value: 0x0. PWM ignore trigger
        uint32_t PwmLaserSafety                                    :1          ; //Bits :[29:29], initial value: 0x0. PWM lazer safety
        uint32_t Reserved2                                         :2          ; //Bits :[30:31], initial value: 0x0. Reserved2
     } fields_rmw; //for non-shadowed register
} RegCsrInterruptStatus4, TRegCsrInterruptStatus4, *PTRegCsrInterruptStatus4;                                //0x1206C

//This register holds the value of Count 0 of the Watch Dog Timer. When this count expires in the WDT, an interrupt_1
//is sent to the LCP. Every time WDT is kicked, this Count 0 value is refilled into the WDT counter when activated
//by the WDT logic.
//initial value: 0xFFFFFFFF
typedef union __RegCsrWdtCount0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtCount0                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 0.
     } fields_read;
    struct {
        uint32_t WdtCount0                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 0.
     } fields_write;
    struct {
        uint32_t WdtCount0                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 0.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtCount0, TRegCsrWdtCount0, *PTRegCsrWdtCount0;                                //0x12080

//This register holds the value of Count 1 of the Watch Dog Timer. When this count expires in the WDT, an interrupt_2
//is sent to the LCP. Every time WDT is kicked, this Count 1 value is refilled into the WDT counter when activated
//by the WDT logic.
//initial value: 0xFFFFFFFF
typedef union __RegCsrWdtCount1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtCount1                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 1.
     } fields_read;
    struct {
        uint32_t WdtCount1                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 1.
     } fields_write;
    struct {
        uint32_t WdtCount1                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 1.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtCount1, TRegCsrWdtCount1, *PTRegCsrWdtCount1;                                //0x12084

//This register holds the value of Count 2 of the Watch Dog Timer. When this count expires in the WDT, the WDT will
//reset the chip. To avoid the chip getting reset by WDT, software needs to kick the WDT periodically within the
// configured timeframe.
//initial value: 0xFFFFFFFF
typedef union __RegCsrWdtCount2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtCount2                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 2.
     } fields_read;
    struct {
        uint32_t WdtCount2                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 2.
     } fields_write;
    struct {
        uint32_t WdtCount2                                         :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. WDT Count 2.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtCount2, TRegCsrWdtCount2, *PTRegCsrWdtCount2;                                //0x12088

//This register holds the current value of Count 0 of the Watch Dog Timer. Initial Value = 0
//initial value: 0x0
typedef union __RegCsrWdtCurrentCount0{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtCurrentCount0                                  :32         ; //Bits :[0:31], initial value: 0x0. WDT Current Count 0.
     } fields_read;
    struct {
        uint32_t WdtCurrentCount0                                  :32         ; //Bits :[0:31], initial value: 0x0. WDT Current Count 0.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtCurrentCount0, TRegCsrWdtCurrentCount0, *PTRegCsrWdtCurrentCount0;                                //0x12090

//This register holds the current value of Count 1 of the Watch Dog Timer. Initial Value = 0
//initial value: 0x0
typedef union __RegCsrWdtCurrentCount1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtCurrentCount1                                  :32         ; //Bits :[0:31], initial value: 0x0. WDT Current Count 1.
     } fields_read;
    struct {
        uint32_t WdtCurrentCount1                                  :32         ; //Bits :[0:31], initial value: 0x0. WDT Current Count 1.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtCurrentCount1, TRegCsrWdtCurrentCount1, *PTRegCsrWdtCurrentCount1;                                //0x12094

//This register holds the current value of Count 2 of the Watch Dog Timer. Initial Value = 0
//initial value: 0x0
typedef union __RegCsrWdtCurrentCount2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtCurrentCount2                                  :32         ; //Bits :[0:31], initial value: 0x0. WDT Current Count 2.
     } fields_read;
    struct {
        uint32_t WdtCurrentCount2                                  :32         ; //Bits :[0:31], initial value: 0x0. WDT Current Count 2.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtCurrentCount2, TRegCsrWdtCurrentCount2, *PTRegCsrWdtCurrentCount2;                                //0x12098

//This register holds the number of chip resets caused by the Watch Dog Timer that has occured since the last time
//that the WDT was kicked. This value is reset to 0 each time the WDT is kicked. Initial Value = 0
//initial value: 0x0
typedef union __RegCsrWdtStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtStatus                                         :8          ; //Bits :[0:7], initial value: 0x0. WDT Status.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t WdtStatus                                         :8          ; //Bits :[0:7], initial value: 0x0. WDT Status.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtStatus, TRegCsrWdtStatus, *PTRegCsrWdtStatus;                                //0x1209C

//Setting a 1 to bit 0 of this register enables the Watch Dog Timer. This action should be done only after all the
//WDT Counts have been programmed. Writing a 0 to this bit disables WDT; the WDT will get reset but its WDT counts
//do not need to be reprogrammed unless a change is desired.
//initial value: 0x0
typedef union __RegCsrWdtControl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtEnable                                         :1          ; //Bits :[0:0], initial value: 0x0. 1: Enable WDT. 0: Disable WDT.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t WdtEnable                                         :1          ; //Bits :[0:0], initial value: 0x0. 1: Enable WDT. 0: Disable WDT.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t WdtEnable                                         :1          ; //Bits :[0:0], initial value: 0x0. 1: Enable WDT. 0: Disable WDT.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtControl0, TRegCsrWdtControl0, *PTRegCsrWdtControl0;                                //0x120A0

//Writing a 1 to bit 0 of this register generates a one-pclk cycle wide that kicks the Watch Dog Timer. This action
//replenishes all counts of WDT. This register is self-cleared. If WDT is not kicked by SW within the desired period
//configured by WDT Counts it will reset the chip. The number of chip resets is stored in WDT Status register. A
// WDT kick will clear the reset counts.
//initial value: 0x0
typedef union __RegCsrWdtControl1{ //register type:WO shadowed:NO
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WdtKick                                           :1          ; //Bits :[0:0], initial value: 0x0. 1: Kick WDT. This bit is self-cleared.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t WdtKick                                           :1          ; //Bits :[0:0], initial value: 0x0. 1: Kick WDT. This bit is self-cleared.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrWdtControl1, TRegCsrWdtControl1, *PTRegCsrWdtControl1;                                //0x120A4

//Tensilica LCP boot vector selector.
//initial value: 0x0
typedef union __RegCsrBootstatvectorsel{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Statvectorsel                                     :1          ; //Bits :[0:0], initial value: 0x0. Tensilica LCP boot vector selector.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Statvectorsel                                     :1          ; //Bits :[0:0], initial value: 0x0. Tensilica LCP boot vector selector.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Statvectorsel                                     :1          ; //Bits :[0:0], initial value: 0x0. Tensilica LCP boot vector selector.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrBootstatvectorsel, TRegCsrBootstatvectorsel, *PTRegCsrBootstatvectorsel;                                //0x12100

//Tensilica LCP reset source indicator
//initial value: 0x0
typedef union __RegCsrBootrstsource{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Bootrstsrc                                        :3          ; //Bits :[0:2], initial value: 0x0. Tensilica LCP reset source indicator
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Bootrstsrc                                        :3          ; //Bits :[0:2], initial value: 0x0. Tensilica LCP reset source indicator
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrBootrstsource, TRegCsrBootrstsource, *PTRegCsrBootrstsource;                                //0x12104

//System lock bit control
//initial value: 0x0
typedef union __RegCsrBootlock{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Modulelock                                        :8          ; //Bits :[0:7], initial value: 0x0. Module lock bits
        uint32_t Reserved                                          :23         ; //Bits :[8:30], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Masterlock                                        :1          ; //Bits :[31:31], initial value: 0x0. Master lock control
     } fields_read;
    struct {
        uint32_t Modulelock                                        :8          ; //Bits :[0:7], initial value: 0x0. Module lock bits
        uint32_t Reserved                                          :23         ; //Bits :[8:30], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Masterlock                                        :1          ; //Bits :[31:31], initial value: 0x0. Master lock control
     } fields_write;
    struct {
        uint32_t Modulelock                                        :8          ; //Bits :[0:7], initial value: 0x0. Module lock bits
        uint32_t Reserved                                          :23         ; //Bits :[8:30], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Masterlock                                        :1          ; //Bits :[31:31], initial value: 0x0. Master lock control
     } fields_rmw; //for non-shadowed register
} RegCsrBootlock, TRegCsrBootlock, *PTRegCsrBootlock;                                //0x12108

//Boot progress register, 16 bit with CW output
//initial value: 0x0
typedef union __RegCsrBootprogress16{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Bootprogress16                                    :16         ; //Bits :[0:15], initial value: 0x0. Boot Progress status register, written by LCP, available by CW
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Bootprogress16                                    :16         ; //Bits :[0:15], initial value: 0x0. Boot Progress status register, written by LCP, available by CW
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Bootprogress16                                    :16         ; //Bits :[0:15], initial value: 0x0. Boot Progress status register, written by LCP, available by CW
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrBootprogress16, TRegCsrBootprogress16, *PTRegCsrBootprogress16;                                //0x1210C

//Boot progress register, 32 bit
//initial value: 0x0
typedef union __RegCsrBootprogress32{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Bootprogress32                                    :32         ; //Bits :[0:31], initial value: 0x0. Boot Progress status register, written by LCP
     } fields_read;
    struct {
        uint32_t Bootprogress32                                    :32         ; //Bits :[0:31], initial value: 0x0. Boot Progress status register, written by LCP
     } fields_write;
    struct {
        uint32_t Bootprogress32                                    :32         ; //Bits :[0:31], initial value: 0x0. Boot Progress status register, written by LCP
     } fields_rmw; //for non-shadowed register
} RegCsrBootprogress32, TRegCsrBootprogress32, *PTRegCsrBootprogress32;                                //0x12120

//LCP and HW reset control
//initial value: 0x0
typedef union __RegCsrBootrstcmd{ //register type:WO shadowed:NO
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Rstproc                                           :1          ; //Bits :[0:0], initial value: 0x0. reset Tensilica LCP, self clearing
        uint32_t Rstmost                                           :1          ; //Bits :[1:1], initial value: 0x0. reset Tensilica LCP and most H/W, self clearing
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Rstproc                                           :1          ; //Bits :[0:0], initial value: 0x0. reset Tensilica LCP, self clearing
        uint32_t Rstmost                                           :1          ; //Bits :[1:1], initial value: 0x0. reset Tensilica LCP and most H/W, self clearing
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrBootrstcmd, TRegCsrBootrstcmd, *PTRegCsrBootrstcmd;                                //0x12110

//Boot reset status
//initial value: 0x0
typedef union __RegCsrBootrststatus{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Bootstatus                                        :32         ; //Bits :[0:31], initial value: 0x0. Boot Status register, LCP boot usage only
     } fields_read;
    struct {
        uint32_t Bootstatus                                        :32         ; //Bits :[0:31], initial value: 0x0. Boot Status register, LCP boot usage only
     } fields_write;
    struct {
        uint32_t Bootstatus                                        :32         ; //Bits :[0:31], initial value: 0x0. Boot Status register, LCP boot usage only
     } fields_rmw; //for non-shadowed register
} RegCsrBootrststatus, TRegCsrBootrststatus, *PTRegCsrBootrststatus;                                //0x12114

//Boot configuration register
//initial value: 0x0
typedef union __RegCsrBootcfg{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Bootcfg                                           :8          ; //Bits :[0:7], initial value: 0x0. Boot Config option register
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Bootcfg                                           :8          ; //Bits :[0:7], initial value: 0x0. Boot Config option register
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Bootcfg                                           :8          ; //Bits :[0:7], initial value: 0x0. Boot Config option register
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrBootcfg, TRegCsrBootcfg, *PTRegCsrBootcfg;                                //0x12118

//unlock SPI flash memory
//initial value: 0x0
typedef union __RegCsrRegflashunlock{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Flashunlock                                       :1          ; //Bits :[0:0], initial value: 0x0. unlock SPI flash memory. writable only id safety strap is not set
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Flashunlock                                       :1          ; //Bits :[0:0], initial value: 0x0. unlock SPI flash memory. writable only id safety strap is not set
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Flashunlock                                       :1          ; //Bits :[0:0], initial value: 0x0. unlock SPI flash memory. writable only id safety strap is not set
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrRegflashunlock, TRegCsrRegflashunlock, *PTRegCsrRegflashunlock;                                //0x1211C

//S/W scratch register, power-on_reset clear only
//initial value: 0x0
typedef union __RegCsrSwsparescratch{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Swsparescratch                                    :32         ; //Bits :[0:31], initial value: 0x0. power-on_reset clear only
     } fields_read;
    struct {
        uint32_t Swsparescratch                                    :32         ; //Bits :[0:31], initial value: 0x0. power-on_reset clear only
     } fields_write;
    struct {
        uint32_t Swsparescratch                                    :32         ; //Bits :[0:31], initial value: 0x0. power-on_reset clear only
     } fields_rmw; //for non-shadowed register
} RegCsrSwsparescratch, TRegCsrSwsparescratch, *PTRegCsrSwsparescratch;                                //0x12124

//Chip Watch Control 0. This register selects the signals from LCP (lcsp_cw0, lcp_cw1), ldi_cw, trpoc_cw0, tproc_cw1,
//ts_cw, cam_cw1 to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Lcp0Sel                                           :4          ; //Bits :[0:3], initial value: 0x0. LCP CW0 selectors.
        uint32_t Lcp1Sel                                           :4          ; //Bits :[4:7], initial value: 0x0. LCP CW1 selectors.
        uint32_t LdiSel                                            :4          ; //Bits :[8:11], initial value: 0x0. LDI CW selectors.
        uint32_t Tproc0Sel                                         :4          ; //Bits :[12:15], initial value: 0x0. TPROC_CW0 selectors.
        uint32_t Tproc1Sel                                         :4          ; //Bits :[16:19], initial value: 0x0. TPROC_CW1 selectors.
        uint32_t TsSel                                             :4          ; //Bits :[20:23], initial value: 0x0. TEMP SENSE CW selectors.
        uint32_t Cam1Sel                                           :4          ; //Bits :[24:27], initial value: 0x0. CAM CW1 selectors.
        uint32_t ReservedControl0                                  :4          ; //Bits :[28:31], initial value: 0x0. Read and write works though unused for now, keeping it for future use, just in case i need more bit then i don't have to go through CCB.
     } fields_read;
    struct {
        uint32_t Lcp0Sel                                           :4          ; //Bits :[0:3], initial value: 0x0. LCP CW0 selectors.
        uint32_t Lcp1Sel                                           :4          ; //Bits :[4:7], initial value: 0x0. LCP CW1 selectors.
        uint32_t LdiSel                                            :4          ; //Bits :[8:11], initial value: 0x0. LDI CW selectors.
        uint32_t Tproc0Sel                                         :4          ; //Bits :[12:15], initial value: 0x0. TPROC_CW0 selectors.
        uint32_t Tproc1Sel                                         :4          ; //Bits :[16:19], initial value: 0x0. TPROC_CW1 selectors.
        uint32_t TsSel                                             :4          ; //Bits :[20:23], initial value: 0x0. TEMP SENSE CW selectors.
        uint32_t Cam1Sel                                           :4          ; //Bits :[24:27], initial value: 0x0. CAM CW1 selectors.
        uint32_t ReservedControl0                                  :4          ; //Bits :[28:31], initial value: 0x0. Read and write works though unused for now, keeping it for future use, just in case i need more bit then i don't have to go through CCB.
     } fields_write;
    struct {
        uint32_t Lcp0Sel                                           :4          ; //Bits :[0:3], initial value: 0x0. LCP CW0 selectors.
        uint32_t Lcp1Sel                                           :4          ; //Bits :[4:7], initial value: 0x0. LCP CW1 selectors.
        uint32_t LdiSel                                            :4          ; //Bits :[8:11], initial value: 0x0. LDI CW selectors.
        uint32_t Tproc0Sel                                         :4          ; //Bits :[12:15], initial value: 0x0. TPROC_CW0 selectors.
        uint32_t Tproc1Sel                                         :4          ; //Bits :[16:19], initial value: 0x0. TPROC_CW1 selectors.
        uint32_t TsSel                                             :4          ; //Bits :[20:23], initial value: 0x0. TEMP SENSE CW selectors.
        uint32_t Cam1Sel                                           :4          ; //Bits :[24:27], initial value: 0x0. CAM CW1 selectors.
        uint32_t ReservedControl0                                  :4          ; //Bits :[28:31], initial value: 0x0. Read and write works though unused for now, keeping it for future use, just in case i need more bit then i don't have to go through CCB.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl0, TRegCsrCwControl0, *PTRegCsrCwControl0;                                //0x12200

//Chip Watch Control 1. This register selects the signals from CAM to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl1                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl1                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl1                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl1, TRegCsrCwControl1, *PTRegCsrCwControl1;                                //0x12204

//Chip Watch Control 2. This register selects the signals from VDF to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl2                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl2                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl2                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl2, TRegCsrCwControl2, *PTRegCsrCwControl2;                                //0x12208

//Chip Watch Control 3. This register selects the signals from REC to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl3                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl3                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl3                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl3, TRegCsrCwControl3, *PTRegCsrCwControl3;                                //0x1220C

//Chip Watch Control 4. This register selects the signals from SCP to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl4{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl4                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl4                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl4                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl4, TRegCsrCwControl4, *PTRegCsrCwControl4;                                //0x12210

//Chip Watch Control 5. This register selects the signals from CSR to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl5{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl5                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl5                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl5                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl5, TRegCsrCwControl5, *PTRegCsrCwControl5;                                //0x12214

//Chip Watch Control 6. This register selects the signals from CRCTL to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl6{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl6                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl6                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl6                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl6, TRegCsrCwControl6, *PTRegCsrCwControl6;                                //0x12218

//Chip Watch Control 7. This register selects the signals from MISC to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl7{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl7                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl7                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl7                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl7, TRegCsrCwControl7, *PTRegCsrCwControl7;                                //0x1221C

//Chip Watch Control 8. This register selects the signals from WDT to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl8{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl8                                        :20         ; //Bits :[0:19], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl8                                        :20         ; //Bits :[0:19], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl8                                        :20         ; //Bits :[0:19], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl8, TRegCsrCwControl8, *PTRegCsrCwControl8;                                //0x12220

//Chip Watch Control 9. This register selects the signals from PERIPHERALS to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl9{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl9                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl9                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl9                                        :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl9, TRegCsrCwControl9, *PTRegCsrCwControl9;                                //0x12224

//Chip Watch Control 10. This register selects the signals from USB to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl10{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl10                                       :20         ; //Bits :[0:19], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl10                                       :20         ; //Bits :[0:19], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl10                                       :20         ; //Bits :[0:19], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl10, TRegCsrCwControl10, *PTRegCsrCwControl10;                                //0x12228

//Chip Watch Control 11. This register selects the signals from MISC2 to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl11{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl11                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl11                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl11                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl11, TRegCsrCwControl11, *PTRegCsrCwControl11;                                //0x1222C

//Chip Watch Control 12. This register selects the signals from PRI2 to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl12{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl12                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl12                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl12                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl12, TRegCsrCwControl12, *PTRegCsrCwControl12;                                //0x12230

//Chip Watch Control 13. This register selects the signals from MISC3 to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl13{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl13                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl13                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl13                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl13, TRegCsrCwControl13, *PTRegCsrCwControl13;                                //0x12234

//Chip Watch Control 14. This register selects the signals from MISC4 to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl14{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl14                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl14                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl14                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl14, TRegCsrCwControl14, *PTRegCsrCwControl14;                                //0x12238

//Chip Watch Control 15. This register selects the signals from MISC5 to be observed on the Chip Watch port.
//initial value: 0xF
typedef union __RegCsrCwControl15{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl15                                       :4          ; //Bits :[0:3], initial value: 0xF. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl15                                       :4          ; //Bits :[0:3], initial value: 0xF. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl15                                       :4          ; //Bits :[0:3], initial value: 0xF. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl15, TRegCsrCwControl15, *PTRegCsrCwControl15;                                //0x1223C

//Chip Watch Control 16. This register selects the signals from MISC6 to be observed on the Chip Watch port.
//initial value: 0xF
typedef union __RegCsrCwControl16{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl16                                       :4          ; //Bits :[0:3], initial value: 0xF. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl16                                       :4          ; //Bits :[0:3], initial value: 0xF. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl16                                       :4          ; //Bits :[0:3], initial value: 0xF. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl16, TRegCsrCwControl16, *PTRegCsrCwControl16;                                //0x12240

//Chip Watch Control 17. This register selects the signals from mtr isp to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl17{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl17                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl17                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl17                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl17, TRegCsrCwControl17, *PTRegCsrCwControl17;                                //0x12244

//Chip Watch Control 18. This register selects the signals from mtr host to be observed on the Chip Watch port.
//initial value: 0x0
typedef union __RegCsrCwControl18{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CwControl18                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CwControl18                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CwControl18                                       :4          ; //Bits :[0:3], initial value: 0x0. CW selectors.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCwControl18, TRegCsrCwControl18, *PTRegCsrCwControl18;                                //0x12248

//This is the 32-bit general purpose register 0 for all uses within the chip.
//initial value: 0x0
typedef union __RegCsrGpr0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t KeepXcOn                                          :1          ; //Bits :[0:0], initial value: 0x0. Keep Crystal Oscillator ON.  This bit can be used to turn on USB quickly (SCENARIO_2) while PMU thinks crystal is Off. Procedure is 1) Program this bit=1 2) Program a low value (=1) in to ON_TIME (in PMU) 3) Disable auto powerup (wake based powerup) in PMU 4) Go through power-dn sequence in PMU with rxelecidle set as wake event and crystal Off (ie SCENARIO_1) 5) Chip wakes up quickly on rxelecidle 6) Program ON_TIME to desired value for power switch 6) Powerup PMU
        uint32_t Gpr0                                              :31         ; //Bits :[1:31], initial value: 0x0. GPR 0
     } fields_read;
    struct {
        uint32_t KeepXcOn                                          :1          ; //Bits :[0:0], initial value: 0x0. Keep Crystal Oscillator ON.  This bit can be used to turn on USB quickly (SCENARIO_2) while PMU thinks crystal is Off. Procedure is 1) Program this bit=1 2) Program a low value (=1) in to ON_TIME (in PMU) 3) Disable auto powerup (wake based powerup) in PMU 4) Go through power-dn sequence in PMU with rxelecidle set as wake event and crystal Off (ie SCENARIO_1) 5) Chip wakes up quickly on rxelecidle 6) Program ON_TIME to desired value for power switch 6) Powerup PMU
        uint32_t Gpr0                                              :31         ; //Bits :[1:31], initial value: 0x0. GPR 0
     } fields_write;
    struct {
        uint32_t KeepXcOn                                          :1          ; //Bits :[0:0], initial value: 0x0. Keep Crystal Oscillator ON.  This bit can be used to turn on USB quickly (SCENARIO_2) while PMU thinks crystal is Off. Procedure is 1) Program this bit=1 2) Program a low value (=1) in to ON_TIME (in PMU) 3) Disable auto powerup (wake based powerup) in PMU 4) Go through power-dn sequence in PMU with rxelecidle set as wake event and crystal Off (ie SCENARIO_1) 5) Chip wakes up quickly on rxelecidle 6) Program ON_TIME to desired value for power switch 6) Powerup PMU
        uint32_t Gpr0                                              :31         ; //Bits :[1:31], initial value: 0x0. GPR 0
     } fields_rmw; //for non-shadowed register
} RegCsrGpr0, TRegCsrGpr0, *PTRegCsrGpr0;                                //0x12260

//This is the 32-bit general purpose register 1 for all uses within the chip.
//initial value: 0x0
typedef union __RegCsrGpr1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Gpr1                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 1
     } fields_read;
    struct {
        uint32_t Gpr1                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 1
     } fields_write;
    struct {
        uint32_t Gpr1                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 1
     } fields_rmw; //for non-shadowed register
} RegCsrGpr1, TRegCsrGpr1, *PTRegCsrGpr1;                                //0x12264

//This is the 32-bit general purpose register 2 for all uses within the chip.
//initial value: 0x0
typedef union __RegCsrGpr2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Gpr2                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 2
     } fields_read;
    struct {
        uint32_t Gpr2                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 2
     } fields_write;
    struct {
        uint32_t Gpr2                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 2
     } fields_rmw; //for non-shadowed register
} RegCsrGpr2, TRegCsrGpr2, *PTRegCsrGpr2;                                //0x12268

//This is the 32-bit general purpose register 3 for all uses within the chip.
//initial value: 0x0
typedef union __RegCsrGpr3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Gpr3                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 3
     } fields_read;
    struct {
        uint32_t Gpr3                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 3
     } fields_write;
    struct {
        uint32_t Gpr3                                              :32         ; //Bits :[0:31], initial value: 0x0. GPR 3
     } fields_rmw; //for non-shadowed register
} RegCsrGpr3, TRegCsrGpr3, *PTRegCsrGpr3;                                //0x1226C

//Power Management Unit (PMU)  Control 0.
//initial value: 0
typedef union __RegCsrPmuControl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UsbM0                                             :2          ; //Bits :[0:1], initial value: 0x0. usb_m0[1:0]: 2'b00 - USB memory 0 is not in PD mode. 2'b01 - USB memory 0 is in LS, 2'b10: USB memory 0 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t UsbM1                                             :2          ; //Bits :[2:3], initial value: 0x0. usb_m1[1:0]: 2'b00 - USB memory 1 is not in PD mode. 2'b01 - USB memory 1 is in LS, 2'b10: USB memory 1 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t UsbM2                                             :2          ; //Bits :[4:5], initial value: 0x0. usb_m2[1:0]: 2'b00 - USB memory 2 is not in PD mode. 2'b01 - USB memory 2 is in LS, 2'b10: USB memory 2 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t RecM                                              :2          ; //Bits :[6:7], initial value: 0x0. rec_m[1:0]: 2'b00 - REC memories  are not in PD mode. 2'b01 - REC memories are in LS, 2'b10: REC memories are in DS, 2'b11: REC memories are in SD
        uint32_t ScpM                                              :2          ; //Bits :[8:9], initial value: 0x0. scp_m[1:0]: 2'b00 - SCP memories  are not in PD mode. 2'b01 - SCP memories are in LS, 2'b10: SCP memories are in DS, 2'b11: SCP memories are in SD
        uint32_t VdfM0                                             :2          ; //Bits :[10:11], initial value: 0x0. vdf_m0[1:0]: 2'b00 - VDF memory 0 is not in PD mode. 2'b01 - VDF memory 0 is in LS, 2'b10: VDF memory 0 is in DS, 2'b11: VDF memory 0 is in SD
        uint32_t VdfM1                                             :2          ; //Bits :[12:13], initial value: 0x0. vdf_m1[1:0]: 2'b00 - VDF memory 1 is not in PD mode. 2'b01 - VDF memory 1 is in LS, 2'b10: VDF memory 1 is in DS, 2'b11: VDF memory 1 is in SD
        uint32_t VdfM2                                             :2          ; //Bits :[14:15], initial value: 0x0. vdf_m2[1:0]: 2'b00 - VDF memory 2 is not in PD mode. 2'b01 - VDF memory 2 is in LS, 2'b10: VDF memory 2 is in DS, 2'b11: VDF memory 2 is in SD
        uint32_t CamM0                                             :2          ; //Bits :[16:17], initial value: 0x0. cam_m0[1:0]: 2'b00 - CAM memory 0 is not in PD mode. 2'b01 - CAM memory 0 is in LS, 2'b10: CAM memory 0 is in DS, 2'b11: CAM memory 0 is in SD
        uint32_t CamM1                                             :2          ; //Bits :[18:19], initial value: 0x0. cam_m1[1:0]: 2'b00 - CAM memory 1 is not in PD mode. 2'b01 - CAM memory 1 is in LS, 2'b10: CAM memory 1 is in DS, 2'b11: CAM memory 1 is in SD
        uint32_t CmpM0                                             :2          ; //Bits :[20:21], initial value: 0x0. cmp_m0[1:0]: 2'b00 - CMP memory 0 is not in PD mode. 2'b01 - CMP memory 0 is in LS, 2'b10: CMP memory 0 is in DS, 2'b11: CMP memory 0 is in SD
        uint32_t CmpM1                                             :2          ; //Bits :[22:23], initial value: 0x0. cmp_m1[1:0]: 2'b00 - CMP memory 1 is not in PD mode. 2'b01 - CMP memory 1 is in LS, 2'b10: CMP memory 1 is in DS, 2'b11: CMP memory 1 is in SD
        uint32_t ItmM                                              :2          ; //Bits :[24:25], initial value: 0x0. itm_m[1:0]: 2'b00 - ITM memory 1 is not in PD mode. 2'b01 - ITM memory 1 is in LS, 2'b10: ITM memory 1 is in DS, 2'b11: ITM memory 1 is in SD
        uint32_t PmuStmDisable                                     :1          ; //Bits :[26:26], initial value: 0x0. pmu_stm_disable[1:0]: 2'b00 - pmu_stm_disable: 1'b0 - Disable PMU to go in PD mode, 1'b1: PMU can go in PD mode if required by LCP
        uint32_t EnLcpMemPdMode                                    :1          ; //Bits :[27:27], initial value: 0x0. en_lcp_mem_PD_mode: 1'b0 disables lcp memories to go in PD mode. Writing 1'b1 allows PMU to PD lcp memories in PD mode of DS5
        uint32_t EnLcpClkGate                                      :1          ; //Bits :[28:28], initial value: 0x0. en_lcp_clk_gate: 1'b0 disables clock gating of sclk in DS5. Writing 1'b1 allows clock gating of DS5
        uint32_t LcpForcesPmuInU3                                  :1          ; //Bits :[29:29], initial value: 0x0. 1'b0 disables the state machine switching from U0 to U3. Writing 1'b1 forces PMU in U3 state. This bit is also used in the event MIPI is the connection used instead of USB3 and I2C is interface with HOST application, here DS5 is I2C Slave.
        uint32_t LcpWakesUpPmu                                     :1          ; //Bits :[30:30], initial value: 0x0. Writing 1'b1 indicates LCP or I2C master (HOST) wants to wake up DS5.
        uint32_t KeepUsbBusclk                                     :1          ; //Bits :[31:31], initial value: 0x0. Controls the busclk to USB Controller. 0: USB busclk is same as VDF clk (which is sclk, gated version) 1: USB busclk is independent of VDF clk (ungated sclk). Note: 'gate' here only refers to VDF-USB relationship.  This is independent of Clock gating when USB is unused
     } fields_read;
    struct {
        uint32_t UsbM0                                             :2          ; //Bits :[0:1], initial value: 0x0. usb_m0[1:0]: 2'b00 - USB memory 0 is not in PD mode. 2'b01 - USB memory 0 is in LS, 2'b10: USB memory 0 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t UsbM1                                             :2          ; //Bits :[2:3], initial value: 0x0. usb_m1[1:0]: 2'b00 - USB memory 1 is not in PD mode. 2'b01 - USB memory 1 is in LS, 2'b10: USB memory 1 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t UsbM2                                             :2          ; //Bits :[4:5], initial value: 0x0. usb_m2[1:0]: 2'b00 - USB memory 2 is not in PD mode. 2'b01 - USB memory 2 is in LS, 2'b10: USB memory 2 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t RecM                                              :2          ; //Bits :[6:7], initial value: 0x0. rec_m[1:0]: 2'b00 - REC memories  are not in PD mode. 2'b01 - REC memories are in LS, 2'b10: REC memories are in DS, 2'b11: REC memories are in SD
        uint32_t ScpM                                              :2          ; //Bits :[8:9], initial value: 0x0. scp_m[1:0]: 2'b00 - SCP memories  are not in PD mode. 2'b01 - SCP memories are in LS, 2'b10: SCP memories are in DS, 2'b11: SCP memories are in SD
        uint32_t VdfM0                                             :2          ; //Bits :[10:11], initial value: 0x0. vdf_m0[1:0]: 2'b00 - VDF memory 0 is not in PD mode. 2'b01 - VDF memory 0 is in LS, 2'b10: VDF memory 0 is in DS, 2'b11: VDF memory 0 is in SD
        uint32_t VdfM1                                             :2          ; //Bits :[12:13], initial value: 0x0. vdf_m1[1:0]: 2'b00 - VDF memory 1 is not in PD mode. 2'b01 - VDF memory 1 is in LS, 2'b10: VDF memory 1 is in DS, 2'b11: VDF memory 1 is in SD
        uint32_t VdfM2                                             :2          ; //Bits :[14:15], initial value: 0x0. vdf_m2[1:0]: 2'b00 - VDF memory 2 is not in PD mode. 2'b01 - VDF memory 2 is in LS, 2'b10: VDF memory 2 is in DS, 2'b11: VDF memory 2 is in SD
        uint32_t CamM0                                             :2          ; //Bits :[16:17], initial value: 0x0. cam_m0[1:0]: 2'b00 - CAM memory 0 is not in PD mode. 2'b01 - CAM memory 0 is in LS, 2'b10: CAM memory 0 is in DS, 2'b11: CAM memory 0 is in SD
        uint32_t CamM1                                             :2          ; //Bits :[18:19], initial value: 0x0. cam_m1[1:0]: 2'b00 - CAM memory 1 is not in PD mode. 2'b01 - CAM memory 1 is in LS, 2'b10: CAM memory 1 is in DS, 2'b11: CAM memory 1 is in SD
        uint32_t CmpM0                                             :2          ; //Bits :[20:21], initial value: 0x0. cmp_m0[1:0]: 2'b00 - CMP memory 0 is not in PD mode. 2'b01 - CMP memory 0 is in LS, 2'b10: CMP memory 0 is in DS, 2'b11: CMP memory 0 is in SD
        uint32_t CmpM1                                             :2          ; //Bits :[22:23], initial value: 0x0. cmp_m1[1:0]: 2'b00 - CMP memory 1 is not in PD mode. 2'b01 - CMP memory 1 is in LS, 2'b10: CMP memory 1 is in DS, 2'b11: CMP memory 1 is in SD
        uint32_t ItmM                                              :2          ; //Bits :[24:25], initial value: 0x0. itm_m[1:0]: 2'b00 - ITM memory 1 is not in PD mode. 2'b01 - ITM memory 1 is in LS, 2'b10: ITM memory 1 is in DS, 2'b11: ITM memory 1 is in SD
        uint32_t PmuStmDisable                                     :1          ; //Bits :[26:26], initial value: 0x0. pmu_stm_disable[1:0]: 2'b00 - pmu_stm_disable: 1'b0 - Disable PMU to go in PD mode, 1'b1: PMU can go in PD mode if required by LCP
        uint32_t EnLcpMemPdMode                                    :1          ; //Bits :[27:27], initial value: 0x0. en_lcp_mem_PD_mode: 1'b0 disables lcp memories to go in PD mode. Writing 1'b1 allows PMU to PD lcp memories in PD mode of DS5
        uint32_t EnLcpClkGate                                      :1          ; //Bits :[28:28], initial value: 0x0. en_lcp_clk_gate: 1'b0 disables clock gating of sclk in DS5. Writing 1'b1 allows clock gating of DS5
        uint32_t LcpForcesPmuInU3                                  :1          ; //Bits :[29:29], initial value: 0x0. 1'b0 disables the state machine switching from U0 to U3. Writing 1'b1 forces PMU in U3 state. This bit is also used in the event MIPI is the connection used instead of USB3 and I2C is interface with HOST application, here DS5 is I2C Slave.
        uint32_t LcpWakesUpPmu                                     :1          ; //Bits :[30:30], initial value: 0x0. Writing 1'b1 indicates LCP or I2C master (HOST) wants to wake up DS5.
        uint32_t KeepUsbBusclk                                     :1          ; //Bits :[31:31], initial value: 0x0. Controls the busclk to USB Controller. 0: USB busclk is same as VDF clk (which is sclk, gated version) 1: USB busclk is independent of VDF clk (ungated sclk). Note: 'gate' here only refers to VDF-USB relationship.  This is independent of Clock gating when USB is unused
     } fields_write;
    struct {
        uint32_t UsbM0                                             :2          ; //Bits :[0:1], initial value: 0x0. usb_m0[1:0]: 2'b00 - USB memory 0 is not in PD mode. 2'b01 - USB memory 0 is in LS, 2'b10: USB memory 0 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t UsbM1                                             :2          ; //Bits :[2:3], initial value: 0x0. usb_m1[1:0]: 2'b00 - USB memory 1 is not in PD mode. 2'b01 - USB memory 1 is in LS, 2'b10: USB memory 1 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t UsbM2                                             :2          ; //Bits :[4:5], initial value: 0x0. usb_m2[1:0]: 2'b00 - USB memory 2 is not in PD mode. 2'b01 - USB memory 2 is in LS, 2'b10: USB memory 2 is in DS, 2'b11: USB memory 0 is in SD
        uint32_t RecM                                              :2          ; //Bits :[6:7], initial value: 0x0. rec_m[1:0]: 2'b00 - REC memories  are not in PD mode. 2'b01 - REC memories are in LS, 2'b10: REC memories are in DS, 2'b11: REC memories are in SD
        uint32_t ScpM                                              :2          ; //Bits :[8:9], initial value: 0x0. scp_m[1:0]: 2'b00 - SCP memories  are not in PD mode. 2'b01 - SCP memories are in LS, 2'b10: SCP memories are in DS, 2'b11: SCP memories are in SD
        uint32_t VdfM0                                             :2          ; //Bits :[10:11], initial value: 0x0. vdf_m0[1:0]: 2'b00 - VDF memory 0 is not in PD mode. 2'b01 - VDF memory 0 is in LS, 2'b10: VDF memory 0 is in DS, 2'b11: VDF memory 0 is in SD
        uint32_t VdfM1                                             :2          ; //Bits :[12:13], initial value: 0x0. vdf_m1[1:0]: 2'b00 - VDF memory 1 is not in PD mode. 2'b01 - VDF memory 1 is in LS, 2'b10: VDF memory 1 is in DS, 2'b11: VDF memory 1 is in SD
        uint32_t VdfM2                                             :2          ; //Bits :[14:15], initial value: 0x0. vdf_m2[1:0]: 2'b00 - VDF memory 2 is not in PD mode. 2'b01 - VDF memory 2 is in LS, 2'b10: VDF memory 2 is in DS, 2'b11: VDF memory 2 is in SD
        uint32_t CamM0                                             :2          ; //Bits :[16:17], initial value: 0x0. cam_m0[1:0]: 2'b00 - CAM memory 0 is not in PD mode. 2'b01 - CAM memory 0 is in LS, 2'b10: CAM memory 0 is in DS, 2'b11: CAM memory 0 is in SD
        uint32_t CamM1                                             :2          ; //Bits :[18:19], initial value: 0x0. cam_m1[1:0]: 2'b00 - CAM memory 1 is not in PD mode. 2'b01 - CAM memory 1 is in LS, 2'b10: CAM memory 1 is in DS, 2'b11: CAM memory 1 is in SD
        uint32_t CmpM0                                             :2          ; //Bits :[20:21], initial value: 0x0. cmp_m0[1:0]: 2'b00 - CMP memory 0 is not in PD mode. 2'b01 - CMP memory 0 is in LS, 2'b10: CMP memory 0 is in DS, 2'b11: CMP memory 0 is in SD
        uint32_t CmpM1                                             :2          ; //Bits :[22:23], initial value: 0x0. cmp_m1[1:0]: 2'b00 - CMP memory 1 is not in PD mode. 2'b01 - CMP memory 1 is in LS, 2'b10: CMP memory 1 is in DS, 2'b11: CMP memory 1 is in SD
        uint32_t ItmM                                              :2          ; //Bits :[24:25], initial value: 0x0. itm_m[1:0]: 2'b00 - ITM memory 1 is not in PD mode. 2'b01 - ITM memory 1 is in LS, 2'b10: ITM memory 1 is in DS, 2'b11: ITM memory 1 is in SD
        uint32_t PmuStmDisable                                     :1          ; //Bits :[26:26], initial value: 0x0. pmu_stm_disable[1:0]: 2'b00 - pmu_stm_disable: 1'b0 - Disable PMU to go in PD mode, 1'b1: PMU can go in PD mode if required by LCP
        uint32_t EnLcpMemPdMode                                    :1          ; //Bits :[27:27], initial value: 0x0. en_lcp_mem_PD_mode: 1'b0 disables lcp memories to go in PD mode. Writing 1'b1 allows PMU to PD lcp memories in PD mode of DS5
        uint32_t EnLcpClkGate                                      :1          ; //Bits :[28:28], initial value: 0x0. en_lcp_clk_gate: 1'b0 disables clock gating of sclk in DS5. Writing 1'b1 allows clock gating of DS5
        uint32_t LcpForcesPmuInU3                                  :1          ; //Bits :[29:29], initial value: 0x0. 1'b0 disables the state machine switching from U0 to U3. Writing 1'b1 forces PMU in U3 state. This bit is also used in the event MIPI is the connection used instead of USB3 and I2C is interface with HOST application, here DS5 is I2C Slave.
        uint32_t LcpWakesUpPmu                                     :1          ; //Bits :[30:30], initial value: 0x0. Writing 1'b1 indicates LCP or I2C master (HOST) wants to wake up DS5.
        uint32_t KeepUsbBusclk                                     :1          ; //Bits :[31:31], initial value: 0x0. Controls the busclk to USB Controller. 0: USB busclk is same as VDF clk (which is sclk, gated version) 1: USB busclk is independent of VDF clk (ungated sclk). Note: 'gate' here only refers to VDF-USB relationship.  This is independent of Clock gating when USB is unused
     } fields_rmw; //for non-shadowed register
} RegCsrPmuControl0, TRegCsrPmuControl0, *PTRegCsrPmuControl0;                                //0x12500

//Power Management Unit (PMU)  Control 1.
//initial value: 0
typedef union __RegCsrPmuControl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t XcOverride                                        :1          ; //Bits :[0:0], initial value: 0x0. Override power management of crystal oscillator. 1'b0 : Disabled, oscillator is always ON. Also, bypass internal crystal-less low frequency oscillator and derive low frequency from this oscillator. Use XC clock for i2c special message decode. 1'b1 : Enabled, oscillator is allowed to be shutoff. When shutoff, 1MHz is suppled using ring oscillator.  Derive low frequncy clock from ring oscillator. Use ring_osc for I2C decode
        uint32_t HspPwrdn                                          :1          ; //Bits :[1:1], initial value: 0x0. Engage pwrdn feature of HS Phy. 1'b0 : Disabled, USB2 HS Phy is in use. 1'b1 : Enabled, Force USB-HSP power down by asserting test_powerdown_hsp
        uint32_t SspPwrdn                                          :1          ; //Bits :[2:2], initial value: 0x0. Engage pwrdn feature of USB-SS PHy. 1'b0 : Disabled, USB3 SS Phy is in use. 1'b1 : Enabled, Force USB-SSP powerdown by asserting test_powerdown_ssp
        uint32_t UsbPwrdn                                          :1          ; //Bits :[3:3], initial value: 0x0. Engange complete clock gating of USBcontroller. 1'b0 : Disabled, USB controller is in Use 1'b1 : Enabled, Force complete clock gating of USB controller
        uint32_t MipiPwrdn                                         :1          ; //Bits :[4:4], initial value: 0x0. Engage complete clock gating of MIPI Phy. 1'b0 : Disabled, MIPI controller in Use 1'b1 : Enabled, Force complete clock gating of MIPI PHY, including external clock.
        uint32_t OneMhzRef                                         :1          ; //Bits :[5:5], initial value: 0x0. When set to 1, output of pre-divider is routed as refclk inside the chip. One usage model could be that FW disables trunk clock gating but enables this bit to sustain operation yet saving power. When 0: Functional mode
        uint32_t SusAsBus                                          :1          ; //Bits :[6:6], initial value: 0x0. When set to 1, suspend_clk is routed as busclk to USB controller. Normally FW moves to suspend_clk when enetring low power mode. When 0: Functional mode.  Note: suspend_clk is activated only when lcp is clock gated (specifically pmu_lcp_cg_n==0). This is to ensure that USB controller and EPW are running on same clock.  Note 2: In USB mode, if crystal is allowed to turn off, this bit should be set so that USB controller is clocked
        uint32_t ClkRxelecidle                                     :1          ; //Bits :[7:7], initial value: 0x0. When 1: Enables gating of RefClock to USB PHY with rxelecidle. When 0: rxelecidle is not used for clock gating. Note: This feature should be disabled after exiting U3 because Rxelecidle may not be reilable indication of idle condition
        uint32_t OntimeOverride                                    :8          ; //Bits :[8:15], initial value: 0x0. Override for power stable delay.  Value programmed (number of clocks in 64KHz) is used to account for delay. 8'h00 : Approx 4mS (or 256 clocks). Same timer value is used to stabilize crystal clock after restart. Note: This value also affects decision during Vblank. Powerdown during Vblank has minimum 160uS limitation (5clk to power down, 5clk to power up, and synchronization uncertainties). Value programmed into this register is added to 160uS in powerdown decisions during Vblank. These timings assume that clock 64KHz which may not be true
        uint32_t MemrepairClockDisable                             :1          ; //Bits :[16:16], initial value: 0x0. Setting this bit to 1, will shut-off clock to memory repair logic. This should be set to 1 by FW
        uint32_t EngageClkbot                                      :1          ; //Bits :[17:17], initial value: 0x0. A transition of 0 to 1 on this bit will Enable the ClkBot. When enabled, ClkBot will stop clock to chip (unless overidden). Only way to restore the Clock is indication from WakeBot. As a safegaurd against device hang, clkBot can not be engaged if WakeBot is disabled or all of its inputs are masked
        uint32_t EnableWakebot                                     :1          ; //Bits :[18:18], initial value: 0x0. When set to 1, wakeBot captures the wake event and makes available to rest of logic. When 0, wakeBot output is cleared and no incoming events are captured
        uint32_t EnaPswOnViaVblnk                                  :1          ; //Bits :[19:19], initial value: 0x0. When set to 1, output of Vblnk timer is allowed to reach SwitchBot.  When 0, output of VblnkBot is masked at SwitchBot level.  Therefore Vblnk timers can not run through powerup sequence. Note: Vblnk timer feature is not effective when Vblank period is less than or around ON_TIME.  It is also not effective at slower frame rates than 20frames/hour. Note2: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t EnaPswOnViaWake                                   :1          ; //Bits :[20:20], initial value: 0x0. When set to 1, output of WakeBot is allowed to reach SwitchBot.  When 0, output of WakeBot is masked at SwitchBot level.  Therefore WakeBot can not run through powerup sequence.
        uint32_t IntOnJtag                                         :1          ; //Bits :[21:21], initial value: 0x0. When set to 1, external wake can be triggered via jtag. When this bit is 0, jtag is ignored
        uint32_t IntOnDwi2c                                        :1          ; //Bits :[22:22], initial value: 0x0. When set to 1, wake can be triggered via interrupt from DW I2C interface. When this bit is 0, DW ignored
        uint32_t IntOnBobi2c                                       :1          ; //Bits :[23:23], initial value: 0x0. When set to 1, wake can be triggered via message decoded from I2C implemntation inside Bob. When this bit is 0, Wake from Bob is ingored
        uint32_t IntOnVblnkon                                      :1          ; //Bits :[24:24], initial value: 0x0. When set 1, request from VblnkTimers to PWRON is used to generate wake_interrupt.  When 0, VblankTimers is ignored. Note: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t IntOnDwAxiAccess                                  :1          ; //Bits :[25:25], initial value: 0x0. When set 1, AXI access from USB Controller is used for wake_interrupt. When 0, AXI access are ignored.
        uint32_t IntOnUsbInt                                       :1          ; //Bits :[26:26], initial value: 0x0. When set 1, interrupt from USB-Phy is used for wake_interrupt. When 0, USB interrupt is ignored for wake interrupt generation.
        uint32_t IntOnDwRxelecidle                                 :1          ; //Bits :[27:27], initial value: 0x0. When set 1, rxelecidle from USB-Phy is directly used for USB wake, there by reducing wake time. When 0, phy signal is ignored.  Note: Using this bit may result in spurious wakes because signal from PHY may not be stable
        uint32_t IntOnDfu                                          :1          ; //Bits :[28:28], initial value: 0x0. When set to 1, external wake can be triggered via gpio. When this bit is 0, gpio is ignored
        uint32_t PwrOnRequest                                      :1          ; //Bits :[29:29], initial value: 0x0. When set to 1, a power off request is sent to SwitchBot.  When 0, a powr ON request is sent to SwitchBot.  Bit is qualified with bit 31, see bit 31
        uint32_t EnaPswOffViaVblnk                                 :1          ; //Bits :[30:30], initial value: 0x0. When set to 1, power-off request from VblkTimers is allowed to reach SwitchBot. When 0, power_off request from VblnkTimers are masked.  Therefore VblkTimers is not allowed to run through the powerdown sequence. Note: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t EnaPswCtrlViaCsr29                                :1          ; //Bits :[31:31], initial value: 0x0. When set to 1, bit[29] is allowed to reach SwitchBot.  When 0, bit[29] is ignored by SwitchBot.  Therefore FW can not run through powerup or pwrdn sequence using SwitchBot.
     } fields_read;
    struct {
        uint32_t XcOverride                                        :1          ; //Bits :[0:0], initial value: 0x0. Override power management of crystal oscillator. 1'b0 : Disabled, oscillator is always ON. Also, bypass internal crystal-less low frequency oscillator and derive low frequency from this oscillator. Use XC clock for i2c special message decode. 1'b1 : Enabled, oscillator is allowed to be shutoff. When shutoff, 1MHz is suppled using ring oscillator.  Derive low frequncy clock from ring oscillator. Use ring_osc for I2C decode
        uint32_t HspPwrdn                                          :1          ; //Bits :[1:1], initial value: 0x0. Engage pwrdn feature of HS Phy. 1'b0 : Disabled, USB2 HS Phy is in use. 1'b1 : Enabled, Force USB-HSP power down by asserting test_powerdown_hsp
        uint32_t SspPwrdn                                          :1          ; //Bits :[2:2], initial value: 0x0. Engage pwrdn feature of USB-SS PHy. 1'b0 : Disabled, USB3 SS Phy is in use. 1'b1 : Enabled, Force USB-SSP powerdown by asserting test_powerdown_ssp
        uint32_t UsbPwrdn                                          :1          ; //Bits :[3:3], initial value: 0x0. Engange complete clock gating of USBcontroller. 1'b0 : Disabled, USB controller is in Use 1'b1 : Enabled, Force complete clock gating of USB controller
        uint32_t MipiPwrdn                                         :1          ; //Bits :[4:4], initial value: 0x0. Engage complete clock gating of MIPI Phy. 1'b0 : Disabled, MIPI controller in Use 1'b1 : Enabled, Force complete clock gating of MIPI PHY, including external clock.
        uint32_t OneMhzRef                                         :1          ; //Bits :[5:5], initial value: 0x0. When set to 1, output of pre-divider is routed as refclk inside the chip. One usage model could be that FW disables trunk clock gating but enables this bit to sustain operation yet saving power. When 0: Functional mode
        uint32_t SusAsBus                                          :1          ; //Bits :[6:6], initial value: 0x0. When set to 1, suspend_clk is routed as busclk to USB controller. Normally FW moves to suspend_clk when enetring low power mode. When 0: Functional mode.  Note: suspend_clk is activated only when lcp is clock gated (specifically pmu_lcp_cg_n==0). This is to ensure that USB controller and EPW are running on same clock.  Note 2: In USB mode, if crystal is allowed to turn off, this bit should be set so that USB controller is clocked
        uint32_t ClkRxelecidle                                     :1          ; //Bits :[7:7], initial value: 0x0. When 1: Enables gating of RefClock to USB PHY with rxelecidle. When 0: rxelecidle is not used for clock gating. Note: This feature should be disabled after exiting U3 because Rxelecidle may not be reilable indication of idle condition
        uint32_t OntimeOverride                                    :8          ; //Bits :[8:15], initial value: 0x0. Override for power stable delay.  Value programmed (number of clocks in 64KHz) is used to account for delay. 8'h00 : Approx 4mS (or 256 clocks). Same timer value is used to stabilize crystal clock after restart. Note: This value also affects decision during Vblank. Powerdown during Vblank has minimum 160uS limitation (5clk to power down, 5clk to power up, and synchronization uncertainties). Value programmed into this register is added to 160uS in powerdown decisions during Vblank. These timings assume that clock 64KHz which may not be true
        uint32_t MemrepairClockDisable                             :1          ; //Bits :[16:16], initial value: 0x0. Setting this bit to 1, will shut-off clock to memory repair logic. This should be set to 1 by FW
        uint32_t EngageClkbot                                      :1          ; //Bits :[17:17], initial value: 0x0. A transition of 0 to 1 on this bit will Enable the ClkBot. When enabled, ClkBot will stop clock to chip (unless overidden). Only way to restore the Clock is indication from WakeBot. As a safegaurd against device hang, clkBot can not be engaged if WakeBot is disabled or all of its inputs are masked
        uint32_t EnableWakebot                                     :1          ; //Bits :[18:18], initial value: 0x0. When set to 1, wakeBot captures the wake event and makes available to rest of logic. When 0, wakeBot output is cleared and no incoming events are captured
        uint32_t EnaPswOnViaVblnk                                  :1          ; //Bits :[19:19], initial value: 0x0. When set to 1, output of Vblnk timer is allowed to reach SwitchBot.  When 0, output of VblnkBot is masked at SwitchBot level.  Therefore Vblnk timers can not run through powerup sequence. Note: Vblnk timer feature is not effective when Vblank period is less than or around ON_TIME.  It is also not effective at slower frame rates than 20frames/hour. Note2: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t EnaPswOnViaWake                                   :1          ; //Bits :[20:20], initial value: 0x0. When set to 1, output of WakeBot is allowed to reach SwitchBot.  When 0, output of WakeBot is masked at SwitchBot level.  Therefore WakeBot can not run through powerup sequence.
        uint32_t IntOnJtag                                         :1          ; //Bits :[21:21], initial value: 0x0. When set to 1, external wake can be triggered via jtag. When this bit is 0, jtag is ignored
        uint32_t IntOnDwi2c                                        :1          ; //Bits :[22:22], initial value: 0x0. When set to 1, wake can be triggered via interrupt from DW I2C interface. When this bit is 0, DW ignored
        uint32_t IntOnBobi2c                                       :1          ; //Bits :[23:23], initial value: 0x0. When set to 1, wake can be triggered via message decoded from I2C implemntation inside Bob. When this bit is 0, Wake from Bob is ingored
        uint32_t IntOnVblnkon                                      :1          ; //Bits :[24:24], initial value: 0x0. When set 1, request from VblnkTimers to PWRON is used to generate wake_interrupt.  When 0, VblankTimers is ignored. Note: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t IntOnDwAxiAccess                                  :1          ; //Bits :[25:25], initial value: 0x0. When set 1, AXI access from USB Controller is used for wake_interrupt. When 0, AXI access are ignored.
        uint32_t IntOnUsbInt                                       :1          ; //Bits :[26:26], initial value: 0x0. When set 1, interrupt from USB-Phy is used for wake_interrupt. When 0, USB interrupt is ignored for wake interrupt generation.
        uint32_t IntOnDwRxelecidle                                 :1          ; //Bits :[27:27], initial value: 0x0. When set 1, rxelecidle from USB-Phy is directly used for USB wake, there by reducing wake time. When 0, phy signal is ignored.  Note: Using this bit may result in spurious wakes because signal from PHY may not be stable
        uint32_t IntOnDfu                                          :1          ; //Bits :[28:28], initial value: 0x0. When set to 1, external wake can be triggered via gpio. When this bit is 0, gpio is ignored
        uint32_t PwrOnRequest                                      :1          ; //Bits :[29:29], initial value: 0x0. When set to 1, a power off request is sent to SwitchBot.  When 0, a powr ON request is sent to SwitchBot.  Bit is qualified with bit 31, see bit 31
        uint32_t EnaPswOffViaVblnk                                 :1          ; //Bits :[30:30], initial value: 0x0. When set to 1, power-off request from VblkTimers is allowed to reach SwitchBot. When 0, power_off request from VblnkTimers are masked.  Therefore VblkTimers is not allowed to run through the powerdown sequence. Note: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t EnaPswCtrlViaCsr29                                :1          ; //Bits :[31:31], initial value: 0x0. When set to 1, bit[29] is allowed to reach SwitchBot.  When 0, bit[29] is ignored by SwitchBot.  Therefore FW can not run through powerup or pwrdn sequence using SwitchBot.
     } fields_write;
    struct {
        uint32_t XcOverride                                        :1          ; //Bits :[0:0], initial value: 0x0. Override power management of crystal oscillator. 1'b0 : Disabled, oscillator is always ON. Also, bypass internal crystal-less low frequency oscillator and derive low frequency from this oscillator. Use XC clock for i2c special message decode. 1'b1 : Enabled, oscillator is allowed to be shutoff. When shutoff, 1MHz is suppled using ring oscillator.  Derive low frequncy clock from ring oscillator. Use ring_osc for I2C decode
        uint32_t HspPwrdn                                          :1          ; //Bits :[1:1], initial value: 0x0. Engage pwrdn feature of HS Phy. 1'b0 : Disabled, USB2 HS Phy is in use. 1'b1 : Enabled, Force USB-HSP power down by asserting test_powerdown_hsp
        uint32_t SspPwrdn                                          :1          ; //Bits :[2:2], initial value: 0x0. Engage pwrdn feature of USB-SS PHy. 1'b0 : Disabled, USB3 SS Phy is in use. 1'b1 : Enabled, Force USB-SSP powerdown by asserting test_powerdown_ssp
        uint32_t UsbPwrdn                                          :1          ; //Bits :[3:3], initial value: 0x0. Engange complete clock gating of USBcontroller. 1'b0 : Disabled, USB controller is in Use 1'b1 : Enabled, Force complete clock gating of USB controller
        uint32_t MipiPwrdn                                         :1          ; //Bits :[4:4], initial value: 0x0. Engage complete clock gating of MIPI Phy. 1'b0 : Disabled, MIPI controller in Use 1'b1 : Enabled, Force complete clock gating of MIPI PHY, including external clock.
        uint32_t OneMhzRef                                         :1          ; //Bits :[5:5], initial value: 0x0. When set to 1, output of pre-divider is routed as refclk inside the chip. One usage model could be that FW disables trunk clock gating but enables this bit to sustain operation yet saving power. When 0: Functional mode
        uint32_t SusAsBus                                          :1          ; //Bits :[6:6], initial value: 0x0. When set to 1, suspend_clk is routed as busclk to USB controller. Normally FW moves to suspend_clk when enetring low power mode. When 0: Functional mode.  Note: suspend_clk is activated only when lcp is clock gated (specifically pmu_lcp_cg_n==0). This is to ensure that USB controller and EPW are running on same clock.  Note 2: In USB mode, if crystal is allowed to turn off, this bit should be set so that USB controller is clocked
        uint32_t ClkRxelecidle                                     :1          ; //Bits :[7:7], initial value: 0x0. When 1: Enables gating of RefClock to USB PHY with rxelecidle. When 0: rxelecidle is not used for clock gating. Note: This feature should be disabled after exiting U3 because Rxelecidle may not be reilable indication of idle condition
        uint32_t OntimeOverride                                    :8          ; //Bits :[8:15], initial value: 0x0. Override for power stable delay.  Value programmed (number of clocks in 64KHz) is used to account for delay. 8'h00 : Approx 4mS (or 256 clocks). Same timer value is used to stabilize crystal clock after restart. Note: This value also affects decision during Vblank. Powerdown during Vblank has minimum 160uS limitation (5clk to power down, 5clk to power up, and synchronization uncertainties). Value programmed into this register is added to 160uS in powerdown decisions during Vblank. These timings assume that clock 64KHz which may not be true
        uint32_t MemrepairClockDisable                             :1          ; //Bits :[16:16], initial value: 0x0. Setting this bit to 1, will shut-off clock to memory repair logic. This should be set to 1 by FW
        uint32_t EngageClkbot                                      :1          ; //Bits :[17:17], initial value: 0x0. A transition of 0 to 1 on this bit will Enable the ClkBot. When enabled, ClkBot will stop clock to chip (unless overidden). Only way to restore the Clock is indication from WakeBot. As a safegaurd against device hang, clkBot can not be engaged if WakeBot is disabled or all of its inputs are masked
        uint32_t EnableWakebot                                     :1          ; //Bits :[18:18], initial value: 0x0. When set to 1, wakeBot captures the wake event and makes available to rest of logic. When 0, wakeBot output is cleared and no incoming events are captured
        uint32_t EnaPswOnViaVblnk                                  :1          ; //Bits :[19:19], initial value: 0x0. When set to 1, output of Vblnk timer is allowed to reach SwitchBot.  When 0, output of VblnkBot is masked at SwitchBot level.  Therefore Vblnk timers can not run through powerup sequence. Note: Vblnk timer feature is not effective when Vblank period is less than or around ON_TIME.  It is also not effective at slower frame rates than 20frames/hour. Note2: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t EnaPswOnViaWake                                   :1          ; //Bits :[20:20], initial value: 0x0. When set to 1, output of WakeBot is allowed to reach SwitchBot.  When 0, output of WakeBot is masked at SwitchBot level.  Therefore WakeBot can not run through powerup sequence.
        uint32_t IntOnJtag                                         :1          ; //Bits :[21:21], initial value: 0x0. When set to 1, external wake can be triggered via jtag. When this bit is 0, jtag is ignored
        uint32_t IntOnDwi2c                                        :1          ; //Bits :[22:22], initial value: 0x0. When set to 1, wake can be triggered via interrupt from DW I2C interface. When this bit is 0, DW ignored
        uint32_t IntOnBobi2c                                       :1          ; //Bits :[23:23], initial value: 0x0. When set to 1, wake can be triggered via message decoded from I2C implemntation inside Bob. When this bit is 0, Wake from Bob is ingored
        uint32_t IntOnVblnkon                                      :1          ; //Bits :[24:24], initial value: 0x0. When set 1, request from VblnkTimers to PWRON is used to generate wake_interrupt.  When 0, VblankTimers is ignored. Note: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t IntOnDwAxiAccess                                  :1          ; //Bits :[25:25], initial value: 0x0. When set 1, AXI access from USB Controller is used for wake_interrupt. When 0, AXI access are ignored.
        uint32_t IntOnUsbInt                                       :1          ; //Bits :[26:26], initial value: 0x0. When set 1, interrupt from USB-Phy is used for wake_interrupt. When 0, USB interrupt is ignored for wake interrupt generation.
        uint32_t IntOnDwRxelecidle                                 :1          ; //Bits :[27:27], initial value: 0x0. When set 1, rxelecidle from USB-Phy is directly used for USB wake, there by reducing wake time. When 0, phy signal is ignored.  Note: Using this bit may result in spurious wakes because signal from PHY may not be stable
        uint32_t IntOnDfu                                          :1          ; //Bits :[28:28], initial value: 0x0. When set to 1, external wake can be triggered via gpio. When this bit is 0, gpio is ignored
        uint32_t PwrOnRequest                                      :1          ; //Bits :[29:29], initial value: 0x0. When set to 1, a power off request is sent to SwitchBot.  When 0, a powr ON request is sent to SwitchBot.  Bit is qualified with bit 31, see bit 31
        uint32_t EnaPswOffViaVblnk                                 :1          ; //Bits :[30:30], initial value: 0x0. When set to 1, power-off request from VblkTimers is allowed to reach SwitchBot. When 0, power_off request from VblnkTimers are masked.  Therefore VblkTimers is not allowed to run through the powerdown sequence. Note: Setting this bit should be performed only when depth-datapath is disabled.
        uint32_t EnaPswCtrlViaCsr29                                :1          ; //Bits :[31:31], initial value: 0x0. When set to 1, bit[29] is allowed to reach SwitchBot.  When 0, bit[29] is ignored by SwitchBot.  Therefore FW can not run through powerup or pwrdn sequence using SwitchBot.
     } fields_rmw; //for non-shadowed register
} RegCsrPmuControl1, TRegCsrPmuControl1, *PTRegCsrPmuControl1;                                //0x12504

//Power Management Unit (PMU)  Control 2.
//initial value: 0
typedef union __RegCsrPmuControl2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SplMessages                                       :8          ; //Bits :[0:7], initial value: 0x0. Definition of special Reset message to be decoded on I2C(H) interafce.
        uint32_t SplSlave                                          :7          ; //Bits :[8:14], initial value: 0x0. Definition of slave address decoded on I2C(H) interafce for special (Reset or Wake) message.  7 bits of Slave Address
        uint32_t SplSlaveEnable                                    :1          ; //Bits :[15:15], initial value: 0x0. When set to 1, special message decode engine is enabled, else disabled. If I2C is operating at higher speed than 400KHz, decoder should be disabled, irrespective of whether decoder is target or not
        uint32_t SplSlaveFltr                                      :1          ; //Bits :[16:16], initial value: 0x0. Used to modify filter behavior of special message decode engine. When set 1, two clock filter is used. When 0, filtering is set to one clock. I2C may require upto 50nS filtering. This bit allows filetring to be adjusted based on clock frequency
        uint32_t SusDivider                                        :15         ; //Bits :[17:31], initial value: 0x0. Divider value for post- and pre_divider. These dividers can be used to set the suspend_clk frequency. Clock source could be either external crystal based refclk or internal ring oscillator. Source is selected by Control1[0].  When using ring oscillator, calibration may be required. Calibration involves adjusting dividers after reading the status register where number of refclks into half-period of suspend_clk is made available. MSbit[31] acts as disable bit. Bits[30:17] should be changed only when Bit[31] is 1. Bits[23:17] control the post_divider and Bits[30:24] control the pre_divider. Legal divider values are 1-127. Value 0 is aliased to 19
     } fields_read;
    struct {
        uint32_t SplMessages                                       :8          ; //Bits :[0:7], initial value: 0x0. Definition of special Reset message to be decoded on I2C(H) interafce.
        uint32_t SplSlave                                          :7          ; //Bits :[8:14], initial value: 0x0. Definition of slave address decoded on I2C(H) interafce for special (Reset or Wake) message.  7 bits of Slave Address
        uint32_t SplSlaveEnable                                    :1          ; //Bits :[15:15], initial value: 0x0. When set to 1, special message decode engine is enabled, else disabled. If I2C is operating at higher speed than 400KHz, decoder should be disabled, irrespective of whether decoder is target or not
        uint32_t SplSlaveFltr                                      :1          ; //Bits :[16:16], initial value: 0x0. Used to modify filter behavior of special message decode engine. When set 1, two clock filter is used. When 0, filtering is set to one clock. I2C may require upto 50nS filtering. This bit allows filetring to be adjusted based on clock frequency
        uint32_t SusDivider                                        :15         ; //Bits :[17:31], initial value: 0x0. Divider value for post- and pre_divider. These dividers can be used to set the suspend_clk frequency. Clock source could be either external crystal based refclk or internal ring oscillator. Source is selected by Control1[0].  When using ring oscillator, calibration may be required. Calibration involves adjusting dividers after reading the status register where number of refclks into half-period of suspend_clk is made available. MSbit[31] acts as disable bit. Bits[30:17] should be changed only when Bit[31] is 1. Bits[23:17] control the post_divider and Bits[30:24] control the pre_divider. Legal divider values are 1-127. Value 0 is aliased to 19
     } fields_write;
    struct {
        uint32_t SplMessages                                       :8          ; //Bits :[0:7], initial value: 0x0. Definition of special Reset message to be decoded on I2C(H) interafce.
        uint32_t SplSlave                                          :7          ; //Bits :[8:14], initial value: 0x0. Definition of slave address decoded on I2C(H) interafce for special (Reset or Wake) message.  7 bits of Slave Address
        uint32_t SplSlaveEnable                                    :1          ; //Bits :[15:15], initial value: 0x0. When set to 1, special message decode engine is enabled, else disabled. If I2C is operating at higher speed than 400KHz, decoder should be disabled, irrespective of whether decoder is target or not
        uint32_t SplSlaveFltr                                      :1          ; //Bits :[16:16], initial value: 0x0. Used to modify filter behavior of special message decode engine. When set 1, two clock filter is used. When 0, filtering is set to one clock. I2C may require upto 50nS filtering. This bit allows filetring to be adjusted based on clock frequency
        uint32_t SusDivider                                        :15         ; //Bits :[17:31], initial value: 0x0. Divider value for post- and pre_divider. These dividers can be used to set the suspend_clk frequency. Clock source could be either external crystal based refclk or internal ring oscillator. Source is selected by Control1[0].  When using ring oscillator, calibration may be required. Calibration involves adjusting dividers after reading the status register where number of refclks into half-period of suspend_clk is made available. MSbit[31] acts as disable bit. Bits[30:17] should be changed only when Bit[31] is 1. Bits[23:17] control the post_divider and Bits[30:24] control the pre_divider. Legal divider values are 1-127. Value 0 is aliased to 19
     } fields_rmw; //for non-shadowed register
} RegCsrPmuControl2, TRegCsrPmuControl2, *PTRegCsrPmuControl2;                                //0x12508

//Power Management Unit (PMU)  Control 3.
//initial value: 0
typedef union __RegCsrPmuControl3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ClkbotOverride                                    :4          ; //Bits :[0:3], initial value: 0x0. These are overrides to take over the control in SW. 0: Enable override, 1: pmu_use_sus_as_ref, 2: pmu_lcp_cg_n, 3:Reserved
        uint32_t PwrbotOverride                                    :8          ; //Bits :[4:11], initial value: 0x0. These are overrides to take over the control in SW. Bit4: Enable override, 11: pmu_recscp_pwr_en, 10:pmu_recscp_cg_n, 9: pmu_recscp_iso_en,  8: pmu_recscp_rstn, 7: pmu_recscp_restore, 6: pmu_recscp_store, 5: Reserved
        uint32_t Ds5Work3                                          :15         ; //Bits :[12:26], initial value: 0x0. This is a check point for DS5. LCP can decide to individual bit as 1 once it has confirmed certain functionality is working on DS5 samples. These signal can be observed on cw. This is for debug only
        uint32_t MipiClkgate                                       :5          ; //Bits :[27:31], initial value: 0x0. These 5bits gate the mipi interface clock going to outside of chip. When set 1 : Clk is gated. Bit 27: a_rclk, 28:b_rclk, 29: m_rclk, 30: y_rclk, 31: z_rclk
     } fields_read;
    struct {
        uint32_t ClkbotOverride                                    :4          ; //Bits :[0:3], initial value: 0x0. These are overrides to take over the control in SW. 0: Enable override, 1: pmu_use_sus_as_ref, 2: pmu_lcp_cg_n, 3:Reserved
        uint32_t PwrbotOverride                                    :8          ; //Bits :[4:11], initial value: 0x0. These are overrides to take over the control in SW. Bit4: Enable override, 11: pmu_recscp_pwr_en, 10:pmu_recscp_cg_n, 9: pmu_recscp_iso_en,  8: pmu_recscp_rstn, 7: pmu_recscp_restore, 6: pmu_recscp_store, 5: Reserved
        uint32_t Ds5Work3                                          :15         ; //Bits :[12:26], initial value: 0x0. This is a check point for DS5. LCP can decide to individual bit as 1 once it has confirmed certain functionality is working on DS5 samples. These signal can be observed on cw. This is for debug only
        uint32_t MipiClkgate                                       :5          ; //Bits :[27:31], initial value: 0x0. These 5bits gate the mipi interface clock going to outside of chip. When set 1 : Clk is gated. Bit 27: a_rclk, 28:b_rclk, 29: m_rclk, 30: y_rclk, 31: z_rclk
     } fields_write;
    struct {
        uint32_t ClkbotOverride                                    :4          ; //Bits :[0:3], initial value: 0x0. These are overrides to take over the control in SW. 0: Enable override, 1: pmu_use_sus_as_ref, 2: pmu_lcp_cg_n, 3:Reserved
        uint32_t PwrbotOverride                                    :8          ; //Bits :[4:11], initial value: 0x0. These are overrides to take over the control in SW. Bit4: Enable override, 11: pmu_recscp_pwr_en, 10:pmu_recscp_cg_n, 9: pmu_recscp_iso_en,  8: pmu_recscp_rstn, 7: pmu_recscp_restore, 6: pmu_recscp_store, 5: Reserved
        uint32_t Ds5Work3                                          :15         ; //Bits :[12:26], initial value: 0x0. This is a check point for DS5. LCP can decide to individual bit as 1 once it has confirmed certain functionality is working on DS5 samples. These signal can be observed on cw. This is for debug only
        uint32_t MipiClkgate                                       :5          ; //Bits :[27:31], initial value: 0x0. These 5bits gate the mipi interface clock going to outside of chip. When set 1 : Clk is gated. Bit 27: a_rclk, 28:b_rclk, 29: m_rclk, 30: y_rclk, 31: z_rclk
     } fields_rmw; //for non-shadowed register
} RegCsrPmuControl3, TRegCsrPmuControl3, *PTRegCsrPmuControl3;                                //0x1250C

//Power Management Unit (PMU)  Control 4.
//initial value: 0x1F
typedef union __RegCsrPmuControl4{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CgNRec                                            :1          ; //Bits :[0:0], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in REC. If 0 then PMU stops clock in REC block during vertical blanking period whenever possible.
        uint32_t CgNScpPre                                         :1          ; //Bits :[1:1], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_pre. If 0 then PMU stops clock in scp_pre block during vertical blanking period whenever possible.
        uint32_t CgNScpRau                                         :1          ; //Bits :[2:2], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_rau. If 0 then PMU stops clock in scp_rau block during vertical blanking period whenever possible.
        uint32_t CgNScpPost                                        :1          ; //Bits :[3:3], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_post. If 0 then PMU stops clock in scp_post block during vertical blanking period whenever possible.
        uint32_t CgNCmp                                            :1          ; //Bits :[4:4], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in cmp. If 0 then PMU stops clock in cmp block whenever lcp decides to write to this bit.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t CgNRec                                            :1          ; //Bits :[0:0], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in REC. If 0 then PMU stops clock in REC block during vertical blanking period whenever possible.
        uint32_t CgNScpPre                                         :1          ; //Bits :[1:1], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_pre. If 0 then PMU stops clock in scp_pre block during vertical blanking period whenever possible.
        uint32_t CgNScpRau                                         :1          ; //Bits :[2:2], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_rau. If 0 then PMU stops clock in scp_rau block during vertical blanking period whenever possible.
        uint32_t CgNScpPost                                        :1          ; //Bits :[3:3], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_post. If 0 then PMU stops clock in scp_post block during vertical blanking period whenever possible.
        uint32_t CgNCmp                                            :1          ; //Bits :[4:4], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in cmp. If 0 then PMU stops clock in cmp block whenever lcp decides to write to this bit.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t CgNRec                                            :1          ; //Bits :[0:0], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in REC. If 0 then PMU stops clock in REC block during vertical blanking period whenever possible.
        uint32_t CgNScpPre                                         :1          ; //Bits :[1:1], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_pre. If 0 then PMU stops clock in scp_pre block during vertical blanking period whenever possible.
        uint32_t CgNScpRau                                         :1          ; //Bits :[2:2], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_rau. If 0 then PMU stops clock in scp_rau block during vertical blanking period whenever possible.
        uint32_t CgNScpPost                                        :1          ; //Bits :[3:3], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in scp_post. If 0 then PMU stops clock in scp_post block during vertical blanking period whenever possible.
        uint32_t CgNCmp                                            :1          ; //Bits :[4:4], initial value: 0x1. Active low. Write 0 to this bit to enable clock gating in cmp. If 0 then PMU stops clock in cmp block whenever lcp decides to write to this bit.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPmuControl4, TRegCsrPmuControl4, *PTRegCsrPmuControl4;                                //0x12514

//Power Management Unit (PMU)  Control 5.
//initial value: 0x0
typedef union __RegCsrPmuControl5{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ScpPreDpSdEn                                      :1          ; //Bits :[0:0], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of scp_pre datapath memory during blanking period whenever possible.
        uint32_t ScpPreLutDsEn                                     :1          ; //Bits :[1:1], initial value: 0x0. Active high. Write 1 to this bit to enable deepsleep mode of scp_pre LUT memory blanking period whenever possible.
        uint32_t ScpPostDpSdEn                                     :1          ; //Bits :[2:2], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of scp_post datapath memory during blanking period whenever possible.
        uint32_t ScpPostLutDsEn                                    :1          ; //Bits :[3:3], initial value: 0x0. Active high. Write 1 to this bit to enable deepsleep mode of scp_post LUT during blanking period whenever possible.
        uint32_t ScpRauSdEn                                        :1          ; //Bits :[4:4], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rau memory during blanking period whenever possible.
        uint32_t RecMSdEn                                          :1          ; //Bits :[5:5], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rec memory during blanking period whenever possible.
        uint32_t CmpMSdEn                                          :1          ; //Bits :[6:6], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rom and ram in cmp whenever LCP decides to do it.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t ScpPreDpSdEn                                      :1          ; //Bits :[0:0], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of scp_pre datapath memory during blanking period whenever possible.
        uint32_t ScpPreLutDsEn                                     :1          ; //Bits :[1:1], initial value: 0x0. Active high. Write 1 to this bit to enable deepsleep mode of scp_pre LUT memory blanking period whenever possible.
        uint32_t ScpPostDpSdEn                                     :1          ; //Bits :[2:2], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of scp_post datapath memory during blanking period whenever possible.
        uint32_t ScpPostLutDsEn                                    :1          ; //Bits :[3:3], initial value: 0x0. Active high. Write 1 to this bit to enable deepsleep mode of scp_post LUT during blanking period whenever possible.
        uint32_t ScpRauSdEn                                        :1          ; //Bits :[4:4], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rau memory during blanking period whenever possible.
        uint32_t RecMSdEn                                          :1          ; //Bits :[5:5], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rec memory during blanking period whenever possible.
        uint32_t CmpMSdEn                                          :1          ; //Bits :[6:6], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rom and ram in cmp whenever LCP decides to do it.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t ScpPreDpSdEn                                      :1          ; //Bits :[0:0], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of scp_pre datapath memory during blanking period whenever possible.
        uint32_t ScpPreLutDsEn                                     :1          ; //Bits :[1:1], initial value: 0x0. Active high. Write 1 to this bit to enable deepsleep mode of scp_pre LUT memory blanking period whenever possible.
        uint32_t ScpPostDpSdEn                                     :1          ; //Bits :[2:2], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of scp_post datapath memory during blanking period whenever possible.
        uint32_t ScpPostLutDsEn                                    :1          ; //Bits :[3:3], initial value: 0x0. Active high. Write 1 to this bit to enable deepsleep mode of scp_post LUT during blanking period whenever possible.
        uint32_t ScpRauSdEn                                        :1          ; //Bits :[4:4], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rau memory during blanking period whenever possible.
        uint32_t RecMSdEn                                          :1          ; //Bits :[5:5], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rec memory during blanking period whenever possible.
        uint32_t CmpMSdEn                                          :1          ; //Bits :[6:6], initial value: 0x0. Active high. Write 1 to this bit to enable shutdown mode of rom and ram in cmp whenever LCP decides to do it.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPmuControl5, TRegCsrPmuControl5, *PTRegCsrPmuControl5;                                //0x12518

//Power Management Unit (PMU)  PMU Status.
//initial value: 1
typedef union __RegCsrPmuStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t InU0                                              :1          ; //Bits :[0:0], initial value: 0x1. PMU is seviving U0 state.
        uint32_t InIdle                                            :1          ; //Bits :[1:1], initial value: 0x0. PMU is in IDLE state.
        uint32_t InU3                                              :1          ; //Bits :[2:2], initial value: 0x0. PMU is serving in U3 state.
        uint32_t InU3ToU0                                          :1          ; //Bits :[3:3], initial value: 0x0. This bit is for future use. Reading this bit will give un predictable result though most of the time it will be zero but rarely 1. Ignore this bit for verification.
        uint32_t PmuState                                          :10         ; //Bits :[4:13], initial value: 0x0. Various internal States for debug. Write has no effect.
        uint32_t PwrSwitchOnStatus                                 :1          ; //Bits :[14:14], initial value: 0x0. Current status of PowerSwitch 1: ON, 0:OFF. Write has no effect.
        uint32_t IsolationStatus                                   :1          ; //Bits :[15:15], initial value: 0x0. Current status of SwitchedPowerDomain 1: Domain Isolated, 0:Domain notIsolated. Write has no effect.
        uint32_t Ref2susRatio                                      :8          ; //Bits :[16:23], initial value: 0x0. Count of refclks in half-period of suspend_clk. This register is used to calibrate the suspend_clk.  Period of suspend_clk is adjusted by programming the pre- and post-dividers. Suspend_clk is 50% duty, slow running clock; typically 64KHz. In situations where width of this register is a limitation, user can first calibrate at a higher frequency and then adjust dividers.
        uint32_t WakeSource                                        :8          ; //Bits :[24:31], initial value: 0x0. Source of wake intr: Indicates event(s) that caused wake intr: 31-jtag, 30-dw_i2c, 29-bob_i2c, 28:vblank_on, 27-usb_gif_access, 26-usb_intr, 25-usb_rxelecidle, 24-dfu_gpio
     } fields_read;
    struct {
        uint32_t InU0                                              :1          ; //Bits :[0:0], initial value: 0x1. PMU is seviving U0 state.
        uint32_t InIdle                                            :1          ; //Bits :[1:1], initial value: 0x0. PMU is in IDLE state.
        uint32_t InU3                                              :1          ; //Bits :[2:2], initial value: 0x0. PMU is serving in U3 state.
        uint32_t InU3ToU0                                          :1          ; //Bits :[3:3], initial value: 0x0. This bit is for future use. Reading this bit will give un predictable result though most of the time it will be zero but rarely 1. Ignore this bit for verification.
        uint32_t PmuState                                          :10         ; //Bits :[4:13], initial value: 0x0. Various internal States for debug. Write has no effect.
        uint32_t PwrSwitchOnStatus                                 :1          ; //Bits :[14:14], initial value: 0x0. Current status of PowerSwitch 1: ON, 0:OFF. Write has no effect.
        uint32_t IsolationStatus                                   :1          ; //Bits :[15:15], initial value: 0x0. Current status of SwitchedPowerDomain 1: Domain Isolated, 0:Domain notIsolated. Write has no effect.
        uint32_t Ref2susRatio                                      :8          ; //Bits :[16:23], initial value: 0x0. Count of refclks in half-period of suspend_clk. This register is used to calibrate the suspend_clk.  Period of suspend_clk is adjusted by programming the pre- and post-dividers. Suspend_clk is 50% duty, slow running clock; typically 64KHz. In situations where width of this register is a limitation, user can first calibrate at a higher frequency and then adjust dividers.
        uint32_t WakeSource                                        :8          ; //Bits :[24:31], initial value: 0x0. Source of wake intr: Indicates event(s) that caused wake intr: 31-jtag, 30-dw_i2c, 29-bob_i2c, 28:vblank_on, 27-usb_gif_access, 26-usb_intr, 25-usb_rxelecidle, 24-dfu_gpio
     } fields_rmw; //for non-shadowed register
} RegCsrPmuStatus, TRegCsrPmuStatus, *PTRegCsrPmuStatus;                                //0x12510

//Enable for indirect register access to fuse block via APB
//initial value: 0x9900
typedef union __RegCsrEfuseControl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t A                                                 :8          ; //Bits :[0:7], initial value: 0x0. 8-bit address bus
        uint32_t Csb                                               :1          ; //Bits :[8:8], initial value: 0x1. chip select/enable (active low)
        uint32_t Strobe                                            :1          ; //Bits :[9:9], initial value: 0x0. high to turn on the array for read access
        uint32_t Load                                              :1          ; //Bits :[10:10], initial value: 0x0. high to turn on sense amp and load data into the latch
        uint32_t Pgenb                                             :1          ; //Bits :[11:11], initial value: 0x1. program enable(active low)
        uint32_t Rsb                                               :1          ; //Bits :[12:12], initial value: 0x1. redundancy enable/disable (active/low)
        uint32_t Rwl                                               :1          ; //Bits :[13:13], initial value: 0x0. redundancy information row select
        uint32_t Ps                                                :1          ; //Bits :[14:14], initial value: 0x0. high to pass 1.8V program voltage to internal macro
        uint32_t Pd                                                :1          ; //Bits :[15:15], initial value: 0x1. power down enable
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t A                                                 :8          ; //Bits :[0:7], initial value: 0x0. 8-bit address bus
        uint32_t Csb                                               :1          ; //Bits :[8:8], initial value: 0x1. chip select/enable (active low)
        uint32_t Strobe                                            :1          ; //Bits :[9:9], initial value: 0x0. high to turn on the array for read access
        uint32_t Load                                              :1          ; //Bits :[10:10], initial value: 0x0. high to turn on sense amp and load data into the latch
        uint32_t Pgenb                                             :1          ; //Bits :[11:11], initial value: 0x1. program enable(active low)
        uint32_t Rsb                                               :1          ; //Bits :[12:12], initial value: 0x1. redundancy enable/disable (active/low)
        uint32_t Rwl                                               :1          ; //Bits :[13:13], initial value: 0x0. redundancy information row select
        uint32_t Ps                                                :1          ; //Bits :[14:14], initial value: 0x0. high to pass 1.8V program voltage to internal macro
        uint32_t Pd                                                :1          ; //Bits :[15:15], initial value: 0x1. power down enable
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t A                                                 :8          ; //Bits :[0:7], initial value: 0x0. 8-bit address bus
        uint32_t Csb                                               :1          ; //Bits :[8:8], initial value: 0x1. chip select/enable (active low)
        uint32_t Strobe                                            :1          ; //Bits :[9:9], initial value: 0x0. high to turn on the array for read access
        uint32_t Load                                              :1          ; //Bits :[10:10], initial value: 0x0. high to turn on sense amp and load data into the latch
        uint32_t Pgenb                                             :1          ; //Bits :[11:11], initial value: 0x1. program enable(active low)
        uint32_t Rsb                                               :1          ; //Bits :[12:12], initial value: 0x1. redundancy enable/disable (active/low)
        uint32_t Rwl                                               :1          ; //Bits :[13:13], initial value: 0x0. redundancy information row select
        uint32_t Ps                                                :1          ; //Bits :[14:14], initial value: 0x0. high to pass 1.8V program voltage to internal macro
        uint32_t Pd                                                :1          ; //Bits :[15:15], initial value: 0x1. power down enable
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrEfuseControl0, TRegCsrEfuseControl0, *PTRegCsrEfuseControl0;                                //0x12540

//FUSE macro read data latch enable
//initial value: 0x0
typedef union __RegCsrEfuseControl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EfuseReadLatch                                    :1          ; //Bits :[0:0], initial value: 0x0. WRITE ONLY. Write ‘1 to this bit to trigger latching of fuse macro read data into 32 bit internal register
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t EfuseReadLatch                                    :1          ; //Bits :[0:0], initial value: 0x0. WRITE ONLY. Write ‘1 to this bit to trigger latching of fuse macro read data into 32 bit internal register
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t EfuseReadLatch                                    :1          ; //Bits :[0:0], initial value: 0x0. WRITE ONLY. Write ‘1 to this bit to trigger latching of fuse macro read data into 32 bit internal register
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrEfuseControl1, TRegCsrEfuseControl1, *PTRegCsrEfuseControl1;                                //0x12544

//EFuse Read Data
//initial value: 0x0
typedef union __RegCsrEfuseReadData{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EfuseQout                                         :32         ; //Bits :[0:31], initial value: 0x0. Contains value of fuses [31:0] after a fuse read sequence has been performed. Initial value =XX
     } fields_read;
    struct {
        uint32_t EfuseQout                                         :32         ; //Bits :[0:31], initial value: 0x0. Contains value of fuses [31:0] after a fuse read sequence has been performed. Initial value =XX
     } fields_rmw; //for non-shadowed register
} RegCsrEfuseReadData, TRegCsrEfuseReadData, *PTRegCsrEfuseReadData;                                //0x12548

//EFuse redundancy Read Data
//initial value: 0x0
typedef union __RegCsrEfuseReadData2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EfuseRfout                                        :4          ; //Bits :[0:3], initial value: 0x0. Contains value of fuses redundancy data [3:0] after a fuse read sequence has been performed. Initial value =XX
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t EfuseRfout                                        :4          ; //Bits :[0:3], initial value: 0x0. Contains value of fuses redundancy data [3:0] after a fuse read sequence has been performed. Initial value =XX
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrEfuseReadData2, TRegCsrEfuseReadData2, *PTRegCsrEfuseReadData2;                                //0x1254C

//MIPI PHY Reference SCLK Frequency Counter and control bits. This is used to measure the PHY PHY data rate on highspeed
//loop back test.
//initial value: 0x14D
typedef union __RegCsrMipiphyRefFrquency{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ReferenceCount                                    :16         ; //Bits :[0:15], initial value: 0x14D. SCLK Reference counter Value
        uint32_t ReferenceCountEnable                              :1          ; //Bits :[16:16], initial value: 0x0. SCLK Reference counter enable. Counter will start counting down upon setting of this bit.
        uint32_t ReferenceCountClear                               :1          ; //Bits :[17:17], initial value: 0x0. Counter value gets cleared upon setting of this bit. Counter remains 0 as long as this bit set.
        uint32_t Reserved                                          :14         ; //Bits :[18:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t ReferenceCount                                    :16         ; //Bits :[0:15], initial value: 0x14D. SCLK Reference counter Value
        uint32_t ReferenceCountEnable                              :1          ; //Bits :[16:16], initial value: 0x0. SCLK Reference counter enable. Counter will start counting down upon setting of this bit.
        uint32_t ReferenceCountClear                               :1          ; //Bits :[17:17], initial value: 0x0. Counter value gets cleared upon setting of this bit. Counter remains 0 as long as this bit set.
        uint32_t Reserved                                          :14         ; //Bits :[18:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t ReferenceCount                                    :16         ; //Bits :[0:15], initial value: 0x14D. SCLK Reference counter Value
        uint32_t ReferenceCountEnable                              :1          ; //Bits :[16:16], initial value: 0x0. SCLK Reference counter enable. Counter will start counting down upon setting of this bit.
        uint32_t ReferenceCountClear                               :1          ; //Bits :[17:17], initial value: 0x0. Counter value gets cleared upon setting of this bit. Counter remains 0 as long as this bit set.
        uint32_t Reserved                                          :14         ; //Bits :[18:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrMipiphyRefFrquency, TRegCsrMipiphyRefFrquency, *PTRegCsrMipiphyRefFrquency;                                //0x12570

//Pinstrap Status. This register is read only. Initial value is X.
//initial value: 0x0
typedef union __RegCsrPinstrapStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t IspI2cAddrStrap                                   :1          ; //Bits :[0:0], initial value: 0x0. Isp I2C Addr Strap
        uint32_t MipihI2cAddrStrap                                 :1          ; //Bits :[1:1], initial value: 0x0. Mipih I2c Addr Strap
        uint32_t JtagIcpStrap                                      :1          ; //Bits :[2:2], initial value: 0x0. Jtag Icp Strap
        uint32_t CrcBypassStrap                                    :1          ; //Bits :[3:3], initial value: 0x0. CRC Bypass Strap
        uint32_t SpiBootStrap                                      :1          ; //Bits :[4:4], initial value: 0x0. SPI Boot Strap
        uint32_t SafetyStrap                                       :1          ; //Bits :[5:5], initial value: 0x0. Safety Strap
        uint32_t MemRepairBypassStrap                              :1          ; //Bits :[6:6], initial value: 0x0. Mem Repair Bypass Strap
        uint32_t FlashSizeStrap                                    :2          ; //Bits :[7:8], initial value: 0x0. Flash Size Strap
        uint32_t FwStrap                                           :4          ; //Bits :[9:12], initial value: 0x0. FW Strap
        uint32_t CwDebugEnStrap                                    :1          ; //Bits :[13:13], initial value: 0x0. Cw Debug En Strap
        uint32_t FastUartStrap                                     :1          ; //Bits :[14:14], initial value: 0x0. Fast UART Strap
        uint32_t PllBypassOnBootStrap                              :1          ; //Bits :[15:15], initial value: 0x0. Pll Bypass on boot Strap
        uint32_t ForceDfuStrap                                     :1          ; //Bits :[16:16], initial value: 0x0. Force DFU Strap
        uint32_t Reserved                                          :15         ; //Bits :[17:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t IspI2cAddrStrap                                   :1          ; //Bits :[0:0], initial value: 0x0. Isp I2C Addr Strap
        uint32_t MipihI2cAddrStrap                                 :1          ; //Bits :[1:1], initial value: 0x0. Mipih I2c Addr Strap
        uint32_t JtagIcpStrap                                      :1          ; //Bits :[2:2], initial value: 0x0. Jtag Icp Strap
        uint32_t CrcBypassStrap                                    :1          ; //Bits :[3:3], initial value: 0x0. CRC Bypass Strap
        uint32_t SpiBootStrap                                      :1          ; //Bits :[4:4], initial value: 0x0. SPI Boot Strap
        uint32_t SafetyStrap                                       :1          ; //Bits :[5:5], initial value: 0x0. Safety Strap
        uint32_t MemRepairBypassStrap                              :1          ; //Bits :[6:6], initial value: 0x0. Mem Repair Bypass Strap
        uint32_t FlashSizeStrap                                    :2          ; //Bits :[7:8], initial value: 0x0. Flash Size Strap
        uint32_t FwStrap                                           :4          ; //Bits :[9:12], initial value: 0x0. FW Strap
        uint32_t CwDebugEnStrap                                    :1          ; //Bits :[13:13], initial value: 0x0. Cw Debug En Strap
        uint32_t FastUartStrap                                     :1          ; //Bits :[14:14], initial value: 0x0. Fast UART Strap
        uint32_t PllBypassOnBootStrap                              :1          ; //Bits :[15:15], initial value: 0x0. Pll Bypass on boot Strap
        uint32_t ForceDfuStrap                                     :1          ; //Bits :[16:16], initial value: 0x0. Force DFU Strap
        uint32_t Reserved                                          :15         ; //Bits :[17:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrPinstrapStatus, TRegCsrPinstrapStatus, *PTRegCsrPinstrapStatus;                                //0x12600

//Interrupt 0  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt0Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt0Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt0 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt0Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt0Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt0 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt0Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt0Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt0 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt0Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt0Control, TRegCsrLcpInterrupt0Control, *PTRegCsrLcpInterrupt0Control;                                //0x12604

//Interrupt 1  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt1Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt1Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt1 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt1Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt1Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt1 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt1Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt1Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt1 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt1Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt1Control, TRegCsrLcpInterrupt1Control, *PTRegCsrLcpInterrupt1Control;                                //0x12608

//Interrupt 2  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt2Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt2Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt2 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt2Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt2Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt2 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt2Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt2Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt2 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt2Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt2Control, TRegCsrLcpInterrupt2Control, *PTRegCsrLcpInterrupt2Control;                                //0x1260C

//Interrupt 3  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt3Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt3Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt3 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt3Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt3Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt3 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt3Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt3Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt3 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt3Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt3Control, TRegCsrLcpInterrupt3Control, *PTRegCsrLcpInterrupt3Control;                                //0x12610

//Interrupt 4  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt4Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt4Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt4 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt4Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt4Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt4 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt4Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt4Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt4 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt4Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt4Control, TRegCsrLcpInterrupt4Control, *PTRegCsrLcpInterrupt4Control;                                //0x12614

//Interrupt 5  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt5Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt5Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt5 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt5Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt5Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt5 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt5Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt5Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt5 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt5Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt5Control, TRegCsrLcpInterrupt5Control, *PTRegCsrLcpInterrupt5Control;                                //0x12618

//Interrupt 6  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt6Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt6Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt6 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt6Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt6Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt6 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt6Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt6Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt6 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt6Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt6Control, TRegCsrLcpInterrupt6Control, *PTRegCsrLcpInterrupt6Control;                                //0x1261C

//Interrupt 7  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt7Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt7Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt7 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt7Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt7Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt7 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt7Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt7Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt7 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt7Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt7Control, TRegCsrLcpInterrupt7Control, *PTRegCsrLcpInterrupt7Control;                                //0x12620

//Interrupt 8  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt8Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt8Type                                    :2          ; //Bits :[0:1], initial value: 0x0. Interrupt8 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt8Period                                  :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt8Type                                    :2          ; //Bits :[0:1], initial value: 0x0. Interrupt8 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt8Period                                  :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt8Type                                    :2          ; //Bits :[0:1], initial value: 0x0. Interrupt8 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt8Period                                  :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt8Control, TRegCsrLcpInterrupt8Control, *PTRegCsrLcpInterrupt8Control;                                //0x12624

//Interrupt 9  type and period in multiple of 32 lcpclk.
//initial value: 0x202
typedef union __RegCsrLcpInterrupt9Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt9Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt9 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt9Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt9Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt9 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt9Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt9Type                                    :2          ; //Bits :[0:1], initial value: 0x2. Interrupt9 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt9Period                                  :8          ; //Bits :[8:15], initial value: 0x2. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt9Control, TRegCsrLcpInterrupt9Control, *PTRegCsrLcpInterrupt9Control;                                //0x12628

//Interrupt 10  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt10Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt10Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt10 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt10Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt10Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt10 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt10Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt10Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt10 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt10Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt10Control, TRegCsrLcpInterrupt10Control, *PTRegCsrLcpInterrupt10Control;                                //0x1262C

//Interrupt 11  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt11Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt11Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt11 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt11Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt11Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt11 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt11Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt11Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt11 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt11Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt11Control, TRegCsrLcpInterrupt11Control, *PTRegCsrLcpInterrupt11Control;                                //0x12630

//Interrupt 12  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt12Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt12Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt12 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt12Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt12Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt12 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt12Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt12Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt12 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt12Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt12Control, TRegCsrLcpInterrupt12Control, *PTRegCsrLcpInterrupt12Control;                                //0x12634

//Interrupt 13  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt13Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt13Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt13 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt13Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt13Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt13 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt13Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt13Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt13 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt13Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt13Control, TRegCsrLcpInterrupt13Control, *PTRegCsrLcpInterrupt13Control;                                //0x12638

//Interrupt 14  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt14Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt14Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt14 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt14Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt14Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt14 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt14Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt14Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt14 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt14Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt14Control, TRegCsrLcpInterrupt14Control, *PTRegCsrLcpInterrupt14Control;                                //0x1263C

//Interrupt 15  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt15Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt15Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt15 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt15Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt15Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt15 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt15Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt15Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt15 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt15Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt15Control, TRegCsrLcpInterrupt15Control, *PTRegCsrLcpInterrupt15Control;                                //0x12640

//Interrupt 16  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt16Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt16Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt16 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt16Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt16Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt16 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt16Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt16Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt16 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt16Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt16Control, TRegCsrLcpInterrupt16Control, *PTRegCsrLcpInterrupt16Control;                                //0x12644

//Interrupt 17  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt17Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt17Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt17 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt17Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt17Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt17 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt17Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt17Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt17 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt17Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt17Control, TRegCsrLcpInterrupt17Control, *PTRegCsrLcpInterrupt17Control;                                //0x12648

//Interrupt 18  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt18Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt18Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt18 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt18Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt18Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt18 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt18Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt18Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt18 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt18Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt18Control, TRegCsrLcpInterrupt18Control, *PTRegCsrLcpInterrupt18Control;                                //0x1264C

//Interrupt 19  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt19Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt19Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt19 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt19Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt19Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt19 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt19Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt19Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt19 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt19Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt19Control, TRegCsrLcpInterrupt19Control, *PTRegCsrLcpInterrupt19Control;                                //0x12650

//Interrupt 20  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt20Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt20Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt20 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt20Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt20Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt20 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt20Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt20Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt20 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt20Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt20Control, TRegCsrLcpInterrupt20Control, *PTRegCsrLcpInterrupt20Control;                                //0x12654

//Interrupt 21  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt21Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt21Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt21 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt21Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt21Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt21 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt21Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt21Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt21 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt21Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt21Control, TRegCsrLcpInterrupt21Control, *PTRegCsrLcpInterrupt21Control;                                //0x12658

//Interrupt 22  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt22Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt22Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt22 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt22Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt22Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt22 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt22Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt22Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt22 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt22Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt22Control, TRegCsrLcpInterrupt22Control, *PTRegCsrLcpInterrupt22Control;                                //0x1265C

//Interrupt 23  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt23Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt23Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt23 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt23Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt23Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt23 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt23Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt23Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt23 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt23Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt23Control, TRegCsrLcpInterrupt23Control, *PTRegCsrLcpInterrupt23Control;                                //0x12660

//Interrupt 24  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt24Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt24Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt24 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt24Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt24Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt24 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt24Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt24Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt24 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt24Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt24Control, TRegCsrLcpInterrupt24Control, *PTRegCsrLcpInterrupt24Control;                                //0x12664

//Interrupt 25  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt25Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt25Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt25 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt25Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt25Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt25 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt25Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt25Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt25 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt25Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt25Control, TRegCsrLcpInterrupt25Control, *PTRegCsrLcpInterrupt25Control;                                //0x12668

//Interrupt 26  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt26Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt26Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt26 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt26Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt26Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt26 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt26Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt26Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt26 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt26Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt26Control, TRegCsrLcpInterrupt26Control, *PTRegCsrLcpInterrupt26Control;                                //0x1266C

//Interrupt 27  type and period in multiple of 32 lcpclk.
//initial value: 0x0
typedef union __RegCsrLcpInterrupt27Control{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Interrupt27Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt27 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt27Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Interrupt27Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt27 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt27Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Interrupt27Type                                   :2          ; //Bits :[0:1], initial value: 0x0. Interrupt27 Type. 00-Edge. 01-Level. 10-Periodic.11-reserved
        uint32_t Reserved0                                         :6          ; //Bits :[2:7], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
        uint32_t Interrupt27Period                                 :8          ; //Bits :[8:15], initial value: 0x0. Periodic edge interrupt in multiple of 32 cycles
        uint32_t Reserved1                                         :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpInterrupt27Control, TRegCsrLcpInterrupt27Control, *PTRegCsrLcpInterrupt27Control;                                //0x12670

//CAMERA A I2C and PDOWN, RCLK , VSYNC IO Strength control.
//initial value: 0x0
typedef union __RegCsrCameraAIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
     } fields_rmw; //for non-shadowed register
} RegCsrCameraAIoStrengthControl, TRegCsrCameraAIoStrengthControl, *PTRegCsrCameraAIoStrengthControl;                                //0x12700

//CAMERA B I2C and PDOWN, RCLK , VSYNC IO Strength control.
//initial value: 0x0
typedef union __RegCsrCameraBIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCameraBIoStrengthControl, TRegCsrCameraBIoStrengthControl, *PTRegCsrCameraBIoStrengthControl;                                //0x12704

//CAMERA M I2C and PDOWN, RCLK , VSYNC IO Strength control.
//initial value: 0x0
typedef union __RegCsrCameraMIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCameraMIoStrengthControl, TRegCsrCameraMIoStrengthControl, *PTRegCsrCameraMIoStrengthControl;                                //0x12708

//CAMERA Y I2C and PDOWN, RCLK , VSYNC IO Strength control.
//initial value: 0x0
typedef union __RegCsrCameraYIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :12         ; //Bits :[0:11], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCameraYIoStrengthControl, TRegCsrCameraYIoStrengthControl, *PTRegCsrCameraYIoStrengthControl;                                //0x1270C

//CAMERA Z I2C and PDOWN, RCLK , VSYNC IO Strength control.
//initial value: 0x0
typedef union __RegCsrCameraZIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :16         ; //Bits :[0:15], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :16         ; //Bits :[0:15], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :16         ; //Bits :[0:15], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCameraZIoStrengthControl, TRegCsrCameraZIoStrengthControl, *PTRegCsrCameraZIoStrengthControl;                                //0x12710

//CAMERA H I2C and PDOWN, RCLK , VSYNC IO Strength control.
//initial value: 0x0
typedef union __RegCsrCameraHIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :4          ; //Bits :[0:3], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :4          ; //Bits :[0:3], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :4          ; //Bits :[0:3], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrCameraHIoStrengthControl, TRegCsrCameraHIoStrengthControl, *PTRegCsrCameraHIoStrengthControl;                                //0x12714

//GPIO Strength control.
//initial value: 0x0
typedef union __RegCsrGpioIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :28         ; //Bits :[0:27], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :28         ; //Bits :[0:27], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :28         ; //Bits :[0:27], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrGpioIoStrengthControl, TRegCsrGpioIoStrengthControl, *PTRegCsrGpioIoStrengthControl;                                //0x12718

//EGPIO Strength control.
//initial value: 0x0
typedef union __RegCsrEgpioIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :26         ; //Bits :[0:25], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :26         ; //Bits :[0:25], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :26         ; //Bits :[0:25], initial value: 0x0. 2 BIT DS Control
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrEgpioIoStrengthControl, TRegCsrEgpioIoStrengthControl, *PTRegCsrEgpioIoStrengthControl;                                //0x1271C

//SPI Strength control.
//initial value: 0x155
typedef union __RegCsrSpiIoStrengthControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitDsControl                                      :10         ; //Bits :[0:9], initial value: 0x155. 2 BIT DS Control
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t BitDsControl                                      :10         ; //Bits :[0:9], initial value: 0x155. 2 BIT DS Control
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t BitDsControl                                      :10         ; //Bits :[0:9], initial value: 0x155. 2 BIT DS Control
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrSpiIoStrengthControl, TRegCsrSpiIoStrengthControl, *PTRegCsrSpiIoStrengthControl;                                //0x12720

//Controls the DFU pin and DFU pin data output
//initial value: 0x0
typedef union __RegCsrDfuControlStatus{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DfuDir                                            :1          ; //Bits :[0:0], initial value: 0x0. Direction of DFU pin. set 1 to configure as output and 0 as input
        uint32_t DfuDataOut                                        :1          ; //Bits :[1:1], initial value: 0x0. When DFU pin is set as output DFU data is driven on DFU Pin
        uint32_t DfuDataIn                                         :1          ; //Bits :[2:2], initial value: 0x0. WHen DFU pin is set as input DFU pin data is captured in DFU_DATA_IN
        uint32_t Reserved3                                         :1          ; //Bits :[3:3], initial value: 0x0 Reserved.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t DfuDir                                            :1          ; //Bits :[0:0], initial value: 0x0. Direction of DFU pin. set 1 to configure as output and 0 as input
        uint32_t DfuDataOut                                        :1          ; //Bits :[1:1], initial value: 0x0. When DFU pin is set as output DFU data is driven on DFU Pin
        uint32_t DfuDataIn                                         :1          ; //Bits :[2:2], initial value: 0x0. WHen DFU pin is set as input DFU pin data is captured in DFU_DATA_IN
        uint32_t Reserved3                                         :1          ; //Bits :[3:3], initial value: 0x0 Reserved.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t DfuDir                                            :1          ; //Bits :[0:0], initial value: 0x0. Direction of DFU pin. set 1 to configure as output and 0 as input
        uint32_t DfuDataOut                                        :1          ; //Bits :[1:1], initial value: 0x0. When DFU pin is set as output DFU data is driven on DFU Pin
        uint32_t DfuDataIn                                         :1          ; //Bits :[2:2], initial value: 0x0. WHen DFU pin is set as input DFU pin data is captured in DFU_DATA_IN
        uint32_t Reserved3                                         :1          ; //Bits :[3:3], initial value: 0x0 Reserved.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrDfuControlStatus, TRegCsrDfuControlStatus, *PTRegCsrDfuControlStatus;                                //0x12724

//If set LED is forced to be on
//initial value: 0x0
typedef union __RegCsrForceLedOn{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceLedOn                                        :1          ; //Bits :[0:0], initial value: 0x0. If this bit is set, LED is forced to be on
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t ForceLedOn                                        :1          ; //Bits :[0:0], initial value: 0x0. If this bit is set, LED is forced to be on
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t ForceLedOn                                        :1          ; //Bits :[0:0], initial value: 0x0. If this bit is set, LED is forced to be on
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrForceLedOn, TRegCsrForceLedOn, *PTRegCsrForceLedOn;                                //0x12728

//IRAM BANK and DRAM BANK Shutdown
//initial value: 0x0
typedef union __RegCsrLcpIramDramShutdown{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Iram0Sd                                           :2          ; //Bits :[0:1], initial value: 0x0. If this bits are set, IRAM0 banks are shutdown
        uint32_t Iram1Sd                                           :2          ; //Bits :[2:3], initial value: 0x0. If this bits are set, IRAM1 banks are shutdown
        uint32_t Dram0Sd                                           :4          ; //Bits :[4:7], initial value: 0x0. If this bits are set, DRAM0 banks are shutdown
        uint32_t Dram1Sd                                           :4          ; //Bits :[8:11], initial value: 0x0. If this bits are set, DRAM1 banks are shutdown
        uint32_t Pdebugenable                                      :1          ; //Bits :[12:12], initial value: 0x0. If this bits are set, DRAM1 banks are shutdown
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_read;
    struct {
        uint32_t Iram0Sd                                           :2          ; //Bits :[0:1], initial value: 0x0. If this bits are set, IRAM0 banks are shutdown
        uint32_t Iram1Sd                                           :2          ; //Bits :[2:3], initial value: 0x0. If this bits are set, IRAM1 banks are shutdown
        uint32_t Dram0Sd                                           :4          ; //Bits :[4:7], initial value: 0x0. If this bits are set, DRAM0 banks are shutdown
        uint32_t Dram1Sd                                           :4          ; //Bits :[8:11], initial value: 0x0. If this bits are set, DRAM1 banks are shutdown
        uint32_t Pdebugenable                                      :1          ; //Bits :[12:12], initial value: 0x0. If this bits are set, DRAM1 banks are shutdown
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_write;
    struct {
        uint32_t Iram0Sd                                           :2          ; //Bits :[0:1], initial value: 0x0. If this bits are set, IRAM0 banks are shutdown
        uint32_t Iram1Sd                                           :2          ; //Bits :[2:3], initial value: 0x0. If this bits are set, IRAM1 banks are shutdown
        uint32_t Dram0Sd                                           :4          ; //Bits :[4:7], initial value: 0x0. If this bits are set, DRAM0 banks are shutdown
        uint32_t Dram1Sd                                           :4          ; //Bits :[8:11], initial value: 0x0. If this bits are set, DRAM1 banks are shutdown
        uint32_t Pdebugenable                                      :1          ; //Bits :[12:12], initial value: 0x0. If this bits are set, DRAM1 banks are shutdown
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read returns 0's.
     } fields_rmw; //for non-shadowed register
} RegCsrLcpIramDramShutdown, TRegCsrLcpIramDramShutdown, *PTRegCsrLcpIramDramShutdown;                                //0x12800

//IO Schmitt Trigger control.
//initial value: 0x00FF
typedef union __RegCsrIoSchmittTriggerControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BitSchmittTriggerControlFor16IoGroups             :32         ; //Bits :[0:31], initial value: 0xFF. 2 BIT schmitt trigger controlf ro 16 IO groups {8*GPIO,  dfu, ld_err, spi_miso TP,CW, vsync, sda,scl}
     } fields_read;
    struct {
        uint32_t BitSchmittTriggerControlFor16IoGroups             :32         ; //Bits :[0:31], initial value: 0xFF. 2 BIT schmitt trigger controlf ro 16 IO groups {8*GPIO,  dfu, ld_err, spi_miso TP,CW, vsync, sda,scl}
     } fields_write;
    struct {
        uint32_t BitSchmittTriggerControlFor16IoGroups             :32         ; //Bits :[0:31], initial value: 0xFF. 2 BIT schmitt trigger controlf ro 16 IO groups {8*GPIO,  dfu, ld_err, spi_miso TP,CW, vsync, sda,scl}
     } fields_rmw; //for non-shadowed register
} RegCsrIoSchmittTriggerControl, TRegCsrIoSchmittTriggerControl, *PTRegCsrIoSchmittTriggerControl;                                //0x1272C

//##############################################################
//                      imu_registers area
//##############################################################
//Control bits for the I2C Slave block
//initial value: 0x00000000
typedef union __RegImuImuI2cSlaveControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SlaveAddress                                      :7          ; //Bits :[0:6], initial value: 0x0. I2C 7 bit slave address
        uint32_t Reserved1                                         :1          ; //Bits :[7:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cDebounceLength                                 :3          ; //Bits :[8:10], initial value: 0x0. I2C debounce length
        uint32_t Reserved2                                         :1          ; //Bits :[11:11], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cDataDelay                                      :3          ; //Bits :[12:14], initial value: 0x0. I2C data delay
        uint32_t Reserved3                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cClockDelay                                     :3          ; //Bits :[16:18], initial value: 0x0. I2C clock delay
        uint32_t Reserved4                                         :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SlaveAddress                                      :7          ; //Bits :[0:6], initial value: 0x0. I2C 7 bit slave address
        uint32_t Reserved1                                         :1          ; //Bits :[7:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cDebounceLength                                 :3          ; //Bits :[8:10], initial value: 0x0. I2C debounce length
        uint32_t Reserved2                                         :1          ; //Bits :[11:11], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cDataDelay                                      :3          ; //Bits :[12:14], initial value: 0x0. I2C data delay
        uint32_t Reserved3                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cClockDelay                                     :3          ; //Bits :[16:18], initial value: 0x0. I2C clock delay
        uint32_t Reserved4                                         :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SlaveAddress                                      :7          ; //Bits :[0:6], initial value: 0x0. I2C 7 bit slave address
        uint32_t Reserved1                                         :1          ; //Bits :[7:7], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cDebounceLength                                 :3          ; //Bits :[8:10], initial value: 0x0. I2C debounce length
        uint32_t Reserved2                                         :1          ; //Bits :[11:11], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cDataDelay                                      :3          ; //Bits :[12:14], initial value: 0x0. I2C data delay
        uint32_t Reserved3                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t I2cClockDelay                                     :3          ; //Bits :[16:18], initial value: 0x0. I2C clock delay
        uint32_t Reserved4                                         :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuI2cSlaveControl, TRegImuImuI2cSlaveControl, *PTRegImuImuI2cSlaveControl;                                //0x11C00

//Indicates if the I2C or the Tensilisa are accessing the common registers
//initial value: 0x00000000
typedef union __RegImuImuFifoOwnership{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FifoOwner                                         :1          ; //Bits :[0:0], initial value: 0x0. 0 - Tensilica is owner; 1 - I2C is owner
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t FifoOwner                                         :1          ; //Bits :[0:0], initial value: 0x0. 0 - Tensilica is owner; 1 - I2C is owner
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t FifoOwner                                         :1          ; //Bits :[0:0], initial value: 0x0. 0 - Tensilica is owner; 1 - I2C is owner
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuFifoOwnership, TRegImuImuFifoOwnership, *PTRegImuImuFifoOwnership;                                //0x11C04

//Control the reset and clock for the IMU and I2C
//initial value: 0x00000000
typedef union __RegImuImuClockAndReset{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ImuReset                                          :1          ; //Bits :[0:0], initial value: 0x0. Reset the entire IMU block, including the I2C, active high
        uint32_t ImuClockDisable                                   :1          ; //Bits :[1:1], initial value: 0x0. This bit disables both sclk and pclk to the entire IMU block
        uint32_t I2cReset                                          :1          ; //Bits :[2:2], initial value: 0x0. Reset the I2C block, active high
        uint32_t I2cClockDisable                                   :1          ; //Bits :[3:3], initial value: 0x0. This bit disables pclk to the I2C
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t ImuReset                                          :1          ; //Bits :[0:0], initial value: 0x0. Reset the entire IMU block, including the I2C, active high
        uint32_t ImuClockDisable                                   :1          ; //Bits :[1:1], initial value: 0x0. This bit disables both sclk and pclk to the entire IMU block
        uint32_t I2cReset                                          :1          ; //Bits :[2:2], initial value: 0x0. Reset the I2C block, active high
        uint32_t I2cClockDisable                                   :1          ; //Bits :[3:3], initial value: 0x0. This bit disables pclk to the I2C
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t ImuReset                                          :1          ; //Bits :[0:0], initial value: 0x0. Reset the entire IMU block, including the I2C, active high
        uint32_t ImuClockDisable                                   :1          ; //Bits :[1:1], initial value: 0x0. This bit disables both sclk and pclk to the entire IMU block
        uint32_t I2cReset                                          :1          ; //Bits :[2:2], initial value: 0x0. Reset the I2C block, active high
        uint32_t I2cClockDisable                                   :1          ; //Bits :[3:3], initial value: 0x0. This bit disables pclk to the I2C
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuClockAndReset, TRegImuImuClockAndReset, *PTRegImuImuClockAndReset;                                //0x11C08

//Next state and Current state fields
//initial value: 0x00000000
typedef union __RegImuImuPowerState{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CurrentState                                      :1          ; //Bits :[0:0], initial value: 0x0. 0 indicates IDLE state, 1 indicates ACTIVE state
        uint32_t NextState                                         :1          ; //Bits :[1:1], initial value: 0x0. 0 indicates IDLE state, 1 indicates ACTIVE state
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t CurrentState                                      :1          ; //Bits :[0:0], initial value: 0x0. 0 indicates IDLE state, 1 indicates ACTIVE state
        uint32_t NextState                                         :1          ; //Bits :[1:1], initial value: 0x0. 0 indicates IDLE state, 1 indicates ACTIVE state
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t CurrentState                                      :1          ; //Bits :[0:0], initial value: 0x0. 0 indicates IDLE state, 1 indicates ACTIVE state
        uint32_t NextState                                         :1          ; //Bits :[1:1], initial value: 0x0. 0 indicates IDLE state, 1 indicates ACTIVE state
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuPowerState, TRegImuImuPowerState, *PTRegImuImuPowerState;                                //0x11C20

//This value is written to Timestamp counter when ACTIVE mode is entered.
//initial value: 0x00000000
typedef union __RegImuImuTimestampStartCnt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TimestampStartCnt                                 :32         ; //Bits :[0:31], initial value: 0x0. This value is written to Timestamp counter when ACTIVE mode is entered.
     } fields_read;
    struct {
        uint32_t TimestampStartCnt                                 :32         ; //Bits :[0:31], initial value: 0x0. This value is written to Timestamp counter when ACTIVE mode is entered.
     } fields_write;
    struct {
        uint32_t TimestampStartCnt                                 :32         ; //Bits :[0:31], initial value: 0x0. This value is written to Timestamp counter when ACTIVE mode is entered.
     } fields_rmw; //for non-shadowed register
} RegImuImuTimestampStartCnt, TRegImuImuTimestampStartCnt, *PTRegImuImuTimestampStartCnt;                                //0x11C24

//The number of sclk cycles between incrementing Timestamp counter
//initial value: 0x00000001
typedef union __RegImuImuTimestampFreqCnt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FreqCnt                                           :20         ; //Bits :[0:19], initial value: 0x1. The number of sclk cycles between incrementing Timestamp counter
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t FreqCnt                                           :20         ; //Bits :[0:19], initial value: 0x1. The number of sclk cycles between incrementing Timestamp counter
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t FreqCnt                                           :20         ; //Bits :[0:19], initial value: 0x1. The number of sclk cycles between incrementing Timestamp counter
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuTimestampFreqCnt, TRegImuImuTimestampFreqCnt, *PTRegImuImuTimestampFreqCnt;                                //0x11C28

//Two levels of correction to get accurate TimeStamp
//initial value: 0x00000000
typedef union __RegImuImuTimestampCorrCnt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FirstCorrCnt                                      :8          ; //Bits :[0:7], initial value: 0x0. The number of TimeStamp increments before correction
        uint32_t SecondCorrCnt                                     :8          ; //Bits :[8:15], initial value: 0x0. The number of first corrections before second correction
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t FirstCorrCnt                                      :8          ; //Bits :[0:7], initial value: 0x0. The number of TimeStamp increments before correction
        uint32_t SecondCorrCnt                                     :8          ; //Bits :[8:15], initial value: 0x0. The number of first corrections before second correction
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t FirstCorrCnt                                      :8          ; //Bits :[0:7], initial value: 0x0. The number of TimeStamp increments before correction
        uint32_t SecondCorrCnt                                     :8          ; //Bits :[8:15], initial value: 0x0. The number of first corrections before second correction
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuTimestampCorrCnt, TRegImuImuTimestampCorrCnt, *PTRegImuImuTimestampCorrCnt;                                //0x11C2C

//Read TimeStamp value
//initial value: 0x00000000
typedef union __RegImuImuTimestampCnt{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TimestampValue                                    :32         ; //Bits :[0:31], initial value: 0x0. TimeStamp Value
     } fields_read;
    struct {
        uint32_t TimestampValue                                    :32         ; //Bits :[0:31], initial value: 0x0. TimeStamp Value
     } fields_rmw; //for non-shadowed register
} RegImuImuTimestampCnt, TRegImuImuTimestampCnt, *PTRegImuImuTimestampCnt;                                //0x11C30

//The FIFO fill level that will cause an interrupt.
//initial value: 0x00000030
typedef union __RegImuImuFifoThreshold{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FifoThreshold                                     :7          ; //Bits :[0:6], initial value: 0x30. FIFO fill level that will cause an interrupt.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t FifoThreshold                                     :7          ; //Bits :[0:6], initial value: 0x30. FIFO fill level that will cause an interrupt.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t FifoThreshold                                     :7          ; //Bits :[0:6], initial value: 0x30. FIFO fill level that will cause an interrupt.
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuFifoThreshold, TRegImuImuFifoThreshold, *PTRegImuImuFifoThreshold;                                //0x11C3C

//Read FIFO entry, Event Info
//initial value: 0x00000000
typedef union __RegImuImuReadFifo1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FifoEventCount                                    :12         ; //Bits :[0:11], initial value: 0x0. FIFO Event Count
        uint32_t FifoEventId                                       :4          ; //Bits :[12:15], initial value: 0x0. FIFO Event Source ID
        uint32_t FifoEntries                                       :8          ; //Bits :[16:23], initial value: 0x0. Number of entries currently in the FIFO
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t FifoEventCount                                    :12         ; //Bits :[0:11], initial value: 0x0. FIFO Event Count
        uint32_t FifoEventId                                       :4          ; //Bits :[12:15], initial value: 0x0. FIFO Event Source ID
        uint32_t FifoEntries                                       :8          ; //Bits :[16:23], initial value: 0x0. Number of entries currently in the FIFO
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuReadFifo1, TRegImuImuReadFifo1, *PTRegImuImuReadFifo1;                                //0x11C40

//Read FIFO entry, TimeStamp value
//initial value: 0x00000000
typedef union __RegImuImuReadFifo2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FifoTimestampValue                                :32         ; //Bits :[0:31], initial value: 0x0. FIFO TimeStamp Value
     } fields_read;
    struct {
        uint32_t FifoTimestampValue                                :32         ; //Bits :[0:31], initial value: 0x0. FIFO TimeStamp Value
     } fields_rmw; //for non-shadowed register
} RegImuImuReadFifo2, TRegImuImuReadFifo2, *PTRegImuImuReadFifo2;                                //0x11C44

//Description of Event 1
//initial value: 0x00000011
typedef union __RegImuImuEvent1Config{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x1. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x1. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x1. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuEvent1Config, TRegImuImuEvent1Config, *PTRegImuImuEvent1Config;                                //0x11C60

//Description of Event 2
//initial value: 0x00000012
typedef union __RegImuImuEvent2Config{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x2. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x2. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x2. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuEvent2Config, TRegImuImuEvent2Config, *PTRegImuImuEvent2Config;                                //0x11C64

//Description of Event 3
//initial value: 0x00000013
typedef union __RegImuImuEvent3Config{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x3. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x3. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x3. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuEvent3Config, TRegImuImuEvent3Config, *PTRegImuImuEvent3Config;                                //0x11C68

//Description of Event 4
//initial value: 0x00000014
typedef union __RegImuImuEvent4Config{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x4. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x4. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x4. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuEvent4Config, TRegImuImuEvent4Config, *PTRegImuImuEvent4Config;                                //0x11C6C

//Description of Event 5
//initial value: 0x00000015
typedef union __RegImuImuEvent5Config{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x5. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x5. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x5. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuEvent5Config, TRegImuImuEvent5Config, *PTRegImuImuEvent5Config;                                //0x11C70

//Description of Event 6
//initial value: 0x00000016
typedef union __RegImuImuEvent6Config{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x6. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x6. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x6. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuEvent6Config, TRegImuImuEvent6Config, *PTRegImuImuEvent6Config;                                //0x11C74

//Description of Event 7
//initial value: 0x00000017
typedef union __RegImuImuEvent7Config{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x7. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x7. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x7. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuEvent7Config, TRegImuImuEvent7Config, *PTRegImuImuEvent7Config;                                //0x11C78

//Description of Event 8
//initial value: 0x00000018
typedef union __RegImuImuEvent8Config{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x8. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x8. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SourceId                                          :4          ; //Bits :[0:3], initial value: 0x8. Source ID assigned to this event, default is Event ID.
        uint32_t EdgeDetect                                        :2          ; //Bits :[4:5], initial value: 0x1. 00 - not used; 01 - rising edge detect; 10 - falling edge detect; 11 - both edges, default rising edge.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuEvent8Config, TRegImuImuEvent8Config, *PTRegImuImuEvent8Config;                                //0x11C7C

//Enable for the interrupts
//initial value: 0x00000000
typedef union __RegImuImuInterruptEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EnableEventInterrupts                             :8          ; //Bits :[0:7], initial value: 0x0. Enable Event interrupt, one bit per event
        uint32_t EnableFifoThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Enable FIFO Threshold interrupt
        uint32_t EnableFifoFullInterrupt                           :1          ; //Bits :[9:9], initial value: 0x0. Enable FIFO full interrupt
        uint32_t EnableFifoOverflowInterrupt                       :1          ; //Bits :[10:10], initial value: 0x0. Enable FIFO overflow interrupt
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t EnableEventInterrupts                             :8          ; //Bits :[0:7], initial value: 0x0. Enable Event interrupt, one bit per event
        uint32_t EnableFifoThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Enable FIFO Threshold interrupt
        uint32_t EnableFifoFullInterrupt                           :1          ; //Bits :[9:9], initial value: 0x0. Enable FIFO full interrupt
        uint32_t EnableFifoOverflowInterrupt                       :1          ; //Bits :[10:10], initial value: 0x0. Enable FIFO overflow interrupt
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t EnableEventInterrupts                             :8          ; //Bits :[0:7], initial value: 0x0. Enable Event interrupt, one bit per event
        uint32_t EnableFifoThresholdInterrupt                      :1          ; //Bits :[8:8], initial value: 0x0. Enable FIFO Threshold interrupt
        uint32_t EnableFifoFullInterrupt                           :1          ; //Bits :[9:9], initial value: 0x0. Enable FIFO full interrupt
        uint32_t EnableFifoOverflowInterrupt                       :1          ; //Bits :[10:10], initial value: 0x0. Enable FIFO overflow interrupt
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuInterruptEnable, TRegImuImuInterruptEnable, *PTRegImuImuInterruptEnable;                                //0x11C80

//Holds the interrupt source information, individual bits are cleared with write of 1.
//initial value: 0x00000000
typedef union __RegImuImuInterruptStatus{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EventInterrupts                                   :8          ; //Bits :[0:7], initial value: 0x0. One interrupt bit for each event trigger
        uint32_t FifoThreshold                                     :1          ; //Bits :[8:8], initial value: 0x0. Interrupt for FIFO Threshold
        uint32_t FifoFull                                          :1          ; //Bits :[9:9], initial value: 0x0. Interrupt for FIFO full
        uint32_t FifoOverflow                                      :1          ; //Bits :[10:10], initial value: 0x0. Interrupt for FIFO overflow
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t EventInterrupts                                   :8          ; //Bits :[0:7], initial value: 0x0. One interrupt bit for each event trigger
        uint32_t FifoThreshold                                     :1          ; //Bits :[8:8], initial value: 0x0. Interrupt for FIFO Threshold
        uint32_t FifoFull                                          :1          ; //Bits :[9:9], initial value: 0x0. Interrupt for FIFO full
        uint32_t FifoOverflow                                      :1          ; //Bits :[10:10], initial value: 0x0. Interrupt for FIFO overflow
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t EventInterrupts                                   :8          ; //Bits :[0:7], initial value: 0x0. One interrupt bit for each event trigger
        uint32_t FifoThreshold                                     :1          ; //Bits :[8:8], initial value: 0x0. Interrupt for FIFO Threshold
        uint32_t FifoFull                                          :1          ; //Bits :[9:9], initial value: 0x0. Interrupt for FIFO full
        uint32_t FifoOverflow                                      :1          ; //Bits :[10:10], initial value: 0x0. Interrupt for FIFO overflow
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegImuImuInterruptStatus, TRegImuImuInterruptStatus, *PTRegImuImuInterruptStatus;                                //0x11C84

//##############################################################
//                      ldi_registers area
//##############################################################
//module ID value
//initial value: 0x87654321
typedef union __RegLdiRegId{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ModuleId                                          :32         ; //Bits :[0:31], initial value: 0x87654321. module ID value
     } fields_read;
    struct {
        uint32_t ModuleId                                          :32         ; //Bits :[0:31], initial value: 0x87654321. module ID value
     } fields_rmw; //for non-shadowed register
} RegLdiRegId, TRegLdiRegId, *PTRegLdiRegId;                                //0x11800

//LD control registers 0
//initial value: 0x0
typedef union __RegLdiDriverCtl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regsprojgainstrobwidthl                           :4          ; //Bits :[0:3], initial value: 0x0. time of modstrob pulse (t2 in the timeing diagram) in pclk cycles count.
        uint32_t Regsprojgainidlebtwnstrobesl                      :3          ; //Bits :[4:6], initial value: 0x0. minimum time in pclk cycles between two adjacent strobes. If configured as 0, the strobe is implemented using pjclk gating, which means that two strobes (i.e. rising edges) can come at consecutive cycles.
        uint32_t Reserved                                          :1          ; //Bits :[7:7], initial value: 0x0.
        uint32_t Regsprojgainldonrisetostrobl                      :8          ; //Bits :[8:15], initial value: 0x0. Time in pclk cycles after LD_ON rise where no strobe is allowed (t1 in the timing diagram)
        uint32_t Regsprojgainldonfalltostrobl                      :8          ; //Bits :[16:23], initial value: 0x0. Time in pclk cycles after LD_ON fall where no strobe is allowed (t4 in the timing diagram)
        uint32_t Regsprojgainstrobtoldonrisel                      :8          ; //Bits :[24:31], initial value: 0x0. minimum time in pclk cycles after ld_on rising edge before a strobe edge is allowed
     } fields_read;
    struct {
        uint32_t Regsprojgainstrobwidthl                           :4          ; //Bits :[0:3], initial value: 0x0. time of modstrob pulse (t2 in the timeing diagram) in pclk cycles count.
        uint32_t Regsprojgainidlebtwnstrobesl                      :3          ; //Bits :[4:6], initial value: 0x0. minimum time in pclk cycles between two adjacent strobes. If configured as 0, the strobe is implemented using pjclk gating, which means that two strobes (i.e. rising edges) can come at consecutive cycles.
        uint32_t Reserved                                          :1          ; //Bits :[7:7], initial value: 0x0.
        uint32_t Regsprojgainldonrisetostrobl                      :8          ; //Bits :[8:15], initial value: 0x0. Time in pclk cycles after LD_ON rise where no strobe is allowed (t1 in the timing diagram)
        uint32_t Regsprojgainldonfalltostrobl                      :8          ; //Bits :[16:23], initial value: 0x0. Time in pclk cycles after LD_ON fall where no strobe is allowed (t4 in the timing diagram)
        uint32_t Regsprojgainstrobtoldonrisel                      :8          ; //Bits :[24:31], initial value: 0x0. minimum time in pclk cycles after ld_on rising edge before a strobe edge is allowed
     } fields_write;
    struct {
        uint32_t Regsprojgainstrobwidthl                           :4          ; //Bits :[0:3], initial value: 0x0. time of modstrob pulse (t2 in the timeing diagram) in pclk cycles count.
        uint32_t Regsprojgainidlebtwnstrobesl                      :3          ; //Bits :[4:6], initial value: 0x0. minimum time in pclk cycles between two adjacent strobes. If configured as 0, the strobe is implemented using pjclk gating, which means that two strobes (i.e. rising edges) can come at consecutive cycles.
        uint32_t Reserved                                          :1          ; //Bits :[7:7], initial value: 0x0.
        uint32_t Regsprojgainldonrisetostrobl                      :8          ; //Bits :[8:15], initial value: 0x0. Time in pclk cycles after LD_ON rise where no strobe is allowed (t1 in the timing diagram)
        uint32_t Regsprojgainldonfalltostrobl                      :8          ; //Bits :[16:23], initial value: 0x0. Time in pclk cycles after LD_ON fall where no strobe is allowed (t4 in the timing diagram)
        uint32_t Regsprojgainstrobtoldonrisel                      :8          ; //Bits :[24:31], initial value: 0x0. minimum time in pclk cycles after ld_on rising edge before a strobe edge is allowed
     } fields_rmw; //for non-shadowed register
} RegLdiDriverCtl0, TRegLdiDriverCtl0, *PTRegLdiDriverCtl0;                                //0x11804

//LD control registers 1
//initial value: 0x0
typedef union __RegLdiDriverCtl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regsprojgainstrobpoll                             :1          ; //Bits :[0:0], initial value: 0x0. Polarity of MODSTROB pin. 0:active high, 1:active low
        uint32_t Regsprojgainldoffrstgainl                         :1          ; //Bits :[1:1], initial value: 0x0. 1 – LD_ON fall resets gain.  0 – Gain is not reset by LD_ON fall.
        uint32_t Regsprojgainallowstrobatldoffl                    :1          ; //Bits :[2:2], initial value: 0x0. 0 - When LD_ON is low, the PI will still drive MODSIGN/STROB to match the actual gain to the required one.  1 – MODSIGN/STROB changing only when LD_ON is high
        uint32_t Regsprojgaindelaystrobel                          :1          ; //Bits :[3:3], initial value: 0x0. Select delay between MODSIGN change and MODSTROB pulse.  0: 1 cycle,  1: 2 cycles
        uint32_t Regsprojgainzerostrobcntl                         :2          ; //Bits :[4:5], initial value: 0x0. additional gain down strobes at end of cycle
        uint32_t Reserved2                                         :2          ; //Bits :[6:7], initial value: 0x0. reserved
        uint32_t Regsprojgainexcessgainl                           :8          ; //Bits :[8:15], initial value: 0x0. Threshold for excess gain error
        uint32_t Reserve3                                          :16         ; //Bits :[16:31], initial value: 0x0. reserved
     } fields_read;
    struct {
        uint32_t Regsprojgainstrobpoll                             :1          ; //Bits :[0:0], initial value: 0x0. Polarity of MODSTROB pin. 0:active high, 1:active low
        uint32_t Regsprojgainldoffrstgainl                         :1          ; //Bits :[1:1], initial value: 0x0. 1 – LD_ON fall resets gain.  0 – Gain is not reset by LD_ON fall.
        uint32_t Regsprojgainallowstrobatldoffl                    :1          ; //Bits :[2:2], initial value: 0x0. 0 - When LD_ON is low, the PI will still drive MODSIGN/STROB to match the actual gain to the required one.  1 – MODSIGN/STROB changing only when LD_ON is high
        uint32_t Regsprojgaindelaystrobel                          :1          ; //Bits :[3:3], initial value: 0x0. Select delay between MODSIGN change and MODSTROB pulse.  0: 1 cycle,  1: 2 cycles
        uint32_t Regsprojgainzerostrobcntl                         :2          ; //Bits :[4:5], initial value: 0x0. additional gain down strobes at end of cycle
        uint32_t Reserved2                                         :2          ; //Bits :[6:7], initial value: 0x0. reserved
        uint32_t Regsprojgainexcessgainl                           :8          ; //Bits :[8:15], initial value: 0x0. Threshold for excess gain error
        uint32_t Reserve3                                          :16         ; //Bits :[16:31], initial value: 0x0. reserved
     } fields_write;
    struct {
        uint32_t Regsprojgainstrobpoll                             :1          ; //Bits :[0:0], initial value: 0x0. Polarity of MODSTROB pin. 0:active high, 1:active low
        uint32_t Regsprojgainldoffrstgainl                         :1          ; //Bits :[1:1], initial value: 0x0. 1 – LD_ON fall resets gain.  0 – Gain is not reset by LD_ON fall.
        uint32_t Regsprojgainallowstrobatldoffl                    :1          ; //Bits :[2:2], initial value: 0x0. 0 - When LD_ON is low, the PI will still drive MODSIGN/STROB to match the actual gain to the required one.  1 – MODSIGN/STROB changing only when LD_ON is high
        uint32_t Regsprojgaindelaystrobel                          :1          ; //Bits :[3:3], initial value: 0x0. Select delay between MODSIGN change and MODSTROB pulse.  0: 1 cycle,  1: 2 cycles
        uint32_t Regsprojgainzerostrobcntl                         :2          ; //Bits :[4:5], initial value: 0x0. additional gain down strobes at end of cycle
        uint32_t Reserved2                                         :2          ; //Bits :[6:7], initial value: 0x0. reserved
        uint32_t Regsprojgainexcessgainl                           :8          ; //Bits :[8:15], initial value: 0x0. Threshold for excess gain error
        uint32_t Reserve3                                          :16         ; //Bits :[16:31], initial value: 0x0. reserved
     } fields_rmw; //for non-shadowed register
} RegLdiDriverCtl1, TRegLdiDriverCtl1, *PTRegLdiDriverCtl1;                                //0x11808

//module config
//initial value: 0x06861
typedef union __RegLdiCfg{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ApbLowFreq                                        :8          ; //Bits :[0:7], initial value: 0x61. APB low frequency limit, MHz
        uint32_t ApbHighFreq                                       :8          ; //Bits :[8:15], initial value: 0x68. APB high frequency limit, MHz
        uint32_t LdErrDebounceCnt                                  :10         ; //Bits :[16:25], initial value: 0x0. debounce ld_err cnt for LD_ON clear
        uint32_t Reserved                                          :5          ; //Bits :[26:30], initial value: 0x0.
        uint32_t Powersaveenable                                   :1          ; //Bits :[31:31], initial value: 0x0. enable auto-power save features
     } fields_read;
    struct {
        uint32_t ApbLowFreq                                        :8          ; //Bits :[0:7], initial value: 0x61. APB low frequency limit, MHz
        uint32_t ApbHighFreq                                       :8          ; //Bits :[8:15], initial value: 0x68. APB high frequency limit, MHz
        uint32_t LdErrDebounceCnt                                  :10         ; //Bits :[16:25], initial value: 0x0. debounce ld_err cnt for LD_ON clear
        uint32_t Reserved                                          :5          ; //Bits :[26:30], initial value: 0x0.
        uint32_t Powersaveenable                                   :1          ; //Bits :[31:31], initial value: 0x0. enable auto-power save features
     } fields_write;
    struct {
        uint32_t ApbLowFreq                                        :8          ; //Bits :[0:7], initial value: 0x61. APB low frequency limit, MHz
        uint32_t ApbHighFreq                                       :8          ; //Bits :[8:15], initial value: 0x68. APB high frequency limit, MHz
        uint32_t LdErrDebounceCnt                                  :10         ; //Bits :[16:25], initial value: 0x0. debounce ld_err cnt for LD_ON clear
        uint32_t Reserved                                          :5          ; //Bits :[26:30], initial value: 0x0.
        uint32_t Powersaveenable                                   :1          ; //Bits :[31:31], initial value: 0x0. enable auto-power save features
     } fields_rmw; //for non-shadowed register
} RegLdiCfg, TRegLdiCfg, *PTRegLdiCfg;                                //0x1180C

//module status
//initial value: 0x0
typedef union __RegLdiStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ApbFreq                                           :8          ; //Bits :[0:7], initial value: 0x0. current APB frequency, MHz
        uint32_t ApbClkError                                       :1          ; //Bits :[8:8], initial value: 0x0. APB clock error detected
        uint32_t LdErrActive                                       :1          ; //Bits :[9:9], initial value: 0x0. LD_ERR pin asserted
        uint32_t Triggerbusy                                       :1          ; //Bits :[10:10], initial value: 0x0. trigger block busy sending hsync pulses to LD gain block
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t ApbFreq                                           :8          ; //Bits :[0:7], initial value: 0x0. current APB frequency, MHz
        uint32_t ApbClkError                                       :1          ; //Bits :[8:8], initial value: 0x0. APB clock error detected
        uint32_t LdErrActive                                       :1          ; //Bits :[9:9], initial value: 0x0. LD_ERR pin asserted
        uint32_t Triggerbusy                                       :1          ; //Bits :[10:10], initial value: 0x0. trigger block busy sending hsync pulses to LD gain block
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegLdiStatus, TRegLdiStatus, *PTRegLdiStatus;                                //0x11810

//module control
//initial value: 0x0
typedef union __RegLdiSysCtl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Projen                                            :1          ; //Bits :[0:0], initial value: 0x0. enable LD logic
        uint32_t LdOn                                              :1          ; //Bits :[1:1], initial value: 0x0. LD_ON control bit, cleared by error conditions
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. reserved
     } fields_read;
    struct {
        uint32_t Projen                                            :1          ; //Bits :[0:0], initial value: 0x0. enable LD logic
        uint32_t LdOn                                              :1          ; //Bits :[1:1], initial value: 0x0. LD_ON control bit, cleared by error conditions
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. reserved
     } fields_write;
    struct {
        uint32_t Projen                                            :1          ; //Bits :[0:0], initial value: 0x0. enable LD logic
        uint32_t LdOn                                              :1          ; //Bits :[1:1], initial value: 0x0. LD_ON control bit, cleared by error conditions
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. reserved
     } fields_rmw; //for non-shadowed register
} RegLdiSysCtl, TRegLdiSysCtl, *PTRegLdiSysCtl;                                //0x11814

//interrupt enables
//initial value: 0x0
typedef union __RegLdiIrqEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AbpClkErrIrqEnable                                :1          ; //Bits :[0:0], initial value: 0x0. enable APB clock frequency error interrupt
        uint32_t LdErrIrqEnable                                    :1          ; //Bits :[1:1], initial value: 0x0. enable LD_ERR error interrupt
        uint32_t ErrtriggerbusyEnable                              :1          ; //Bits :[2:2], initial value: 0x0. enable vsync re-trigger interrupt
        uint32_t ErrretriggerintEnable                             :1          ; //Bits :[3:3], initial value: 0x0. enable gainlogic internal re-trigger while busy interrupt
        uint32_t ErrretriggerextEnable                             :1          ; //Bits :[4:4], initial value: 0x0. enable gainlogic external re-trigger while busy interrupt
        uint32_t ErrexcessgainEnable                               :1          ; //Bits :[5:5], initial value: 0x0. enable excess gain detect interrupt
        uint32_t Errbadclkref                                      :1          ; //Bits :[6:6], initial value: 0x0. enable bad clk_ref setting interrupt
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. reserved
     } fields_read;
    struct {
        uint32_t AbpClkErrIrqEnable                                :1          ; //Bits :[0:0], initial value: 0x0. enable APB clock frequency error interrupt
        uint32_t LdErrIrqEnable                                    :1          ; //Bits :[1:1], initial value: 0x0. enable LD_ERR error interrupt
        uint32_t ErrtriggerbusyEnable                              :1          ; //Bits :[2:2], initial value: 0x0. enable vsync re-trigger interrupt
        uint32_t ErrretriggerintEnable                             :1          ; //Bits :[3:3], initial value: 0x0. enable gainlogic internal re-trigger while busy interrupt
        uint32_t ErrretriggerextEnable                             :1          ; //Bits :[4:4], initial value: 0x0. enable gainlogic external re-trigger while busy interrupt
        uint32_t ErrexcessgainEnable                               :1          ; //Bits :[5:5], initial value: 0x0. enable excess gain detect interrupt
        uint32_t Errbadclkref                                      :1          ; //Bits :[6:6], initial value: 0x0. enable bad clk_ref setting interrupt
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. reserved
     } fields_write;
    struct {
        uint32_t AbpClkErrIrqEnable                                :1          ; //Bits :[0:0], initial value: 0x0. enable APB clock frequency error interrupt
        uint32_t LdErrIrqEnable                                    :1          ; //Bits :[1:1], initial value: 0x0. enable LD_ERR error interrupt
        uint32_t ErrtriggerbusyEnable                              :1          ; //Bits :[2:2], initial value: 0x0. enable vsync re-trigger interrupt
        uint32_t ErrretriggerintEnable                             :1          ; //Bits :[3:3], initial value: 0x0. enable gainlogic internal re-trigger while busy interrupt
        uint32_t ErrretriggerextEnable                             :1          ; //Bits :[4:4], initial value: 0x0. enable gainlogic external re-trigger while busy interrupt
        uint32_t ErrexcessgainEnable                               :1          ; //Bits :[5:5], initial value: 0x0. enable excess gain detect interrupt
        uint32_t Errbadclkref                                      :1          ; //Bits :[6:6], initial value: 0x0. enable bad clk_ref setting interrupt
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. reserved
     } fields_rmw; //for non-shadowed register
} RegLdiIrqEnable, TRegLdiIrqEnable, *PTRegLdiIrqEnable;                                //0x11818

//interrupt Status, write 1's to clear bits
//initial value: 0x0
typedef union __RegLdiIrqStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AbpClkErrIrq                                      :1          ; //Bits :[0:0], initial value: 0x0. APB clock frequency error interrupt, write 1 to clear
        uint32_t LdErrIrq                                          :1          ; //Bits :[1:1], initial value: 0x0. LD_ERR error interrupt, write 1 to clear
        uint32_t ErrtriggerbusyIrq                                 :1          ; //Bits :[2:2], initial value: 0x0. vsync re-trigger interrupt, trigger logic busy, write 1 to clear
        uint32_t ErrretriggerintIrq                                :1          ; //Bits :[3:3], initial value: 0x0. gainlogic internal re-trigger while busy interrupt, write 1 to clear
        uint32_t ErrretriggerextIrq                                :1          ; //Bits :[4:4], initial value: 0x0. gainlogic external re-trigger while busy interrupt, write 1 to clear
        uint32_t ErrexcessgainIrq                                  :1          ; //Bits :[5:5], initial value: 0x0. gainlogic excess gain interrupt, write 1 to clear
        uint32_t ErrbadclkrefIrq                                   :1          ; //Bits :[6:6], initial value: 0x0. bad clk_ref interrupt, write 1 to clear
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. reserved
     } fields_read;
    struct {
        uint32_t AbpClkErrIrq                                      :1          ; //Bits :[0:0], initial value: 0x0. APB clock frequency error interrupt, write 1 to clear
        uint32_t LdErrIrq                                          :1          ; //Bits :[1:1], initial value: 0x0. LD_ERR error interrupt, write 1 to clear
        uint32_t ErrtriggerbusyIrq                                 :1          ; //Bits :[2:2], initial value: 0x0. vsync re-trigger interrupt, trigger logic busy, write 1 to clear
        uint32_t ErrretriggerintIrq                                :1          ; //Bits :[3:3], initial value: 0x0. gainlogic internal re-trigger while busy interrupt, write 1 to clear
        uint32_t ErrretriggerextIrq                                :1          ; //Bits :[4:4], initial value: 0x0. gainlogic external re-trigger while busy interrupt, write 1 to clear
        uint32_t ErrexcessgainIrq                                  :1          ; //Bits :[5:5], initial value: 0x0. gainlogic excess gain interrupt, write 1 to clear
        uint32_t ErrbadclkrefIrq                                   :1          ; //Bits :[6:6], initial value: 0x0. bad clk_ref interrupt, write 1 to clear
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. reserved
     } fields_rmw; //for non-shadowed register
} RegLdiIrqStatus, TRegLdiIrqStatus, *PTRegLdiIrqStatus;                                //0x1181C

//LD_ERR IRQ debounce value
//initial value: 0x0
typedef union __RegLdiLdErrIrqCnt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LdErrIrqValue                                     :15         ; //Bits :[0:14], initial value: 0x0. debounce ld_err debounce count for IRQ trigger
        uint32_t Reserved                                          :17         ; //Bits :[15:31], initial value: 0x0. reserved
     } fields_read;
    struct {
        uint32_t LdErrIrqValue                                     :15         ; //Bits :[0:14], initial value: 0x0. debounce ld_err debounce count for IRQ trigger
        uint32_t Reserved                                          :17         ; //Bits :[15:31], initial value: 0x0. reserved
     } fields_write;
    struct {
        uint32_t LdErrIrqValue                                     :15         ; //Bits :[0:14], initial value: 0x0. debounce ld_err debounce count for IRQ trigger
        uint32_t Reserved                                          :17         ; //Bits :[15:31], initial value: 0x0. reserved
     } fields_rmw; //for non-shadowed register
} RegLdiLdErrIrqCnt, TRegLdiLdErrIrqCnt, *PTRegLdiLdErrIrqCnt;                                //0x11820

//memory address pointer, auto incrementing
//initial value: 0x0
typedef union __RegLdiMemAddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MemAddr                                           :10         ; //Bits :[0:9], initial value: 0x0. memory address pointer, auto incrementing
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. reserved
     } fields_read;
    struct {
        uint32_t MemAddr                                           :10         ; //Bits :[0:9], initial value: 0x0. memory address pointer, auto incrementing
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. reserved
     } fields_write;
    struct {
        uint32_t MemAddr                                           :10         ; //Bits :[0:9], initial value: 0x0. memory address pointer, auto incrementing
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. reserved
     } fields_rmw; //for non-shadowed register
} RegLdiMemAddr, TRegLdiMemAddr, *PTRegLdiMemAddr;                                //0x11824

//memory data value bits [31:0]
//initial value: 0x0
typedef union __RegLdiMemData0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MemAddr                                           :32         ; //Bits :[0:31], initial value: 0x0. memory data value bits [31:0]
     } fields_read;
    struct {
        uint32_t MemAddr                                           :32         ; //Bits :[0:31], initial value: 0x0. memory data value bits [31:0]
     } fields_write;
    struct {
        uint32_t MemAddr                                           :32         ; //Bits :[0:31], initial value: 0x0. memory data value bits [31:0]
     } fields_rmw; //for non-shadowed register
} RegLdiMemData0, TRegLdiMemData0, *PTRegLdiMemData0;                                //0x11828

//memory data value bits [35:32]
//initial value: 0x0
typedef union __RegLdiMemData1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MemAddr                                           :32         ; //Bits :[0:31], initial value: 0x0. memory data value bits [35:32]
     } fields_read;
    struct {
        uint32_t MemAddr                                           :32         ; //Bits :[0:31], initial value: 0x0. memory data value bits [35:32]
     } fields_write;
    struct {
        uint32_t MemAddr                                           :32         ; //Bits :[0:31], initial value: 0x0. memory data value bits [35:32]
     } fields_rmw; //for non-shadowed register
} RegLdiMemData1, TRegLdiMemData1, *PTRegLdiMemData1;                                //0x1182C

//delay sclk cycles between internally generated hsync0 pulses
//initial value: 0x0
typedef union __RegLdiTrigDelayCnt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TrigDelayCnt                                      :16         ; //Bits :[0:15], initial value: 0x0. delay sclk cycles between internally generated hsync0 pulses
     } fields_read;
    struct {
        uint32_t TrigDelayCnt                                      :16         ; //Bits :[0:15], initial value: 0x0. delay sclk cycles between internally generated hsync0 pulses
     } fields_write;
    struct {
        uint32_t TrigDelayCnt                                      :16         ; //Bits :[0:15], initial value: 0x0. delay sclk cycles between internally generated hsync0 pulses
     } fields_rmw; //for non-shadowed register
} RegLdiTrigDelayCnt, TRegLdiTrigDelayCnt, *PTRegLdiTrigDelayCnt;                                //0x11830

//number of internally generated hsync0 pulses after an external trigger
//initial value: 0x0
typedef union __RegLdiTrigLoopCnt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TrigLoopCnt                                       :13         ; //Bits :[0:12], initial value: 0x0. number of internally generated hsync0 pulses after an external trigger
     } fields_read;
    struct {
        uint32_t TrigLoopCnt                                       :13         ; //Bits :[0:12], initial value: 0x0. number of internally generated hsync0 pulses after an external trigger
     } fields_write;
    struct {
        uint32_t TrigLoopCnt                                       :13         ; //Bits :[0:12], initial value: 0x0. number of internally generated hsync0 pulses after an external trigger
     } fields_rmw; //for non-shadowed register
} RegLdiTrigLoopCnt, TRegLdiTrigLoopCnt, *PTRegLdiTrigLoopCnt;                                //0x11834

//select which IRQ will create a fatal error and disable the LDI module
//initial value: 0x0
typedef union __RegLdiRegFatalErrSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regfatalerrselect                                 :7          ; //Bits :[0:6], initial value: 0x0. select which IRQ will create a fatal error and disable the LDI module
     } fields_read;
    struct {
        uint32_t Regfatalerrselect                                 :7          ; //Bits :[0:6], initial value: 0x0. select which IRQ will create a fatal error and disable the LDI module
     } fields_write;
    struct {
        uint32_t Regfatalerrselect                                 :7          ; //Bits :[0:6], initial value: 0x0. select which IRQ will create a fatal error and disable the LDI module
     } fields_rmw; //for non-shadowed register
} RegLdiRegFatalErrSelect, TRegLdiRegFatalErrSelect, *PTRegLdiRegFatalErrSelect;                                //0x11838

//##############################################################
//                    mipiA_registers area
//##############################################################
//MIPI Version
//initial value: 0x3131302a
typedef union __RegMipiAVersion{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_read;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_write;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_rmw; //for non-shadowed register
} RegMipiAVersion, TRegMipiAVersion, *PTRegMipiAVersion;                                //0x40000

//Number of lanes
//initial value: 0x0
typedef union __RegMipiANumLanes{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_read;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_write;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_rmw; //for non-shadowed register
} RegMipiANumLanes, TRegMipiANumLanes, *PTRegMipiANumLanes;                                //0x40004

//MIPI Reset N
//initial value: 0x0
typedef union __RegMipiAResetN{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_read;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_write;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_rmw; //for non-shadowed register
} RegMipiAResetN, TRegMipiAResetN, *PTRegMipiAResetN;                                //0x40008

//MIPI Interrupt Status
//initial value: 0x0
typedef union __RegMipiAIntStMain{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_read;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_write;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_rmw; //for non-shadowed register
} RegMipiAIntStMain, TRegMipiAIntStMain, *PTRegMipiAIntStMain;                                //0x4000C

//DATA IDS 1
//initial value: 0x00000000
typedef union __RegMipiADataIds1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_read;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_write;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiADataIds1, TRegMipiADataIds1, *PTRegMipiADataIds1;                                //0x40010

//DATA IDS 2
//initial value: 0x00000000
typedef union __RegMipiADataIds2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_read;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_write;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiADataIds2, TRegMipiADataIds2, *PTRegMipiADataIds2;                                //0x40014

//PHY Shutdown Z
//initial value: 0x0
typedef union __RegMipiAPhyShutdownZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_read;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_write;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_rmw; //for non-shadowed register
} RegMipiAPhyShutdownZ, TRegMipiAPhyShutdownZ, *PTRegMipiAPhyShutdownZ;                                //0x40040

//PHY Reset Z
//initial value: 0x0
typedef union __RegMipiADphyRstZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_read;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_write;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_rmw; //for non-shadowed register
} RegMipiADphyRstZ, TRegMipiADphyRstZ, *PTRegMipiADphyRstZ;                                //0x40044

//PHY RX status
//initial value: 0x0
typedef union __RegMipiAPhyRx{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_read;
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_rmw; //for non-shadowed register
} RegMipiAPhyRx, TRegMipiAPhyRx, *PTRegMipiAPhyRx;                                //0x40048

//PHY Stop State signals status
//initial value: 0x0
typedef union __RegMipiAPhyStopState{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_read;
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_rmw; //for non-shadowed register
} RegMipiAPhyStopState, TRegMipiAPhyStopState, *PTRegMipiAPhyStopState;                                //0x4004C

//PHY Test Ctrl0
//initial value: 0x0
typedef union __RegMipiAPhyTestCtrl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_read;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_write;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_rmw; //for non-shadowed register
} RegMipiAPhyTestCtrl0, TRegMipiAPhyTestCtrl0, *PTRegMipiAPhyTestCtrl0;                                //0x40050

//PHY Test Ctrl1
//initial value: 0x0
typedef union __RegMipiAPhyTestCtrl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_read;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_write;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_rmw; //for non-shadowed register
} RegMipiAPhyTestCtrl1, TRegMipiAPhyTestCtrl1, *PTRegMipiAPhyTestCtrl1;                                //0x40054

//PHY calibration status
//initial value: 0x0
typedef union __RegMipiAPhyCal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_read;
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_rmw; //for non-shadowed register
} RegMipiAPhyCal, TRegMipiAPhyCal, *PTRegMipiAPhyCal;                                //0x400CC

//PHY fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiAIntStPhyFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiAIntStPhyFatal, TRegMipiAIntStPhyFatal, *PTRegMipiAIntStPhyFatal;                                //0x400E0

//PHY fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiAIntMaskPhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiAIntMaskPhyFatal, TRegMipiAIntMaskPhyFatal, *PTRegMipiAIntMaskPhyFatal;                                //0x400E4

//PHY fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiAIntForcePhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiAIntForcePhyFatal, TRegMipiAIntForcePhyFatal, *PTRegMipiAIntForcePhyFatal;                                //0x400E8

//PKT fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiAIntStPktFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_read;
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_rmw; //for non-shadowed register
} RegMipiAIntStPktFatal, TRegMipiAIntStPktFatal, *PTRegMipiAIntStPktFatal;                                //0x400F0

//PKT fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiAIntMaskPktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiAIntMaskPktFatal, TRegMipiAIntMaskPktFatal, *PTRegMipiAIntMaskPktFatal;                                //0x400F4

//PKT fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiAIntForcePktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiAIntForcePktFatal, TRegMipiAIntForcePktFatal, *PTRegMipiAIntForcePktFatal;                                //0x400F8

//FRAME fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiAIntStFrameFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiAIntStFrameFatal, TRegMipiAIntStFrameFatal, *PTRegMipiAIntStFrameFatal;                                //0x40100

//FRAME fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiAIntMaskFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiAIntMaskFrameFatal, TRegMipiAIntMaskFrameFatal, *PTRegMipiAIntMaskFrameFatal;                                //0x40104

//FRAME fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiAIntForceFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiAIntForceFrameFatal, TRegMipiAIntForceFrameFatal, *PTRegMipiAIntForceFrameFatal;                                //0x40108

//PHY Interrupts status
//initial value: 0x0
typedef union __RegMipiAIntStPhy{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiAIntStPhy, TRegMipiAIntStPhy, *PTRegMipiAIntStPhy;                                //0x40110

//PHY Interrupts mask
//initial value: 0x0
typedef union __RegMipiAIntMaskPhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiAIntMaskPhy, TRegMipiAIntMaskPhy, *PTRegMipiAIntMaskPhy;                                //0x40114

//PHY Interrupts force
//initial value: 0x0
typedef union __RegMipiAIntForcePhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiAIntForcePhy, TRegMipiAIntForcePhy, *PTRegMipiAIntForcePhy;                                //0x40118

//PKT Interrupts status
//initial value: 0x0
typedef union __RegMipiAIntStPkt{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiAIntStPkt, TRegMipiAIntStPkt, *PTRegMipiAIntStPkt;                                //0x40120

//PKT Interrupts mask
//initial value: 0x0
typedef union __RegMipiAIntMaskPkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiAIntMaskPkt, TRegMipiAIntMaskPkt, *PTRegMipiAIntMaskPkt;                                //0x40124

//PKT Interrupts force
//initial value: 0x0
typedef union __RegMipiAIntForcePkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiAIntForcePkt, TRegMipiAIntForcePkt, *PTRegMipiAIntForcePkt;                                //0x40128

//LINE Interrupts status
//initial value: 0x0
typedef union __RegMipiAIntStLine{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiAIntStLine, TRegMipiAIntStLine, *PTRegMipiAIntStLine;                                //0x40130

//LINE Interrupts mask
//initial value: 0x0
typedef union __RegMipiAIntMaskLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiAIntMaskLine, TRegMipiAIntMaskLine, *PTRegMipiAIntMaskLine;                                //0x40134

//LINE Interrupts force
//initial value: 0x0
typedef union __RegMipiAIntForceLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiAIntForceLine, TRegMipiAIntForceLine, *PTRegMipiAIntForceLine;                                //0x40138

//##############################################################
//                    mipiB_registers area
//##############################################################
//MIPI Version
//initial value: 0x3131302a
typedef union __RegMipiBVersion{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_read;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_write;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_rmw; //for non-shadowed register
} RegMipiBVersion, TRegMipiBVersion, *PTRegMipiBVersion;                                //0x40400

//Number of lanes
//initial value: 0x0
typedef union __RegMipiBNumLanes{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_read;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_write;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_rmw; //for non-shadowed register
} RegMipiBNumLanes, TRegMipiBNumLanes, *PTRegMipiBNumLanes;                                //0x40404

//MIPI Reset N
//initial value: 0x0
typedef union __RegMipiBResetN{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_read;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_write;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_rmw; //for non-shadowed register
} RegMipiBResetN, TRegMipiBResetN, *PTRegMipiBResetN;                                //0x40408

//MIPI Interrupt Status
//initial value: 0x0
typedef union __RegMipiBIntStMain{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_read;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_write;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_rmw; //for non-shadowed register
} RegMipiBIntStMain, TRegMipiBIntStMain, *PTRegMipiBIntStMain;                                //0x4040C

//DATA IDS 1
//initial value: 0x00000000
typedef union __RegMipiBDataIds1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_read;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_write;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiBDataIds1, TRegMipiBDataIds1, *PTRegMipiBDataIds1;                                //0x40410

//DATA IDS 2
//initial value: 0x00000000
typedef union __RegMipiBDataIds2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_read;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_write;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiBDataIds2, TRegMipiBDataIds2, *PTRegMipiBDataIds2;                                //0x40414

//PHY Shutdown Z
//initial value: 0x0
typedef union __RegMipiBPhyShutdownZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_read;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_write;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_rmw; //for non-shadowed register
} RegMipiBPhyShutdownZ, TRegMipiBPhyShutdownZ, *PTRegMipiBPhyShutdownZ;                                //0x40440

//PHY Reset Z
//initial value: 0x0
typedef union __RegMipiBDphyRstZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_read;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_write;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_rmw; //for non-shadowed register
} RegMipiBDphyRstZ, TRegMipiBDphyRstZ, *PTRegMipiBDphyRstZ;                                //0x40444

//PHY RX status
//initial value: 0x0
typedef union __RegMipiBPhyRx{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_read;
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_rmw; //for non-shadowed register
} RegMipiBPhyRx, TRegMipiBPhyRx, *PTRegMipiBPhyRx;                                //0x40448

//PHY Stop State signals status
//initial value: 0x0
typedef union __RegMipiBPhyStopState{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_read;
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_rmw; //for non-shadowed register
} RegMipiBPhyStopState, TRegMipiBPhyStopState, *PTRegMipiBPhyStopState;                                //0x4044C

//PHY Test Ctrl0
//initial value: 0x0
typedef union __RegMipiBPhyTestCtrl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_read;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_write;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_rmw; //for non-shadowed register
} RegMipiBPhyTestCtrl0, TRegMipiBPhyTestCtrl0, *PTRegMipiBPhyTestCtrl0;                                //0x40450

//PHY Test Ctrl1
//initial value: 0x0
typedef union __RegMipiBPhyTestCtrl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_read;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_write;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_rmw; //for non-shadowed register
} RegMipiBPhyTestCtrl1, TRegMipiBPhyTestCtrl1, *PTRegMipiBPhyTestCtrl1;                                //0x40454

//PHY calibration status
//initial value: 0x0
typedef union __RegMipiBPhyCal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_read;
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_rmw; //for non-shadowed register
} RegMipiBPhyCal, TRegMipiBPhyCal, *PTRegMipiBPhyCal;                                //0x404CC

//PHY fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiBIntStPhyFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiBIntStPhyFatal, TRegMipiBIntStPhyFatal, *PTRegMipiBIntStPhyFatal;                                //0x404E0

//PHY fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiBIntMaskPhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiBIntMaskPhyFatal, TRegMipiBIntMaskPhyFatal, *PTRegMipiBIntMaskPhyFatal;                                //0x404E4

//PHY fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiBIntForcePhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiBIntForcePhyFatal, TRegMipiBIntForcePhyFatal, *PTRegMipiBIntForcePhyFatal;                                //0x404E8

//PKT fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiBIntStPktFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_read;
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_rmw; //for non-shadowed register
} RegMipiBIntStPktFatal, TRegMipiBIntStPktFatal, *PTRegMipiBIntStPktFatal;                                //0x404F0

//PKT fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiBIntMaskPktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiBIntMaskPktFatal, TRegMipiBIntMaskPktFatal, *PTRegMipiBIntMaskPktFatal;                                //0x404F4

//PKT fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiBIntForcePktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiBIntForcePktFatal, TRegMipiBIntForcePktFatal, *PTRegMipiBIntForcePktFatal;                                //0x404F8

//FRAME fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiBIntStFrameFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiBIntStFrameFatal, TRegMipiBIntStFrameFatal, *PTRegMipiBIntStFrameFatal;                                //0x40500

//FRAME fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiBIntMaskFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiBIntMaskFrameFatal, TRegMipiBIntMaskFrameFatal, *PTRegMipiBIntMaskFrameFatal;                                //0x40504

//FRAME fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiBIntForceFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiBIntForceFrameFatal, TRegMipiBIntForceFrameFatal, *PTRegMipiBIntForceFrameFatal;                                //0x40508

//PHY Interrupts status
//initial value: 0x0
typedef union __RegMipiBIntStPhy{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiBIntStPhy, TRegMipiBIntStPhy, *PTRegMipiBIntStPhy;                                //0x40510

//PHY Interrupts mask
//initial value: 0x0
typedef union __RegMipiBIntMaskPhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiBIntMaskPhy, TRegMipiBIntMaskPhy, *PTRegMipiBIntMaskPhy;                                //0x40514

//PHY Interrupts force
//initial value: 0x0
typedef union __RegMipiBIntForcePhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiBIntForcePhy, TRegMipiBIntForcePhy, *PTRegMipiBIntForcePhy;                                //0x40518

//PKT Interrupts status
//initial value: 0x0
typedef union __RegMipiBIntStPkt{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiBIntStPkt, TRegMipiBIntStPkt, *PTRegMipiBIntStPkt;                                //0x40520

//PKT Interrupts mask
//initial value: 0x0
typedef union __RegMipiBIntMaskPkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiBIntMaskPkt, TRegMipiBIntMaskPkt, *PTRegMipiBIntMaskPkt;                                //0x40524

//PKT Interrupts force
//initial value: 0x0
typedef union __RegMipiBIntForcePkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiBIntForcePkt, TRegMipiBIntForcePkt, *PTRegMipiBIntForcePkt;                                //0x40528

//LINE Interrupts status
//initial value: 0x0
typedef union __RegMipiBIntStLine{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiBIntStLine, TRegMipiBIntStLine, *PTRegMipiBIntStLine;                                //0x40530

//LINE Interrupts mask
//initial value: 0x0
typedef union __RegMipiBIntMaskLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiBIntMaskLine, TRegMipiBIntMaskLine, *PTRegMipiBIntMaskLine;                                //0x40534

//LINE Interrupts force
//initial value: 0x0
typedef union __RegMipiBIntForceLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiBIntForceLine, TRegMipiBIntForceLine, *PTRegMipiBIntForceLine;                                //0x40538

//##############################################################
//                    mipiM_registers area
//##############################################################
//MIPI Version
//initial value: 0x3131302a
typedef union __RegMipiMVersion{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_read;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_write;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_rmw; //for non-shadowed register
} RegMipiMVersion, TRegMipiMVersion, *PTRegMipiMVersion;                                //0x40800

//Number of lanes
//initial value: 0x0
typedef union __RegMipiMNumLanes{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_read;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_write;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_rmw; //for non-shadowed register
} RegMipiMNumLanes, TRegMipiMNumLanes, *PTRegMipiMNumLanes;                                //0x40804

//MIPI Reset N
//initial value: 0x0
typedef union __RegMipiMResetN{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_read;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_write;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_rmw; //for non-shadowed register
} RegMipiMResetN, TRegMipiMResetN, *PTRegMipiMResetN;                                //0x40808

//MIPI Interrupt Status
//initial value: 0x0
typedef union __RegMipiMIntStMain{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_read;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_write;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_rmw; //for non-shadowed register
} RegMipiMIntStMain, TRegMipiMIntStMain, *PTRegMipiMIntStMain;                                //0x4080C

//DATA IDS 1
//initial value: 0x00000000
typedef union __RegMipiMDataIds1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_read;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_write;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiMDataIds1, TRegMipiMDataIds1, *PTRegMipiMDataIds1;                                //0x40810

//DATA IDS 2
//initial value: 0x00000000
typedef union __RegMipiMDataIds2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_read;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_write;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiMDataIds2, TRegMipiMDataIds2, *PTRegMipiMDataIds2;                                //0x40814

//PHY Shutdown Z
//initial value: 0x0
typedef union __RegMipiMPhyShutdownZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_read;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_write;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_rmw; //for non-shadowed register
} RegMipiMPhyShutdownZ, TRegMipiMPhyShutdownZ, *PTRegMipiMPhyShutdownZ;                                //0x40840

//PHY Reset Z
//initial value: 0x0
typedef union __RegMipiMDphyRstZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_read;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_write;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_rmw; //for non-shadowed register
} RegMipiMDphyRstZ, TRegMipiMDphyRstZ, *PTRegMipiMDphyRstZ;                                //0x40844

//PHY RX status
//initial value: 0x0
typedef union __RegMipiMPhyRx{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_read;
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_rmw; //for non-shadowed register
} RegMipiMPhyRx, TRegMipiMPhyRx, *PTRegMipiMPhyRx;                                //0x40848

//PHY Stop State signals status
//initial value: 0x0
typedef union __RegMipiMPhyStopState{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_read;
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_rmw; //for non-shadowed register
} RegMipiMPhyStopState, TRegMipiMPhyStopState, *PTRegMipiMPhyStopState;                                //0x4084C

//PHY Test Ctrl0
//initial value: 0x0
typedef union __RegMipiMPhyTestCtrl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_read;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_write;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_rmw; //for non-shadowed register
} RegMipiMPhyTestCtrl0, TRegMipiMPhyTestCtrl0, *PTRegMipiMPhyTestCtrl0;                                //0x40850

//PHY Test Ctrl1
//initial value: 0x0
typedef union __RegMipiMPhyTestCtrl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_read;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_write;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_rmw; //for non-shadowed register
} RegMipiMPhyTestCtrl1, TRegMipiMPhyTestCtrl1, *PTRegMipiMPhyTestCtrl1;                                //0x40854

//PHY calibration status
//initial value: 0x0
typedef union __RegMipiMPhyCal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_read;
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_rmw; //for non-shadowed register
} RegMipiMPhyCal, TRegMipiMPhyCal, *PTRegMipiMPhyCal;                                //0x408CC

//PHY fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiMIntStPhyFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiMIntStPhyFatal, TRegMipiMIntStPhyFatal, *PTRegMipiMIntStPhyFatal;                                //0x408E0

//PHY fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiMIntMaskPhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiMIntMaskPhyFatal, TRegMipiMIntMaskPhyFatal, *PTRegMipiMIntMaskPhyFatal;                                //0x408E4

//PHY fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiMIntForcePhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiMIntForcePhyFatal, TRegMipiMIntForcePhyFatal, *PTRegMipiMIntForcePhyFatal;                                //0x408E8

//PKT fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiMIntStPktFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_read;
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_rmw; //for non-shadowed register
} RegMipiMIntStPktFatal, TRegMipiMIntStPktFatal, *PTRegMipiMIntStPktFatal;                                //0x408F0

//PKT fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiMIntMaskPktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiMIntMaskPktFatal, TRegMipiMIntMaskPktFatal, *PTRegMipiMIntMaskPktFatal;                                //0x408F4

//PKT fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiMIntForcePktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiMIntForcePktFatal, TRegMipiMIntForcePktFatal, *PTRegMipiMIntForcePktFatal;                                //0x408F8

//FRAME fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiMIntStFrameFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiMIntStFrameFatal, TRegMipiMIntStFrameFatal, *PTRegMipiMIntStFrameFatal;                                //0x40900

//FRAME fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiMIntMaskFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiMIntMaskFrameFatal, TRegMipiMIntMaskFrameFatal, *PTRegMipiMIntMaskFrameFatal;                                //0x40904

//FRAME fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiMIntForceFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiMIntForceFrameFatal, TRegMipiMIntForceFrameFatal, *PTRegMipiMIntForceFrameFatal;                                //0x40908

//PHY Interrupts status
//initial value: 0x0
typedef union __RegMipiMIntStPhy{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiMIntStPhy, TRegMipiMIntStPhy, *PTRegMipiMIntStPhy;                                //0x40910

//PHY Interrupts mask
//initial value: 0x0
typedef union __RegMipiMIntMaskPhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiMIntMaskPhy, TRegMipiMIntMaskPhy, *PTRegMipiMIntMaskPhy;                                //0x40914

//PHY Interrupts force
//initial value: 0x0
typedef union __RegMipiMIntForcePhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiMIntForcePhy, TRegMipiMIntForcePhy, *PTRegMipiMIntForcePhy;                                //0x40918

//PKT Interrupts status
//initial value: 0x0
typedef union __RegMipiMIntStPkt{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiMIntStPkt, TRegMipiMIntStPkt, *PTRegMipiMIntStPkt;                                //0x40920

//PKT Interrupts mask
//initial value: 0x0
typedef union __RegMipiMIntMaskPkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiMIntMaskPkt, TRegMipiMIntMaskPkt, *PTRegMipiMIntMaskPkt;                                //0x40924

//PKT Interrupts force
//initial value: 0x0
typedef union __RegMipiMIntForcePkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiMIntForcePkt, TRegMipiMIntForcePkt, *PTRegMipiMIntForcePkt;                                //0x40928

//LINE Interrupts status
//initial value: 0x0
typedef union __RegMipiMIntStLine{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiMIntStLine, TRegMipiMIntStLine, *PTRegMipiMIntStLine;                                //0x40930

//LINE Interrupts mask
//initial value: 0x0
typedef union __RegMipiMIntMaskLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiMIntMaskLine, TRegMipiMIntMaskLine, *PTRegMipiMIntMaskLine;                                //0x40934

//LINE Interrupts force
//initial value: 0x0
typedef union __RegMipiMIntForceLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiMIntForceLine, TRegMipiMIntForceLine, *PTRegMipiMIntForceLine;                                //0x40938

//##############################################################
//                    mipiY_registers area
//##############################################################
//MIPI Version
//initial value: 0x3131302a
typedef union __RegMipiYVersion{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_read;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_write;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_rmw; //for non-shadowed register
} RegMipiYVersion, TRegMipiYVersion, *PTRegMipiYVersion;                                //0x40C00

//Number of lanes
//initial value: 0x0
typedef union __RegMipiYNumLanes{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_read;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_write;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_rmw; //for non-shadowed register
} RegMipiYNumLanes, TRegMipiYNumLanes, *PTRegMipiYNumLanes;                                //0x40C04

//MIPI Reset N
//initial value: 0x0
typedef union __RegMipiYResetN{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_read;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_write;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_rmw; //for non-shadowed register
} RegMipiYResetN, TRegMipiYResetN, *PTRegMipiYResetN;                                //0x40C08

//MIPI Interrupt Status
//initial value: 0x0
typedef union __RegMipiYIntStMain{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_read;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_write;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_rmw; //for non-shadowed register
} RegMipiYIntStMain, TRegMipiYIntStMain, *PTRegMipiYIntStMain;                                //0x40C0C

//DATA IDS 1
//initial value: 0x00000000
typedef union __RegMipiYDataIds1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_read;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_write;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiYDataIds1, TRegMipiYDataIds1, *PTRegMipiYDataIds1;                                //0x40C10

//DATA IDS 2
//initial value: 0x00000000
typedef union __RegMipiYDataIds2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_read;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_write;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiYDataIds2, TRegMipiYDataIds2, *PTRegMipiYDataIds2;                                //0x40C14

//PHY Shutdown Z
//initial value: 0x0
typedef union __RegMipiYPhyShutdownZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_read;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_write;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_rmw; //for non-shadowed register
} RegMipiYPhyShutdownZ, TRegMipiYPhyShutdownZ, *PTRegMipiYPhyShutdownZ;                                //0x40C40

//PHY Reset Z
//initial value: 0x0
typedef union __RegMipiYDphyRstZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_read;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_write;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_rmw; //for non-shadowed register
} RegMipiYDphyRstZ, TRegMipiYDphyRstZ, *PTRegMipiYDphyRstZ;                                //0x40C44

//PHY RX status
//initial value: 0x0
typedef union __RegMipiYPhyRx{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_read;
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_rmw; //for non-shadowed register
} RegMipiYPhyRx, TRegMipiYPhyRx, *PTRegMipiYPhyRx;                                //0x40C48

//PHY Stop State signals status
//initial value: 0x0
typedef union __RegMipiYPhyStopState{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_read;
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_rmw; //for non-shadowed register
} RegMipiYPhyStopState, TRegMipiYPhyStopState, *PTRegMipiYPhyStopState;                                //0x40C4C

//PHY Test Ctrl0
//initial value: 0x0
typedef union __RegMipiYPhyTestCtrl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_read;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_write;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_rmw; //for non-shadowed register
} RegMipiYPhyTestCtrl0, TRegMipiYPhyTestCtrl0, *PTRegMipiYPhyTestCtrl0;                                //0x40C50

//PHY Test Ctrl1
//initial value: 0x0
typedef union __RegMipiYPhyTestCtrl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_read;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_write;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_rmw; //for non-shadowed register
} RegMipiYPhyTestCtrl1, TRegMipiYPhyTestCtrl1, *PTRegMipiYPhyTestCtrl1;                                //0x40C54

//PHY calibration status
//initial value: 0x0
typedef union __RegMipiYPhyCal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_read;
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_rmw; //for non-shadowed register
} RegMipiYPhyCal, TRegMipiYPhyCal, *PTRegMipiYPhyCal;                                //0x40CCC

//PHY fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiYIntStPhyFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiYIntStPhyFatal, TRegMipiYIntStPhyFatal, *PTRegMipiYIntStPhyFatal;                                //0x40CE0

//PHY fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiYIntMaskPhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiYIntMaskPhyFatal, TRegMipiYIntMaskPhyFatal, *PTRegMipiYIntMaskPhyFatal;                                //0x40CE4

//PHY fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiYIntForcePhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiYIntForcePhyFatal, TRegMipiYIntForcePhyFatal, *PTRegMipiYIntForcePhyFatal;                                //0x40CE8

//PKT fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiYIntStPktFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_read;
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_rmw; //for non-shadowed register
} RegMipiYIntStPktFatal, TRegMipiYIntStPktFatal, *PTRegMipiYIntStPktFatal;                                //0x40CF0

//PKT fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiYIntMaskPktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiYIntMaskPktFatal, TRegMipiYIntMaskPktFatal, *PTRegMipiYIntMaskPktFatal;                                //0x40CF4

//PKT fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiYIntForcePktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiYIntForcePktFatal, TRegMipiYIntForcePktFatal, *PTRegMipiYIntForcePktFatal;                                //0x40CF8

//FRAME fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiYIntStFrameFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiYIntStFrameFatal, TRegMipiYIntStFrameFatal, *PTRegMipiYIntStFrameFatal;                                //0x40D00

//FRAME fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiYIntMaskFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiYIntMaskFrameFatal, TRegMipiYIntMaskFrameFatal, *PTRegMipiYIntMaskFrameFatal;                                //0x40D04

//FRAME fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiYIntForceFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiYIntForceFrameFatal, TRegMipiYIntForceFrameFatal, *PTRegMipiYIntForceFrameFatal;                                //0x40D08

//PHY Interrupts status
//initial value: 0x0
typedef union __RegMipiYIntStPhy{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiYIntStPhy, TRegMipiYIntStPhy, *PTRegMipiYIntStPhy;                                //0x40D10

//PHY Interrupts mask
//initial value: 0x0
typedef union __RegMipiYIntMaskPhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiYIntMaskPhy, TRegMipiYIntMaskPhy, *PTRegMipiYIntMaskPhy;                                //0x40D14

//PHY Interrupts force
//initial value: 0x0
typedef union __RegMipiYIntForcePhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiYIntForcePhy, TRegMipiYIntForcePhy, *PTRegMipiYIntForcePhy;                                //0x40D18

//PKT Interrupts status
//initial value: 0x0
typedef union __RegMipiYIntStPkt{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiYIntStPkt, TRegMipiYIntStPkt, *PTRegMipiYIntStPkt;                                //0x40D20

//PKT Interrupts mask
//initial value: 0x0
typedef union __RegMipiYIntMaskPkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiYIntMaskPkt, TRegMipiYIntMaskPkt, *PTRegMipiYIntMaskPkt;                                //0x40D24

//PKT Interrupts force
//initial value: 0x0
typedef union __RegMipiYIntForcePkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiYIntForcePkt, TRegMipiYIntForcePkt, *PTRegMipiYIntForcePkt;                                //0x40D28

//LINE Interrupts status
//initial value: 0x0
typedef union __RegMipiYIntStLine{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiYIntStLine, TRegMipiYIntStLine, *PTRegMipiYIntStLine;                                //0x40D30

//LINE Interrupts mask
//initial value: 0x0
typedef union __RegMipiYIntMaskLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiYIntMaskLine, TRegMipiYIntMaskLine, *PTRegMipiYIntMaskLine;                                //0x40D34

//LINE Interrupts force
//initial value: 0x0
typedef union __RegMipiYIntForceLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiYIntForceLine, TRegMipiYIntForceLine, *PTRegMipiYIntForceLine;                                //0x40D38

//##############################################################
//                    mipiZ_registers area
//##############################################################
//MIPI Version
//initial value: 0x3131302a
typedef union __RegMipiZVersion{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_read;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_write;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x3131302A. MIPI version.
     } fields_rmw; //for non-shadowed register
} RegMipiZVersion, TRegMipiZVersion, *PTRegMipiZVersion;                                //0x41080

//Number of lanes
//initial value: 0x0
typedef union __RegMipiZNumLanes{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_read;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_write;
    struct {
        uint32_t Numlanes                                          :3          ; //Bits :[0:2], initial value: 0x0. Number of lanes.
     } fields_rmw; //for non-shadowed register
} RegMipiZNumLanes, TRegMipiZNumLanes, *PTRegMipiZNumLanes;                                //0x41084

//MIPI Reset N
//initial value: 0x0
typedef union __RegMipiZResetN{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_read;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_write;
    struct {
        uint32_t ResetN                                            :1          ; //Bits :[0:0], initial value: 0x0. Reset N.
     } fields_rmw; //for non-shadowed register
} RegMipiZResetN, TRegMipiZResetN, *PTRegMipiZResetN;                                //0x41088

//MIPI Interrupt Status
//initial value: 0x0
typedef union __RegMipiZIntStMain{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_read;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_write;
    struct {
        uint32_t PhyFatal                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy fatal error
        uint32_t PktFatal                                          :1          ; //Bits :[1:1], initial value: 0x0. Packet fatal error
        uint32_t FrameFatal                                        :1          ; //Bits :[2:2], initial value: 0x0. Frame fatal error
        uint32_t Reserved3                                         :13         ; //Bits :[3:15], initial value: 0x0 Reserved.
        uint32_t Phy                                               :1          ; //Bits :[16:16], initial value: 0x0. Phy error
        uint32_t Pkt                                               :1          ; //Bits :[17:17], initial value: 0x0. Packet error
        uint32_t Line                                              :1          ; //Bits :[18:18], initial value: 0x0. Line error
        uint32_t Ipi                                               :1          ; //Bits :[19:19], initial value: 0x0. IPI error
     } fields_rmw; //for non-shadowed register
} RegMipiZIntStMain, TRegMipiZIntStMain, *PTRegMipiZIntStMain;                                //0x4108C

//DATA IDS 1
//initial value: 0x00000000
typedef union __RegMipiZDataIds1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_read;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_write;
    struct {
        uint32_t Di0Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI0 data type
        uint32_t Di0Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI0 Virtual channel
        uint32_t Di1Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI1 data type
        uint32_t Di1Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI1 Virtual channel
        uint32_t Di2Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI2 data type
        uint32_t Di2Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI2 Virtual channel
        uint32_t Di3Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI3 data type
        uint32_t Di3Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI3 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiZDataIds1, TRegMipiZDataIds1, *PTRegMipiZDataIds1;                                //0x41090

//DATA IDS 2
//initial value: 0x00000000
typedef union __RegMipiZDataIds2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_read;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_write;
    struct {
        uint32_t Di4Dt                                             :6          ; //Bits :[0:5], initial value: 0x0. DI4 data type
        uint32_t Di4Vc                                             :2          ; //Bits :[6:7], initial value: 0x0. DI4 Virtual channel
        uint32_t Di5Dt                                             :6          ; //Bits :[8:13], initial value: 0x0. DI5 data type
        uint32_t Di5Vc                                             :2          ; //Bits :[14:15], initial value: 0x0. DI5 Virtual channel
        uint32_t Di6Dt                                             :6          ; //Bits :[16:21], initial value: 0x0. DI6 data type
        uint32_t Di6Vc                                             :2          ; //Bits :[22:23], initial value: 0x0. DI6 Virtual channel
        uint32_t Di7Dt                                             :6          ; //Bits :[24:29], initial value: 0x0. DI7 data type
        uint32_t Di7Vc                                             :2          ; //Bits :[30:31], initial value: 0x0. DI7 Virtual channel
     } fields_rmw; //for non-shadowed register
} RegMipiZDataIds2, TRegMipiZDataIds2, *PTRegMipiZDataIds2;                                //0x41094

//PHY Shutdown Z
//initial value: 0x0
typedef union __RegMipiZPhyShutdownZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_read;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_write;
    struct {
        uint32_t PhyShutdownZ                                      :1          ; //Bits :[0:0], initial value: 0x0. Phy shutdown Z.
     } fields_rmw; //for non-shadowed register
} RegMipiZPhyShutdownZ, TRegMipiZPhyShutdownZ, *PTRegMipiZPhyShutdownZ;                                //0x410C0

//PHY Reset Z
//initial value: 0x0
typedef union __RegMipiZDphyRstZ{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_read;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_write;
    struct {
        uint32_t DphyRstZ                                          :1          ; //Bits :[0:0], initial value: 0x0. Phy Reset Z.
     } fields_rmw; //for non-shadowed register
} RegMipiZDphyRstZ, TRegMipiZDphyRstZ, *PTRegMipiZDphyRstZ;                                //0x410C4

//PHY RX status
//initial value: 0x0
typedef union __RegMipiZPhyRx{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_read;
    struct {
        uint32_t PhyRxulpsesc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Lane module 0 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Lane module 1 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Lane module 2 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Lane module 3 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc4                                     :1          ; //Bits :[4:4], initial value: 0x0. Lane module 4 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc5                                     :1          ; //Bits :[5:5], initial value: 0x0. Lane module 5 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc6                                     :1          ; //Bits :[6:6], initial value: 0x0. Lane module 6 has entered the Ultra Low Power mode
        uint32_t PhyRxulpsesc7                                     :1          ; //Bits :[7:7], initial value: 0x0. Lane module 7 has entered the Ultra Low Power mode
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyRxulpsclknot                                   :1          ; //Bits :[16:16], initial value: 0x0. This signal indicates that the Clock Lane module has entered the Ultra Low Power state. active Low
        uint32_t PhyRxclkactivehs                                  :1          ; //Bits :[17:17], initial value: 0x0. Indicates that the clock lane is actively receiving a DDR clock
     } fields_rmw; //for non-shadowed register
} RegMipiZPhyRx, TRegMipiZPhyRx, *PTRegMipiZPhyRx;                                //0x410C8

//PHY Stop State signals status
//initial value: 0x0
typedef union __RegMipiZPhyStopState{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_read;
    struct {
        uint32_t PhyStopStateData0                                 :1          ; //Bits :[0:0], initial value: 0x0. Data lane 0 in Stop state
        uint32_t PhyStopStateData1                                 :1          ; //Bits :[1:1], initial value: 0x0. Data lane 1 in Stop state
        uint32_t PhyStopStateData2                                 :1          ; //Bits :[2:2], initial value: 0x0. Data lane 2 in Stop state
        uint32_t PhyStopStateData3                                 :1          ; //Bits :[3:3], initial value: 0x0. Data lane 3 in Stop state
        uint32_t PhyStopStateData4                                 :1          ; //Bits :[4:4], initial value: 0x0. Data lane 4 in Stop state
        uint32_t PhyStopStateData5                                 :1          ; //Bits :[5:5], initial value: 0x0. Data lane 5 in Stop state
        uint32_t PhyStopStateData6                                 :1          ; //Bits :[6:6], initial value: 0x0. Data lane 6 in Stop state
        uint32_t PhyStopStateData7                                 :1          ; //Bits :[7:7], initial value: 0x0. Data lane 7 in Stop state
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyStopStateClk                                   :1          ; //Bits :[16:16], initial value: 0x0. Clock lane in Stop state
     } fields_rmw; //for non-shadowed register
} RegMipiZPhyStopState, TRegMipiZPhyStopState, *PTRegMipiZPhyStopState;                                //0x410CC

//PHY Test Ctrl0
//initial value: 0x0
typedef union __RegMipiZPhyTestCtrl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_read;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_write;
    struct {
        uint32_t PhyTestClr                                        :1          ; //Bits :[0:0], initial value: 0x0. Phy Test clear.
        uint32_t PhyTestClk                                        :1          ; //Bits :[1:1], initial value: 0x0. Phy Test clock.
     } fields_rmw; //for non-shadowed register
} RegMipiZPhyTestCtrl0, TRegMipiZPhyTestCtrl0, *PTRegMipiZPhyTestCtrl0;                                //0x410D0

//PHY Test Ctrl1
//initial value: 0x0
typedef union __RegMipiZPhyTestCtrl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_read;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_write;
    struct {
        uint32_t PhyTestDin                                        :8          ; //Bits :[0:7], initial value: 0x0. Phy Test data IN.
        uint32_t PhyTestDout                                       :8          ; //Bits :[8:15], initial value: 0x0. Phy Test data OUT.
        uint32_t PhyTestEn                                         :1          ; //Bits :[16:16], initial value: 0x0. Phy Test Enable.
     } fields_rmw; //for non-shadowed register
} RegMipiZPhyTestCtrl1, TRegMipiZPhyTestCtrl1, *PTRegMipiZPhyTestCtrl1;                                //0x410D4

//PHY calibration status
//initial value: 0x0
typedef union __RegMipiZPhyCal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_read;
    struct {
        uint32_t RxSkewCalHs                                       :1          ; //Bits :[0:0], initial value: 0x0. A low-to-high transition on rxskewcalhs signal means that the PHY has initiated the de-skew calibration
     } fields_rmw; //for non-shadowed register
} RegMipiZPhyCal, TRegMipiZPhyCal, *PTRegMipiZPhyCal;                                //0x4114C

//PHY fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiZIntStPhyFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotSyncHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrSotSyncHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiZIntStPhyFatal, TRegMipiZIntStPhyFatal, *PTRegMipiZIntStPhyFatal;                                //0x41160

//PHY fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiZIntMaskPhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotSyncHs0                              :1          ; //Bits :[0:0], initial value: 0x0. Mask for Phy Start of transmission error on data lane 0
        uint32_t MaskPhyErrSotSyncHs1                              :1          ; //Bits :[1:1], initial value: 0x0. Mask for Phy Start of transmission error on data lane 1
        uint32_t MaskPhyErrSotSyncHs2                              :1          ; //Bits :[2:2], initial value: 0x0. Mask for Phy Start of transmission error on data lane 2
        uint32_t MaskPhyErrSotSyncHs3                              :1          ; //Bits :[3:3], initial value: 0x0. Mask for Phy Start of transmission error on data lane 3
        uint32_t MaskPhyErrSotSyncHs4                              :1          ; //Bits :[4:4], initial value: 0x0. Mask for Phy Start of transmission error on data lane 4
        uint32_t MaskPhyErrSotSyncHs5                              :1          ; //Bits :[5:5], initial value: 0x0. Mask for Phy Start of transmission error on data lane 5
        uint32_t MaskPhyErrSotSyncHs6                              :1          ; //Bits :[6:6], initial value: 0x0. Mask for Phy Start of transmission error on data lane 6
        uint32_t MaskPhyErrSotSyncHs7                              :1          ; //Bits :[7:7], initial value: 0x0. Mask for Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiZIntMaskPhyFatal, TRegMipiZIntMaskPhyFatal, *PTRegMipiZIntMaskPhyFatal;                                //0x41164

//PHY fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiZIntForcePhyFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotSyncHs0                             :1          ; //Bits :[0:0], initial value: 0x0. Force Phy Start of transmission error on data lane 0
        uint32_t ForcePhyErrSotSyncHs1                             :1          ; //Bits :[1:1], initial value: 0x0. Force Phy Start of transmission error on data lane 1
        uint32_t ForcePhyErrSotSyncHs2                             :1          ; //Bits :[2:2], initial value: 0x0. Force Phy Start of transmission error on data lane 2
        uint32_t ForcePhyErrSotSyncHs3                             :1          ; //Bits :[3:3], initial value: 0x0. Force Phy Start of transmission error on data lane 3
        uint32_t ForcePhyErrSotSyncHs4                             :1          ; //Bits :[4:4], initial value: 0x0. Force Phy Start of transmission error on data lane 4
        uint32_t ForcePhyErrSotSyncHs5                             :1          ; //Bits :[5:5], initial value: 0x0. Force Phy Start of transmission error on data lane 5
        uint32_t ForcePhyErrSotSyncHs6                             :1          ; //Bits :[6:6], initial value: 0x0. Force Phy Start of transmission error on data lane 6
        uint32_t ForcePhyErrSotSyncHs7                             :1          ; //Bits :[7:7], initial value: 0x0. Force Phy Start of transmission error on data lane 7
     } fields_rmw; //for non-shadowed register
} RegMipiZIntForcePhyFatal, TRegMipiZIntForcePhyFatal, *PTRegMipiZIntForcePhyFatal;                                //0x41168

//PKT fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiZIntStPktFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_read;
    struct {
        uint32_t Vc0ErrCrc                                         :1          ; //Bits :[0:0], initial value: 0x0. Checksum error detected on virtual channel 0
        uint32_t Vc1ErrCrc                                         :1          ; //Bits :[1:1], initial value: 0x0. Checksum error detected on virtual channel 1
        uint32_t Vc2ErrCrc                                         :1          ; //Bits :[2:2], initial value: 0x0. Checksum error detected on virtual channel 2
        uint32_t Vc3ErrCrc                                         :1          ; //Bits :[3:3], initial value: 0x0. Checksum error detected on virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ErrEccDouble                                      :1          ; //Bits :[16:16], initial value: 0x0. Header ECC contains 2 errors, unrecoverable
     } fields_rmw; //for non-shadowed register
} RegMipiZIntStPktFatal, TRegMipiZIntStPktFatal, *PTRegMipiZIntStPktFatal;                                //0x41170

//PKT fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiZIntMaskPktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t MaskVc0ErrCrc                                     :1          ; //Bits :[0:0], initial value: 0x0. mask for VC_0_ERR_CRC
        uint32_t MaskVc1ErrCrc                                     :1          ; //Bits :[1:1], initial value: 0x0. mask for VC_1_ERR_CRC
        uint32_t MaskVc2ErrCrc                                     :1          ; //Bits :[2:2], initial value: 0x0. mask for VC_2_ERR_CRC
        uint32_t MaskVc3ErrCrc                                     :1          ; //Bits :[3:3], initial value: 0x0. mask for VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskErrEccDouble                                  :1          ; //Bits :[16:16], initial value: 0x0. mask for ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiZIntMaskPktFatal, TRegMipiZIntMaskPktFatal, *PTRegMipiZIntMaskPktFatal;                                //0x41174

//PKT fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiZIntForcePktFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_read;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_write;
    struct {
        uint32_t ForceVc0ErrCrc                                    :1          ; //Bits :[0:0], initial value: 0x0. force VC_0_ERR_CRC
        uint32_t ForceVc1ErrCrc                                    :1          ; //Bits :[1:1], initial value: 0x0. force VC_1_ERR_CRC
        uint32_t ForceVc2ErrCrc                                    :1          ; //Bits :[2:2], initial value: 0x0. force VC_2_ERR_CRC
        uint32_t ForceVc3ErrCrc                                    :1          ; //Bits :[3:3], initial value: 0x0. force VC_3_ERR_CRC
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceErrEccDouble                                 :1          ; //Bits :[16:16], initial value: 0x0. force ERR_ECC_DOUBLE
     } fields_rmw; //for non-shadowed register
} RegMipiZIntForcePktFatal, TRegMipiZIntForcePktFatal, *PTRegMipiZIntForcePktFatal;                                //0x41178

//FRAME fatal Interrupts status
//initial value: 0x0
typedef union __RegMipiZIntStFrameFatal{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ErrFrmBndryMatchVc0                               :1          ; //Bits :[0:0], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ErrFrmBndryMatchVc1                               :1          ; //Bits :[1:1], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ErrFrmBndryMatchVc2                               :1          ; //Bits :[2:2], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ErrFrmBndryMatchVc3                               :1          ; //Bits :[3:3], initial value: 0x0. Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ErrFrmSeqVc0                                      :1          ; //Bits :[8:8], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ErrFrmSeqVc1                                      :1          ; //Bits :[9:9], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ErrFrmSeqVc2                                      :1          ; //Bits :[10:10], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ErrFrmSeqVc3                                      :1          ; //Bits :[11:11], initial value: 0x0. Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ErrFrmDataVc0                                     :1          ; //Bits :[16:16], initial value: 0x0. Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ErrFrmDataVc1                                     :1          ; //Bits :[17:17], initial value: 0x0. Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ErrFrmDataVc2                                     :1          ; //Bits :[18:18], initial value: 0x0. Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ErrFrmDataVc3                                     :1          ; //Bits :[19:19], initial value: 0x0. Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiZIntStFrameFatal, TRegMipiZIntStFrameFatal, *PTRegMipiZIntStFrameFatal;                                //0x41180

//FRAME fatal Interrupts mask
//initial value: 0x0
typedef union __RegMipiZIntMaskFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t MaskErrFrmBndryMatchVc0                           :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 0
        uint32_t MaskErrFrmBndryMatchVc1                           :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 1
        uint32_t MaskErrFrmBndryMatchVc2                           :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 2
        uint32_t MaskErrFrmBndryMatchVc3                           :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmSeqVc0                                  :1          ; //Bits :[8:8], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t MaskErrFrmSeqVc1                                  :1          ; //Bits :[9:9], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t MaskErrFrmSeqVc2                                  :1          ; //Bits :[10:10], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t MaskErrFrmSeqVc3                                  :1          ; //Bits :[11:11], initial value: 0x0. Mask Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t MaskErrFrmDataVc0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t MaskErrFrmDataVc1                                 :1          ; //Bits :[17:17], initial value: 0x0. Mask Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t MaskErrFrmDataVc2                                 :1          ; //Bits :[18:18], initial value: 0x0. Mask Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t MaskErrFrmDataVc3                                 :1          ; //Bits :[19:19], initial value: 0x0. Mask Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiZIntMaskFrameFatal, TRegMipiZIntMaskFrameFatal, *PTRegMipiZIntMaskFrameFatal;                                //0x41184

//FRAME fatal Interrupts force
//initial value: 0x0
typedef union __RegMipiZIntForceFrameFatal{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_read;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_write;
    struct {
        uint32_t ForceErrFrmBndryMatchVc0                          :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 0
        uint32_t ForceErrFrmBndryMatchVc1                          :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 1
        uint32_t ForceErrFrmBndryMatchVc2                          :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 2
        uint32_t ForceErrFrmBndryMatchVc3                          :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching Frame Start with Frame End for virtual channel 3
        uint32_t Reserved4                                         :4          ; //Bits :[4:7], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmSeqVc0                                 :1          ; //Bits :[8:8], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 0
        uint32_t ForceErrFrmSeqVc1                                 :1          ; //Bits :[9:9], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 1
        uint32_t ForceErrFrmSeqVc2                                 :1          ; //Bits :[10:10], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 2
        uint32_t ForceErrFrmSeqVc3                                 :1          ; //Bits :[11:11], initial value: 0x0. Force Incorrect Frame sequence detected in Virtual Channel 3
        uint32_t Reserved12                                        :4          ; //Bits :[12:15], initial value: 0x0 Reserved.
        uint32_t ForceErrFrmDataVc0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Last received Frame in virtual channel 0, had at least one CRC error
        uint32_t ForceErrFrmDataVc1                                :1          ; //Bits :[17:17], initial value: 0x0. Force Last received Frame in virtual channel 1, had at least one CRC error
        uint32_t ForceErrFrmDataVc2                                :1          ; //Bits :[18:18], initial value: 0x0. Force Last received Frame in virtual channel 2, had at least one CRC error
        uint32_t ForceErrFrmDataVc3                                :1          ; //Bits :[19:19], initial value: 0x0. Force Last received Frame in virtual channel 3, had at least one CRC error
     } fields_rmw; //for non-shadowed register
} RegMipiZIntForceFrameFatal, TRegMipiZIntForceFrameFatal, *PTRegMipiZIntForceFrameFatal;                                //0x41188

//PHY Interrupts status
//initial value: 0x0
typedef union __RegMipiZIntStPhy{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t PhyErrSotHs0                                      :1          ; //Bits :[0:0], initial value: 0x0. Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t PhyErrSotHs1                                      :1          ; //Bits :[1:1], initial value: 0x0. Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t PhyErrSotHs2                                      :1          ; //Bits :[2:2], initial value: 0x0. Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t PhyErrSotHs3                                      :1          ; //Bits :[3:3], initial value: 0x0. Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t PhyErrSotHs4                                      :1          ; //Bits :[4:4], initial value: 0x0. Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t PhyErrSotHs5                                      :1          ; //Bits :[5:5], initial value: 0x0. Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t PhyErrSotHs6                                      :1          ; //Bits :[6:6], initial value: 0x0. Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t PhyErrSotHs7                                      :1          ; //Bits :[7:7], initial value: 0x0. Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t PhyErrEsc0                                        :1          ; //Bits :[16:16], initial value: 0x0. Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t PhyErrEsc1                                        :1          ; //Bits :[17:17], initial value: 0x0. Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t PhyErrEsc2                                        :1          ; //Bits :[18:18], initial value: 0x0. Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t PhyErrEsc3                                        :1          ; //Bits :[19:19], initial value: 0x0. Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t PhyErrEsc4                                        :1          ; //Bits :[20:20], initial value: 0x0. Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t PhyErrEsc5                                        :1          ; //Bits :[21:21], initial value: 0x0. Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t PhyErrEsc6                                        :1          ; //Bits :[22:22], initial value: 0x0. Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t PhyErrEsc7                                        :1          ; //Bits :[23:23], initial value: 0x0. Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiZIntStPhy, TRegMipiZIntStPhy, *PTRegMipiZIntStPhy;                                //0x41190

//PHY Interrupts mask
//initial value: 0x0
typedef union __RegMipiZIntMaskPhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t MaskPhyErrSotHs0                                  :1          ; //Bits :[0:0], initial value: 0x0. Mask Mask Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs1                                  :1          ; //Bits :[1:1], initial value: 0x0. Mask Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs2                                  :1          ; //Bits :[2:2], initial value: 0x0. Mask Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs3                                  :1          ; //Bits :[3:3], initial value: 0x0. Mask Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs4                                  :1          ; //Bits :[4:4], initial value: 0x0. Mask Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs5                                  :1          ; //Bits :[5:5], initial value: 0x0. Mask Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs6                                  :1          ; //Bits :[6:6], initial value: 0x0. Mask Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t MaskPhyErrSotHs7                                  :1          ; //Bits :[7:7], initial value: 0x0. Mask Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskPhyErrEsc0                                    :1          ; //Bits :[16:16], initial value: 0x0. Mask Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t MaskPhyErrEsc1                                    :1          ; //Bits :[17:17], initial value: 0x0. Mask Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t MaskPhyErrEsc2                                    :1          ; //Bits :[18:18], initial value: 0x0. Mask Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t MaskPhyErrEsc3                                    :1          ; //Bits :[19:19], initial value: 0x0. Mask Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t MaskPhyErrEsc4                                    :1          ; //Bits :[20:20], initial value: 0x0. Mask Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t MaskPhyErrEsc5                                    :1          ; //Bits :[21:21], initial value: 0x0. Mask Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t MaskPhyErrEsc6                                    :1          ; //Bits :[22:22], initial value: 0x0. Mask Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t MaskPhyErrEsc7                                    :1          ; //Bits :[23:23], initial value: 0x0. Mask Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiZIntMaskPhy, TRegMipiZIntMaskPhy, *PTRegMipiZIntMaskPhy;                                //0x41194

//PHY Interrupts force
//initial value: 0x0
typedef union __RegMipiZIntForcePhy{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_read;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_write;
    struct {
        uint32_t ForcePhyErrSotHs0                                 :1          ; //Bits :[0:0], initial value: 0x0. Force Start of transmission error on data lane 0 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs1                                 :1          ; //Bits :[1:1], initial value: 0x0. Force Start of transmission error on data lane 1 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs2                                 :1          ; //Bits :[2:2], initial value: 0x0. Force Start of transmission error on data lane 2 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs3                                 :1          ; //Bits :[3:3], initial value: 0x0. Force Start of transmission error on data lane 3 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs4                                 :1          ; //Bits :[4:4], initial value: 0x0. Force Start of transmission error on data lane 4 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs5                                 :1          ; //Bits :[5:5], initial value: 0x0. Force Start of transmission error on data lane 5 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs6                                 :1          ; //Bits :[6:6], initial value: 0x0. Force Start of transmission error on data lane 6 (synchronization can still be achieved)
        uint32_t ForcePhyErrSotHs7                                 :1          ; //Bits :[7:7], initial value: 0x0. Force Start of transmission error on data lane 7 (synchronization can still be achieved)
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForcePhyErrEsc0                                   :1          ; //Bits :[16:16], initial value: 0x0. Force Start of Transmission Error on data lane 0 (no synchronization achieved)
        uint32_t ForcePhyErrEsc1                                   :1          ; //Bits :[17:17], initial value: 0x0. Force Start of Transmission Error on data lane 1 (no synchronization achieved)
        uint32_t ForcePhyErrEsc2                                   :1          ; //Bits :[18:18], initial value: 0x0. Force Start of Transmission Error on data lane 2 (no synchronization achieved)
        uint32_t ForcePhyErrEsc3                                   :1          ; //Bits :[19:19], initial value: 0x0. Force Start of Transmission Error on data lane 3 (no synchronization achieved)
        uint32_t ForcePhyErrEsc4                                   :1          ; //Bits :[20:20], initial value: 0x0. Force Start of Transmission Error on data lane 4 (no synchronization achieved)
        uint32_t ForcePhyErrEsc5                                   :1          ; //Bits :[21:21], initial value: 0x0. Force Start of Transmission Error on data lane 5 (no synchronization achieved)
        uint32_t ForcePhyErrEsc6                                   :1          ; //Bits :[22:22], initial value: 0x0. Force Start of Transmission Error on data lane 6 (no synchronization achieved)
        uint32_t ForcePhyErrEsc7                                   :1          ; //Bits :[23:23], initial value: 0x0. Force Start of Transmission Error on data lane 7 (no synchronization achieved)
     } fields_rmw; //for non-shadowed register
} RegMipiZIntForcePhy, TRegMipiZIntForcePhy, *PTRegMipiZIntForcePhy;                                //0x41198

//PKT Interrupts status
//initial value: 0x0
typedef union __RegMipiZIntStPkt{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ErrIdVc0                                          :1          ; //Bits :[0:0], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ErrIdVc1                                          :1          ; //Bits :[1:1], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ErrIdVc2                                          :1          ; //Bits :[2:2], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ErrIdVc3                                          :1          ; //Bits :[3:3], initial value: 0x0. Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t Vc0ErrEccCorrected                                :1          ; //Bits :[16:16], initial value: 0x0. Header error detected and corrected on virtual channel 0
        uint32_t Vc1ErrEccCorrected                                :1          ; //Bits :[17:17], initial value: 0x0. Header error detected and corrected on virtual channel 1
        uint32_t Vc2ErrEccCorrected                                :1          ; //Bits :[18:18], initial value: 0x0. Header error detected and corrected on virtual channel 2
        uint32_t Vc3ErrEccCorrected                                :1          ; //Bits :[19:19], initial value: 0x0. Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiZIntStPkt, TRegMipiZIntStPkt, *PTRegMipiZIntStPkt;                                //0x411A0

//PKT Interrupts mask
//initial value: 0x0
typedef union __RegMipiZIntMaskPkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t MaskErrIdVc0                                      :1          ; //Bits :[0:0], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t MaskErrIdVc1                                      :1          ; //Bits :[1:1], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t MaskErrIdVc2                                      :1          ; //Bits :[2:2], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t MaskErrIdVc3                                      :1          ; //Bits :[3:3], initial value: 0x0. Mask Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t MaskVc0ErrEccCorrected                            :1          ; //Bits :[16:16], initial value: 0x0. Mask Header error detected and corrected on virtual channel 0
        uint32_t MaskVc1ErrEccCorrected                            :1          ; //Bits :[17:17], initial value: 0x0. Mask Header error detected and corrected on virtual channel 1
        uint32_t MaskVc2ErrEccCorrected                            :1          ; //Bits :[18:18], initial value: 0x0. Mask Header error detected and corrected on virtual channel 2
        uint32_t MaskVc3ErrEccCorrected                            :1          ; //Bits :[19:19], initial value: 0x0. Mask Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiZIntMaskPkt, TRegMipiZIntMaskPkt, *PTRegMipiZIntMaskPkt;                                //0x411A4

//PKT Interrupts force
//initial value: 0x0
typedef union __RegMipiZIntForcePkt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_read;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_write;
    struct {
        uint32_t ForceErrIdVc0                                     :1          ; //Bits :[0:0], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 0
        uint32_t ForceErrIdVc1                                     :1          ; //Bits :[1:1], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 1
        uint32_t ForceErrIdVc2                                     :1          ; //Bits :[2:2], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 2
        uint32_t ForceErrIdVc3                                     :1          ; //Bits :[3:3], initial value: 0x0. Force Unrecognized or unimplemented data type detected in virtual channel 3
        uint32_t Reserved4                                         :12         ; //Bits :[4:15], initial value: 0x0 Reserved.
        uint32_t ForceVc0ErrEccCorrected                           :1          ; //Bits :[16:16], initial value: 0x0. Force Header error detected and corrected on virtual channel 0
        uint32_t ForceVc1ErrEccCorrected                           :1          ; //Bits :[17:17], initial value: 0x0. Force Header error detected and corrected on virtual channel 1
        uint32_t ForceVc2ErrEccCorrected                           :1          ; //Bits :[18:18], initial value: 0x0. Force Header error detected and corrected on virtual channel 2
        uint32_t ForceVc3ErrEccCorrected                           :1          ; //Bits :[19:19], initial value: 0x0. Force Header error detected and corrected on virtual channel 3
     } fields_rmw; //for non-shadowed register
} RegMipiZIntForcePkt, TRegMipiZIntForcePkt, *PTRegMipiZIntForcePkt;                                //0x411A8

//LINE Interrupts status
//initial value: 0x0
typedef union __RegMipiZIntStLine{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ErrLineBndryMatchDi0                              :1          ; //Bits :[0:0], initial value: 0x0. Error matching line start with line end for vc0 and dt0
        uint32_t ErrLineBndryMatchDi1                              :1          ; //Bits :[1:1], initial value: 0x0. Error matching line start with line end for vc1 and dt1
        uint32_t ErrLineBndryMatchDi2                              :1          ; //Bits :[2:2], initial value: 0x0. Error matching line start with line end for vc2 and dt2
        uint32_t ErrLineBndryMatchDi3                              :1          ; //Bits :[3:3], initial value: 0x0. Error matching line start with line end for vc3 and dt3
        uint32_t ErrLineBndryMatchDi4                              :1          ; //Bits :[4:4], initial value: 0x0. Error matching line start with line end for vc4 and dt4
        uint32_t ErrLineBndryMatchDi5                              :1          ; //Bits :[5:5], initial value: 0x0. Error matching line start with line end for vc5 and dt5
        uint32_t ErrLineBndryMatchDi6                              :1          ; //Bits :[6:6], initial value: 0x0. Error matching line start with line end for vc6 and dt6
        uint32_t ErrLineBndryMatchDi7                              :1          ; //Bits :[7:7], initial value: 0x0. Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ErrLineSeqDi0                                     :1          ; //Bits :[16:16], initial value: 0x0. Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiZIntStLine, TRegMipiZIntStLine, *PTRegMipiZIntStLine;                                //0x411B0

//LINE Interrupts mask
//initial value: 0x0
typedef union __RegMipiZIntMaskLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t MaskErrLineBndryMatchDi0                          :1          ; //Bits :[0:0], initial value: 0x0. Mask Error matching line start with line end for vc0 and dt0
        uint32_t MaskErrLineBndryMatchDi1                          :1          ; //Bits :[1:1], initial value: 0x0. Mask Error matching line start with line end for vc1 and dt1
        uint32_t MaskErrLineBndryMatchDi2                          :1          ; //Bits :[2:2], initial value: 0x0. Mask Error matching line start with line end for vc2 and dt2
        uint32_t MaskErrLineBndryMatchDi3                          :1          ; //Bits :[3:3], initial value: 0x0. Mask Error matching line start with line end for vc3 and dt3
        uint32_t MaskErrLineBndryMatchDi4                          :1          ; //Bits :[4:4], initial value: 0x0. Mask Error matching line start with line end for vc4 and dt4
        uint32_t MaskErrLineBndryMatchDi5                          :1          ; //Bits :[5:5], initial value: 0x0. Mask Error matching line start with line end for vc5 and dt5
        uint32_t MaskErrLineBndryMatchDi6                          :1          ; //Bits :[6:6], initial value: 0x0. Mask Error matching line start with line end for vc6 and dt6
        uint32_t MaskErrLineBndryMatchDi7                          :1          ; //Bits :[7:7], initial value: 0x0. Mask Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t MaskErrLineSeqDi0                                 :1          ; //Bits :[16:16], initial value: 0x0. Mask Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiZIntMaskLine, TRegMipiZIntMaskLine, *PTRegMipiZIntMaskLine;                                //0x411B4

//LINE Interrupts force
//initial value: 0x0
typedef union __RegMipiZIntForceLine{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_read;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_write;
    struct {
        uint32_t ForceErrLineBndryMatchDi0                         :1          ; //Bits :[0:0], initial value: 0x0. Force Error matching line start with line end for vc0 and dt0
        uint32_t ForceErrLineBndryMatchDi1                         :1          ; //Bits :[1:1], initial value: 0x0. Force Error matching line start with line end for vc1 and dt1
        uint32_t ForceErrLineBndryMatchDi2                         :1          ; //Bits :[2:2], initial value: 0x0. Force Error matching line start with line end for vc2 and dt2
        uint32_t ForceErrLineBndryMatchDi3                         :1          ; //Bits :[3:3], initial value: 0x0. Force Error matching line start with line end for vc3 and dt3
        uint32_t ForceErrLineBndryMatchDi4                         :1          ; //Bits :[4:4], initial value: 0x0. Force Error matching line start with line end for vc4 and dt4
        uint32_t ForceErrLineBndryMatchDi5                         :1          ; //Bits :[5:5], initial value: 0x0. Force Error matching line start with line end for vc5 and dt5
        uint32_t ForceErrLineBndryMatchDi6                         :1          ; //Bits :[6:6], initial value: 0x0. Force Error matching line start with line end for vc6 and dt6
        uint32_t ForceErrLineBndryMatchDi7                         :1          ; //Bits :[7:7], initial value: 0x0. Force Error matching line start with line end for vc7 and dt7
        uint32_t Reserved8                                         :8          ; //Bits :[8:15], initial value: 0x0 Reserved.
        uint32_t ForceErrLineSeqDi0                                :1          ; //Bits :[16:16], initial value: 0x0. Force Error in the sequence of lines for vc0 and dt0
     } fields_rmw; //for non-shadowed register
} RegMipiZIntForceLine, TRegMipiZIntForceLine, *PTRegMipiZIntForceLine;                                //0x411B8

//##############################################################
//                      mtr_registers area
//##############################################################
//MIPI Transmitter control and status
//initial value: 0x00640000
typedef union __RegMtrTransmitterControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TransmitterEnable                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable.  When disabled, any packet in process will finsh, then the clock will will be put in low-power mode.
        uint32_t TransmitterBusyStatus                             :1          ; //Bits :[1:1], initial value: 0x0. read-only: 0: transmitter is idle, 1: transmitter is busy
        uint32_t ModuleMode                                        :1          ; //Bits :[2:2], initial value: 0x0. Operating mode.  0: transmitter,  1: receiver.  Note this is forced to 0 if the module is built as a 4 lane transmitter
        uint32_t FifoUnderflow                                     :1          ; //Bits :[3:3], initial value: 0x0. read-only: 0: FIFO OK  1: FIFO underflow.  Reset by clearing Transmitter_Enable
        uint32_t Reserved                                          :12         ; //Bits :[4:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ClockTurnoffTimer                                 :16         ; //Bits :[16:31], initial value: 0x64. Specifies an idle timer to disable the high-speed-clock.  0 disables this function.  The timer counts at an s_clk rate.
     } fields_read;
    struct {
        uint32_t TransmitterEnable                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable.  When disabled, any packet in process will finsh, then the clock will will be put in low-power mode.
        uint32_t TransmitterBusyStatus                             :1          ; //Bits :[1:1], initial value: 0x0. read-only: 0: transmitter is idle, 1: transmitter is busy
        uint32_t ModuleMode                                        :1          ; //Bits :[2:2], initial value: 0x0. Operating mode.  0: transmitter,  1: receiver.  Note this is forced to 0 if the module is built as a 4 lane transmitter
        uint32_t FifoUnderflow                                     :1          ; //Bits :[3:3], initial value: 0x0. read-only: 0: FIFO OK  1: FIFO underflow.  Reset by clearing Transmitter_Enable
        uint32_t Reserved                                          :12         ; //Bits :[4:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ClockTurnoffTimer                                 :16         ; //Bits :[16:31], initial value: 0x64. Specifies an idle timer to disable the high-speed-clock.  0 disables this function.  The timer counts at an s_clk rate.
     } fields_write;
    struct {
        uint32_t TransmitterEnable                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable.  When disabled, any packet in process will finsh, then the clock will will be put in low-power mode.
        uint32_t TransmitterBusyStatus                             :1          ; //Bits :[1:1], initial value: 0x0. read-only: 0: transmitter is idle, 1: transmitter is busy
        uint32_t ModuleMode                                        :1          ; //Bits :[2:2], initial value: 0x0. Operating mode.  0: transmitter,  1: receiver.  Note this is forced to 0 if the module is built as a 4 lane transmitter
        uint32_t FifoUnderflow                                     :1          ; //Bits :[3:3], initial value: 0x0. read-only: 0: FIFO OK  1: FIFO underflow.  Reset by clearing Transmitter_Enable
        uint32_t Reserved                                          :12         ; //Bits :[4:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ClockTurnoffTimer                                 :16         ; //Bits :[16:31], initial value: 0x64. Specifies an idle timer to disable the high-speed-clock.  0 disables this function.  The timer counts at an s_clk rate.
     } fields_rmw; //for non-shadowed register
} RegMtrTransmitterControl, TRegMtrTransmitterControl, *PTRegMtrTransmitterControl;                                //0x41404

//DPhy control and status
//initial value: 0xa0000000
typedef union __RegMtrDphyControlStatus{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TransmitterDataLanesEnable                        :4          ; //Bits :[0:3], initial value: 0x0. Enables the desired number of tansmitter lanes.  Legal value are 0x1, 0x3, 0xf. 0 disables all data lanes
        uint32_t TransmitterClockLaneEnable                        :1          ; //Bits :[4:4], initial value: 0x0. Transmitter clock lane enable.  Should be a 1 for normal operation
        uint32_t Txulpsrequest                                     :1          ; //Bits :[5:5], initial value: 0x0. Ultra-low-power request.  0: normal operation,  1: initiate ULPS
        uint32_t Txulpsexit                                        :1          ; //Bits :[6:6], initial value: 0x0. Ultra-low-power exit.  0: normal operation,  1: exit ULPS
        uint32_t TxulpsstatusNot                                   :1          ; //Bits :[7:7], initial value: 0x0. read-only: Ultra-low-power Status.  0: ULPS active,  1: normal operation
        uint32_t DataLanesStopState                                :4          ; //Bits :[8:11], initial value: 0x0. read-only: Status bits indicating which data lanes are in the Stop State
        uint32_t ClockLaneStopState                                :1          ; //Bits :[12:12], initial value: 0x0. read-only: Status bit indicating if clock lane is in the Stop State
        uint32_t Forcepll                                          :1          ; //Bits :[13:13], initial value: 0x0. Force PLL operation.  0: normal operation (PLL disabled when not needed),  1: PLL always enabled
        uint32_t TxPktDelay                                        :6          ; //Bits :[14:19], initial value: 0x0. Set inter-tx-packet delay.
        uint32_t Reserved                                          :9          ; //Bits :[20:28], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DphyShutdown                                      :1          ; //Bits :[29:29], initial value: 0x1. Shutdown the DPhy for lower power.  0: normal operation,  1: shutdown
        uint32_t DphyPllLock                                       :1          ; //Bits :[30:30], initial value: 0x0. read-only: DPhy PLL lock status.  0: not-locked,  1: locked
        uint32_t DphyReset                                         :1          ; //Bits :[31:31], initial value: 0x1. DPhy reset request.  0: enable DPhy,  1: reset DPhy
     } fields_read;
    struct {
        uint32_t TransmitterDataLanesEnable                        :4          ; //Bits :[0:3], initial value: 0x0. Enables the desired number of tansmitter lanes.  Legal value are 0x1, 0x3, 0xf. 0 disables all data lanes
        uint32_t TransmitterClockLaneEnable                        :1          ; //Bits :[4:4], initial value: 0x0. Transmitter clock lane enable.  Should be a 1 for normal operation
        uint32_t Txulpsrequest                                     :1          ; //Bits :[5:5], initial value: 0x0. Ultra-low-power request.  0: normal operation,  1: initiate ULPS
        uint32_t Txulpsexit                                        :1          ; //Bits :[6:6], initial value: 0x0. Ultra-low-power exit.  0: normal operation,  1: exit ULPS
        uint32_t TxulpsstatusNot                                   :1          ; //Bits :[7:7], initial value: 0x0. read-only: Ultra-low-power Status.  0: ULPS active,  1: normal operation
        uint32_t DataLanesStopState                                :4          ; //Bits :[8:11], initial value: 0x0. read-only: Status bits indicating which data lanes are in the Stop State
        uint32_t ClockLaneStopState                                :1          ; //Bits :[12:12], initial value: 0x0. read-only: Status bit indicating if clock lane is in the Stop State
        uint32_t Forcepll                                          :1          ; //Bits :[13:13], initial value: 0x0. Force PLL operation.  0: normal operation (PLL disabled when not needed),  1: PLL always enabled
        uint32_t TxPktDelay                                        :6          ; //Bits :[14:19], initial value: 0x0. Set inter-tx-packet delay.
        uint32_t Reserved                                          :9          ; //Bits :[20:28], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DphyShutdown                                      :1          ; //Bits :[29:29], initial value: 0x1. Shutdown the DPhy for lower power.  0: normal operation,  1: shutdown
        uint32_t DphyPllLock                                       :1          ; //Bits :[30:30], initial value: 0x0. read-only: DPhy PLL lock status.  0: not-locked,  1: locked
        uint32_t DphyReset                                         :1          ; //Bits :[31:31], initial value: 0x1. DPhy reset request.  0: enable DPhy,  1: reset DPhy
     } fields_write;
    struct {
        uint32_t TransmitterDataLanesEnable                        :4          ; //Bits :[0:3], initial value: 0x0. Enables the desired number of tansmitter lanes.  Legal value are 0x1, 0x3, 0xf. 0 disables all data lanes
        uint32_t TransmitterClockLaneEnable                        :1          ; //Bits :[4:4], initial value: 0x0. Transmitter clock lane enable.  Should be a 1 for normal operation
        uint32_t Txulpsrequest                                     :1          ; //Bits :[5:5], initial value: 0x0. Ultra-low-power request.  0: normal operation,  1: initiate ULPS
        uint32_t Txulpsexit                                        :1          ; //Bits :[6:6], initial value: 0x0. Ultra-low-power exit.  0: normal operation,  1: exit ULPS
        uint32_t TxulpsstatusNot                                   :1          ; //Bits :[7:7], initial value: 0x0. read-only: Ultra-low-power Status.  0: ULPS active,  1: normal operation
        uint32_t DataLanesStopState                                :4          ; //Bits :[8:11], initial value: 0x0. read-only: Status bits indicating which data lanes are in the Stop State
        uint32_t ClockLaneStopState                                :1          ; //Bits :[12:12], initial value: 0x0. read-only: Status bit indicating if clock lane is in the Stop State
        uint32_t Forcepll                                          :1          ; //Bits :[13:13], initial value: 0x0. Force PLL operation.  0: normal operation (PLL disabled when not needed),  1: PLL always enabled
        uint32_t TxPktDelay                                        :6          ; //Bits :[14:19], initial value: 0x0. Set inter-tx-packet delay.
        uint32_t Reserved                                          :9          ; //Bits :[20:28], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DphyShutdown                                      :1          ; //Bits :[29:29], initial value: 0x1. Shutdown the DPhy for lower power.  0: normal operation,  1: shutdown
        uint32_t DphyPllLock                                       :1          ; //Bits :[30:30], initial value: 0x0. read-only: DPhy PLL lock status.  0: not-locked,  1: locked
        uint32_t DphyReset                                         :1          ; //Bits :[31:31], initial value: 0x1. DPhy reset request.  0: enable DPhy,  1: reset DPhy
     } fields_rmw; //for non-shadowed register
} RegMtrDphyControlStatus, TRegMtrDphyControlStatus, *PTRegMtrDphyControlStatus;                                //0x41408

//DPhy test Port Access.  This enables access to the DPhy test and setup registers
//initial value: 0x0
typedef union __RegMtrDphyTestAccess{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TestPortWrData                                    :8          ; //Bits :[0:7], initial value: 0x0. Data/Addr byte to send to the Test Port
        uint32_t TestPortRdData                                    :8          ; //Bits :[8:15], initial value: 0x0. read-only: Test Port response byte
        uint32_t TestPortXferMode                                  :1          ; //Bits :[16:16], initial value: 0x0. Test Port byte transfer mode.  0: data cycle,  1: control/test_code load
        uint32_t Reserved                                          :13         ; //Bits :[17:29], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t TestPortClear                                     :1          ; //Bits :[30:30], initial value: 0x0. Test Port clear command, self reseting.  0: normal operation, 1: issue clear pulse
        uint32_t TestPortGo                                        :1          ; //Bits :[31:31], initial value: 0x0. Test Port GO command.  setting this bit will start the transfer of a byte of data or test_code between the DPhy and the control logic.  The bit will be cleared when the cycle is done.
     } fields_read;
    struct {
        uint32_t TestPortWrData                                    :8          ; //Bits :[0:7], initial value: 0x0. Data/Addr byte to send to the Test Port
        uint32_t TestPortRdData                                    :8          ; //Bits :[8:15], initial value: 0x0. read-only: Test Port response byte
        uint32_t TestPortXferMode                                  :1          ; //Bits :[16:16], initial value: 0x0. Test Port byte transfer mode.  0: data cycle,  1: control/test_code load
        uint32_t Reserved                                          :13         ; //Bits :[17:29], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t TestPortClear                                     :1          ; //Bits :[30:30], initial value: 0x0. Test Port clear command, self reseting.  0: normal operation, 1: issue clear pulse
        uint32_t TestPortGo                                        :1          ; //Bits :[31:31], initial value: 0x0. Test Port GO command.  setting this bit will start the transfer of a byte of data or test_code between the DPhy and the control logic.  The bit will be cleared when the cycle is done.
     } fields_write;
    struct {
        uint32_t TestPortWrData                                    :8          ; //Bits :[0:7], initial value: 0x0. Data/Addr byte to send to the Test Port
        uint32_t TestPortRdData                                    :8          ; //Bits :[8:15], initial value: 0x0. read-only: Test Port response byte
        uint32_t TestPortXferMode                                  :1          ; //Bits :[16:16], initial value: 0x0. Test Port byte transfer mode.  0: data cycle,  1: control/test_code load
        uint32_t Reserved                                          :13         ; //Bits :[17:29], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t TestPortClear                                     :1          ; //Bits :[30:30], initial value: 0x0. Test Port clear command, self reseting.  0: normal operation, 1: issue clear pulse
        uint32_t TestPortGo                                        :1          ; //Bits :[31:31], initial value: 0x0. Test Port GO command.  setting this bit will start the transfer of a byte of data or test_code between the DPhy and the control logic.  The bit will be cleared when the cycle is done.
     } fields_rmw; //for non-shadowed register
} RegMtrDphyTestAccess, TRegMtrDphyTestAccess, *PTRegMtrDphyTestAccess;                                //0x4140C

//ID and revision register
//initial value: 0xf00d0000
typedef union __RegMtrId{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Revision                                          :8          ; //Bits :[0:7], initial value: 0x0. Module revision number, initial value is 0
        uint32_t Configuration                                     :1          ; //Bits :[8:8], initial value: 0x0. Module configuration;  0: 4 lane MIPI TX;   1: 2 lane MIPI TX and RX
        uint32_t Reserved                                          :7          ; //Bits :[9:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t Cookie                                            :16         ; //Bits :[16:31], initial value: 0xF00D. fixed value of 0xF00D for diagnostics and simulation
     } fields_read;
    struct {
        uint32_t Revision                                          :8          ; //Bits :[0:7], initial value: 0x0. Module revision number, initial value is 0
        uint32_t Configuration                                     :1          ; //Bits :[8:8], initial value: 0x0. Module configuration;  0: 4 lane MIPI TX;   1: 2 lane MIPI TX and RX
        uint32_t Reserved                                          :7          ; //Bits :[9:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t Cookie                                            :16         ; //Bits :[16:31], initial value: 0xF00D. fixed value of 0xF00D for diagnostics and simulation
     } fields_rmw; //for non-shadowed register
} RegMtrId, TRegMtrId, *PTRegMtrId;                                //0x41400

//##############################################################
//                mtr_tx_rx_registers area
//##############################################################
//MIPI Transmitter control and status
//initial value: 0x00640000
typedef union __RegMtr_tx_rxTransmitterControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TransmitterEnable                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable.  When disabled, any packet in process will finsh, then the clock will will be put in low-power mode.
        uint32_t TransmitterBusyStatus                             :1          ; //Bits :[1:1], initial value: 0x0. read-only: 0: transmitter is idle, 1: transmitter is busy
        uint32_t ModuleMode                                        :1          ; //Bits :[2:2], initial value: 0x0. Operating mode.  0: transmitter,  1: receiver.  Note this is forced to 0 if the module is built as a 4 lane transmitter
        uint32_t FifoUnderflow                                     :1          ; //Bits :[3:3], initial value: 0x0. read-only: 0: FIFO OK  1: FIFO underflow.  Reset by clearing Transmitter_Enable
        uint32_t Reserved                                          :12         ; //Bits :[4:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ClockTurnoffTimer                                 :16         ; //Bits :[16:31], initial value: 0x64. Specifies an idle timer to disable the high-speed-clock.  0 disables this function.  The timer counts at an s_clk rate.
     } fields_read;
    struct {
        uint32_t TransmitterEnable                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable.  When disabled, any packet in process will finsh, then the clock will will be put in low-power mode.
        uint32_t TransmitterBusyStatus                             :1          ; //Bits :[1:1], initial value: 0x0. read-only: 0: transmitter is idle, 1: transmitter is busy
        uint32_t ModuleMode                                        :1          ; //Bits :[2:2], initial value: 0x0. Operating mode.  0: transmitter,  1: receiver.  Note this is forced to 0 if the module is built as a 4 lane transmitter
        uint32_t FifoUnderflow                                     :1          ; //Bits :[3:3], initial value: 0x0. read-only: 0: FIFO OK  1: FIFO underflow.  Reset by clearing Transmitter_Enable
        uint32_t Reserved                                          :12         ; //Bits :[4:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ClockTurnoffTimer                                 :16         ; //Bits :[16:31], initial value: 0x64. Specifies an idle timer to disable the high-speed-clock.  0 disables this function.  The timer counts at an s_clk rate.
     } fields_write;
    struct {
        uint32_t TransmitterEnable                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable.  When disabled, any packet in process will finsh, then the clock will will be put in low-power mode.
        uint32_t TransmitterBusyStatus                             :1          ; //Bits :[1:1], initial value: 0x0. read-only: 0: transmitter is idle, 1: transmitter is busy
        uint32_t ModuleMode                                        :1          ; //Bits :[2:2], initial value: 0x0. Operating mode.  0: transmitter,  1: receiver.  Note this is forced to 0 if the module is built as a 4 lane transmitter
        uint32_t FifoUnderflow                                     :1          ; //Bits :[3:3], initial value: 0x0. read-only: 0: FIFO OK  1: FIFO underflow.  Reset by clearing Transmitter_Enable
        uint32_t Reserved                                          :12         ; //Bits :[4:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ClockTurnoffTimer                                 :16         ; //Bits :[16:31], initial value: 0x64. Specifies an idle timer to disable the high-speed-clock.  0 disables this function.  The timer counts at an s_clk rate.
     } fields_rmw; //for non-shadowed register
} RegMtr_tx_rxTransmitterControl, TRegMtr_tx_rxTransmitterControl, *PTRegMtr_tx_rxTransmitterControl;                                //0x41004

//DPhy control and status
//initial value: 0xa0000000
typedef union __RegMtr_tx_rxDphyControlStatus{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TransmitterDataLanesEnable                        :4          ; //Bits :[0:3], initial value: 0x0. Enables the desired number of tansmitter lanes.  Legal value are 0x1, 0x3, 0xf. 0 disables all data lanes
        uint32_t TransmitterClockLaneEnable                        :1          ; //Bits :[4:4], initial value: 0x0. Transmitter clock lane enable.  Should be a 1 for normal operation
        uint32_t Txulpsrequest                                     :1          ; //Bits :[5:5], initial value: 0x0. Ultra-low-power request.  0: normal operation,  1: initiate ULPS
        uint32_t Txulpsexit                                        :1          ; //Bits :[6:6], initial value: 0x0. Ultra-low-power exit.  0: normal operation,  1: exit ULPS
        uint32_t TxulpsstatusNot                                   :1          ; //Bits :[7:7], initial value: 0x0. read-only: Ultra-low-power Status.  0: ULPS active,  1: normal operation
        uint32_t DataLanesStopState                                :4          ; //Bits :[8:11], initial value: 0x0. read-only: Status bits indicating which data lanes are in the Stop State
        uint32_t ClockLaneStopState                                :1          ; //Bits :[12:12], initial value: 0x0. read-only: Status bit indicating if clock lane is in the Stop State
        uint32_t Forcepll                                          :1          ; //Bits :[13:13], initial value: 0x0. Force PLL operation.  0: normal operation (PLL disabled when not needed),  1: PLL always enabled
        uint32_t TxPktDelay                                        :6          ; //Bits :[14:19], initial value: 0x0. Set inter-tx-packet delay.
        uint32_t Reserved                                          :9          ; //Bits :[20:28], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DphyShutdown                                      :1          ; //Bits :[29:29], initial value: 0x1. Shutdown the DPhy for lower power.  0: normal operation,  1: shutdown
        uint32_t DphyPllLock                                       :1          ; //Bits :[30:30], initial value: 0x0. read-only: DPhy PLL lock status.  0: not-locked,  1: locked
        uint32_t DphyReset                                         :1          ; //Bits :[31:31], initial value: 0x1. DPhy reset request.  0: enable DPhy,  1: reset DPhy
     } fields_read;
    struct {
        uint32_t TransmitterDataLanesEnable                        :4          ; //Bits :[0:3], initial value: 0x0. Enables the desired number of tansmitter lanes.  Legal value are 0x1, 0x3, 0xf. 0 disables all data lanes
        uint32_t TransmitterClockLaneEnable                        :1          ; //Bits :[4:4], initial value: 0x0. Transmitter clock lane enable.  Should be a 1 for normal operation
        uint32_t Txulpsrequest                                     :1          ; //Bits :[5:5], initial value: 0x0. Ultra-low-power request.  0: normal operation,  1: initiate ULPS
        uint32_t Txulpsexit                                        :1          ; //Bits :[6:6], initial value: 0x0. Ultra-low-power exit.  0: normal operation,  1: exit ULPS
        uint32_t TxulpsstatusNot                                   :1          ; //Bits :[7:7], initial value: 0x0. read-only: Ultra-low-power Status.  0: ULPS active,  1: normal operation
        uint32_t DataLanesStopState                                :4          ; //Bits :[8:11], initial value: 0x0. read-only: Status bits indicating which data lanes are in the Stop State
        uint32_t ClockLaneStopState                                :1          ; //Bits :[12:12], initial value: 0x0. read-only: Status bit indicating if clock lane is in the Stop State
        uint32_t Forcepll                                          :1          ; //Bits :[13:13], initial value: 0x0. Force PLL operation.  0: normal operation (PLL disabled when not needed),  1: PLL always enabled
        uint32_t TxPktDelay                                        :6          ; //Bits :[14:19], initial value: 0x0. Set inter-tx-packet delay.
        uint32_t Reserved                                          :9          ; //Bits :[20:28], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DphyShutdown                                      :1          ; //Bits :[29:29], initial value: 0x1. Shutdown the DPhy for lower power.  0: normal operation,  1: shutdown
        uint32_t DphyPllLock                                       :1          ; //Bits :[30:30], initial value: 0x0. read-only: DPhy PLL lock status.  0: not-locked,  1: locked
        uint32_t DphyReset                                         :1          ; //Bits :[31:31], initial value: 0x1. DPhy reset request.  0: enable DPhy,  1: reset DPhy
     } fields_write;
    struct {
        uint32_t TransmitterDataLanesEnable                        :4          ; //Bits :[0:3], initial value: 0x0. Enables the desired number of tansmitter lanes.  Legal value are 0x1, 0x3, 0xf. 0 disables all data lanes
        uint32_t TransmitterClockLaneEnable                        :1          ; //Bits :[4:4], initial value: 0x0. Transmitter clock lane enable.  Should be a 1 for normal operation
        uint32_t Txulpsrequest                                     :1          ; //Bits :[5:5], initial value: 0x0. Ultra-low-power request.  0: normal operation,  1: initiate ULPS
        uint32_t Txulpsexit                                        :1          ; //Bits :[6:6], initial value: 0x0. Ultra-low-power exit.  0: normal operation,  1: exit ULPS
        uint32_t TxulpsstatusNot                                   :1          ; //Bits :[7:7], initial value: 0x0. read-only: Ultra-low-power Status.  0: ULPS active,  1: normal operation
        uint32_t DataLanesStopState                                :4          ; //Bits :[8:11], initial value: 0x0. read-only: Status bits indicating which data lanes are in the Stop State
        uint32_t ClockLaneStopState                                :1          ; //Bits :[12:12], initial value: 0x0. read-only: Status bit indicating if clock lane is in the Stop State
        uint32_t Forcepll                                          :1          ; //Bits :[13:13], initial value: 0x0. Force PLL operation.  0: normal operation (PLL disabled when not needed),  1: PLL always enabled
        uint32_t TxPktDelay                                        :6          ; //Bits :[14:19], initial value: 0x0. Set inter-tx-packet delay.
        uint32_t Reserved                                          :9          ; //Bits :[20:28], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DphyShutdown                                      :1          ; //Bits :[29:29], initial value: 0x1. Shutdown the DPhy for lower power.  0: normal operation,  1: shutdown
        uint32_t DphyPllLock                                       :1          ; //Bits :[30:30], initial value: 0x0. read-only: DPhy PLL lock status.  0: not-locked,  1: locked
        uint32_t DphyReset                                         :1          ; //Bits :[31:31], initial value: 0x1. DPhy reset request.  0: enable DPhy,  1: reset DPhy
     } fields_rmw; //for non-shadowed register
} RegMtr_tx_rxDphyControlStatus, TRegMtr_tx_rxDphyControlStatus, *PTRegMtr_tx_rxDphyControlStatus;                                //0x41008

//DPhy test Port Access.  This enables access to the DPhy test and setup registers
//initial value: 0x0
typedef union __RegMtr_tx_rxDphyTestAccess{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TestPortWrData                                    :8          ; //Bits :[0:7], initial value: 0x0. Data/Addr byte to send to the Test Port
        uint32_t TestPortRdData                                    :8          ; //Bits :[8:15], initial value: 0x0. read-only: Test Port response byte
        uint32_t TestPortXferMode                                  :1          ; //Bits :[16:16], initial value: 0x0. Test Port byte transfer mode.  0: data cycle,  1: control/test_code load
        uint32_t Reserved                                          :13         ; //Bits :[17:29], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t TestPortClear                                     :1          ; //Bits :[30:30], initial value: 0x0. Test Port clear command, self reseting.  0: normal operation, 1: issue clear pulse
        uint32_t TestPortGo                                        :1          ; //Bits :[31:31], initial value: 0x0. Test Port GO command.  setting this bit will start the transfer of a byte of data or test_code between the DPhy and the control logic.  The bit will be cleared when the cycle is done.
     } fields_read;
    struct {
        uint32_t TestPortWrData                                    :8          ; //Bits :[0:7], initial value: 0x0. Data/Addr byte to send to the Test Port
        uint32_t TestPortRdData                                    :8          ; //Bits :[8:15], initial value: 0x0. read-only: Test Port response byte
        uint32_t TestPortXferMode                                  :1          ; //Bits :[16:16], initial value: 0x0. Test Port byte transfer mode.  0: data cycle,  1: control/test_code load
        uint32_t Reserved                                          :13         ; //Bits :[17:29], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t TestPortClear                                     :1          ; //Bits :[30:30], initial value: 0x0. Test Port clear command, self reseting.  0: normal operation, 1: issue clear pulse
        uint32_t TestPortGo                                        :1          ; //Bits :[31:31], initial value: 0x0. Test Port GO command.  setting this bit will start the transfer of a byte of data or test_code between the DPhy and the control logic.  The bit will be cleared when the cycle is done.
     } fields_write;
    struct {
        uint32_t TestPortWrData                                    :8          ; //Bits :[0:7], initial value: 0x0. Data/Addr byte to send to the Test Port
        uint32_t TestPortRdData                                    :8          ; //Bits :[8:15], initial value: 0x0. read-only: Test Port response byte
        uint32_t TestPortXferMode                                  :1          ; //Bits :[16:16], initial value: 0x0. Test Port byte transfer mode.  0: data cycle,  1: control/test_code load
        uint32_t Reserved                                          :13         ; //Bits :[17:29], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t TestPortClear                                     :1          ; //Bits :[30:30], initial value: 0x0. Test Port clear command, self reseting.  0: normal operation, 1: issue clear pulse
        uint32_t TestPortGo                                        :1          ; //Bits :[31:31], initial value: 0x0. Test Port GO command.  setting this bit will start the transfer of a byte of data or test_code between the DPhy and the control logic.  The bit will be cleared when the cycle is done.
     } fields_rmw; //for non-shadowed register
} RegMtr_tx_rxDphyTestAccess, TRegMtr_tx_rxDphyTestAccess, *PTRegMtr_tx_rxDphyTestAccess;                                //0x4100C

//ID and revision register
//initial value: 0xf00d0100
typedef union __RegMtr_tx_rxId{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Revision                                          :8          ; //Bits :[0:7], initial value: 0x0. Module revision number, initial value is 0
        uint32_t Configuration                                     :1          ; //Bits :[8:8], initial value: 0x1. Module configuration;  0: 4 lane MIPI TX;   1: 2 lane MIPI TX and RX
        uint32_t Reserved                                          :7          ; //Bits :[9:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t Cookie                                            :16         ; //Bits :[16:31], initial value: 0xF00D. fixed value of 0xF00D for diagnostics and simulation
     } fields_read;
    struct {
        uint32_t Revision                                          :8          ; //Bits :[0:7], initial value: 0x0. Module revision number, initial value is 0
        uint32_t Configuration                                     :1          ; //Bits :[8:8], initial value: 0x1. Module configuration;  0: 4 lane MIPI TX;   1: 2 lane MIPI TX and RX
        uint32_t Reserved                                          :7          ; //Bits :[9:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t Cookie                                            :16         ; //Bits :[16:31], initial value: 0xF00D. fixed value of 0xF00D for diagnostics and simulation
     } fields_rmw; //for non-shadowed register
} RegMtr_tx_rxId, TRegMtr_tx_rxId, *PTRegMtr_tx_rxId;                                //0x41000

//##############################################################
//                      rec_registers area
//##############################################################
//When run is set and vsync input occurs, Rectification Module captures the following frame.
//initial value: 0x00000000
typedef union __RegRecCaptureFrames{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Capture                                           :1          ; //Bits :[0:0], initial value: 0x0. Capture frame at vsync
        uint32_t ProcRwEnable                                      :1          ; //Bits :[1:1], initial value: 0x0. 1=enable processor r/w to buffer memory access;0=disable processor r/w to buffer memory
        uint32_t RecTestRegIfEn                                    :1          ; //Bits :[2:2], initial value: 0x0. 0 = use real camera interface; 1 = use REC Test Register Interface
        uint32_t RecTpgenEnable                                    :1          ; //Bits :[3:3], initial value: 0x0. 0 = test pattern generator disabled; 1 = test pattern generator enabled
        uint32_t RecErrchkDisable                                  :1          ; //Bits :[4:4], initial value: 0x0. 0 = input errchk enabled; 1 = input errchk disabled
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t Capture                                           :1          ; //Bits :[0:0], initial value: 0x0. Capture frame at vsync
        uint32_t ProcRwEnable                                      :1          ; //Bits :[1:1], initial value: 0x0. 1=enable processor r/w to buffer memory access;0=disable processor r/w to buffer memory
        uint32_t RecTestRegIfEn                                    :1          ; //Bits :[2:2], initial value: 0x0. 0 = use real camera interface; 1 = use REC Test Register Interface
        uint32_t RecTpgenEnable                                    :1          ; //Bits :[3:3], initial value: 0x0. 0 = test pattern generator disabled; 1 = test pattern generator enabled
        uint32_t RecErrchkDisable                                  :1          ; //Bits :[4:4], initial value: 0x0. 0 = input errchk enabled; 1 = input errchk disabled
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t Capture                                           :1          ; //Bits :[0:0], initial value: 0x0. Capture frame at vsync
        uint32_t ProcRwEnable                                      :1          ; //Bits :[1:1], initial value: 0x0. 1=enable processor r/w to buffer memory access;0=disable processor r/w to buffer memory
        uint32_t RecTestRegIfEn                                    :1          ; //Bits :[2:2], initial value: 0x0. 0 = use real camera interface; 1 = use REC Test Register Interface
        uint32_t RecTpgenEnable                                    :1          ; //Bits :[3:3], initial value: 0x0. 0 = test pattern generator disabled; 1 = test pattern generator enabled
        uint32_t RecErrchkDisable                                  :1          ; //Bits :[4:4], initial value: 0x0. 0 = input errchk enabled; 1 = input errchk disabled
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecCaptureFrames, TRegRecCaptureFrames, *PTRegRecCaptureFrames;                               //0x100000

//The blanking time between frames, in pixel clocks (five sclks).
//initial value: 0x00000000
typedef union __RegRecVerticalBlankingTime{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Vblank                                            :16         ; //Bits :[0:15], initial value: 0x0.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t Vblank                                            :16         ; //Bits :[0:15], initial value: 0x0.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t Vblank                                            :16         ; //Bits :[0:15], initial value: 0x0.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecVerticalBlankingTime, TRegRecVerticalBlankingTime, *PTRegRecVerticalBlankingTime;                               //0x100004

//The initial position for right image data in Pixel Buffer
//initial value: 0x2000
typedef union __RegRecPixelBufferRightOffset{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RightOffset                                       :14         ; //Bits :[0:13], initial value: 0x2000.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t RightOffset                                       :14         ; //Bits :[0:13], initial value: 0x2000.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t RightOffset                                       :14         ; //Bits :[0:13], initial value: 0x2000.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecPixelBufferRightOffset, TRegRecPixelBufferRightOffset, *PTRegRecPixelBufferRightOffset;                               //0x100008

//Control clock gating and memory sleep
//initial value: 0x00
typedef union __RegRecRecPowerControl{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t LsChiknBit                                        :1          ; //Bits :[0:0], initial value: 0x0. enable light sleep for Rec memories
        uint32_t AdrgenChiknBit                                    :1          ; //Bits :[1:1], initial value: 0x0. if set, enable clock gating for adrgen module
        uint32_t ScpHaltChiknBit                                   :1          ; //Bits :[2:2], initial value: 0x0. if set, enable clock gating during scp_rec_halt
        uint32_t VdfHaltChiknBit                                   :1          ; //Bits :[3:3], initial value: 0x0. if set, enable clock gating during vdf_halt
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecRecPowerControl, TRegRecRecPowerControl, *PTRegRecRecPowerControl;                               //0x10000C

//Control number of sclks per pixel
//initial value: 0x00
typedef union __RegRecRecPixelPacing{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t PacingSclkCount                                   :6          ; //Bits :[0:5], initial value: 0x0. register value plus 5 is number of sclks per pixel
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecRecPixelPacing, TRegRecRecPixelPacing, *PTRegRecRecPixelPacing;                               //0x100010

//The number of input lines after the requested pixel that the Rec waits to start processing
//initial value: 0x00
typedef union __RegRecRecBufferFill{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t InputLineCount                                    :8          ; //Bits :[0:7], initial value: 0x0. extra input lines buffered
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecRecBufferFill, TRegRecRecBufferFill, *PTRegRecRecBufferFill;                               //0x100014

//number of lines (times four) to add to the write position when predicting overflow during vdf_halt.
//initial value: 0xf1
typedef union __RegRecRecHaltLineMargin{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t HaltLineMargin                                    :4          ; //Bits :[0:3], initial value: 0x1. number of lines (times four) between write and read buffer locations to restart data flow, enter ignore vdf_halt.
        uint32_t HaltLineHysteresis                                :4          ; //Bits :[4:7], initial value: 0xF. number of lines (times four) between write and read buffer locations to exit ignore vdf_halt.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecRecHaltLineMargin, TRegRecRecHaltLineMargin, *PTRegRecRecHaltLineMargin;                               //0x100018

//turn Rec on for M frames and off for N frames
//initial value: 0x00
typedef union __RegRecRecRunOnOff{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t MOnFrameCount                                     :8          ; //Bits :[0:7], initial value: 0x0. number of frames the Rec processes
        uint32_t NOffFrameCount                                    :8          ; //Bits :[8:15], initial value: 0x0. number of frames the Rec skips
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecRecRunOnOff, TRegRecRecRunOnOff, *PTRegRecRecRunOnOff;                               //0x10001C

//Rectification remap matrix coefficient 1 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A11                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients1, TRegRecC0b0LeftMatrixCoefficients1, *PTRegRecC0b0LeftMatrixCoefficients1;                               //0x100020

//Rectification remap matrix coefficient 2 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A12                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients2, TRegRecC0b0LeftMatrixCoefficients2, *PTRegRecC0b0LeftMatrixCoefficients2;                               //0x100024

//Rectification remap matrix coefficient 3 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A13                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients3, TRegRecC0b0LeftMatrixCoefficients3, *PTRegRecC0b0LeftMatrixCoefficients3;                               //0x100028

//Rectification remap matrix coefficient 4 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A21                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients4, TRegRecC0b0LeftMatrixCoefficients4, *PTRegRecC0b0LeftMatrixCoefficients4;                               //0x10002C

//Rectification remap matrix coefficient 5 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A22                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients5, TRegRecC0b0LeftMatrixCoefficients5, *PTRegRecC0b0LeftMatrixCoefficients5;                               //0x100030

//Rectification remap matrix coefficient 6 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients6{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A23                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients6, TRegRecC0b0LeftMatrixCoefficients6, *PTRegRecC0b0LeftMatrixCoefficients6;                               //0x100034

//Rectification remap matrix coefficient 7 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients7{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A31                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients7, TRegRecC0b0LeftMatrixCoefficients7, *PTRegRecC0b0LeftMatrixCoefficients7;                               //0x100038

//Rectification remap matrix coefficient 8 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients8{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A32                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients8, TRegRecC0b0LeftMatrixCoefficients8, *PTRegRecC0b0LeftMatrixCoefficients8;                               //0x10003C

//Rectification remap matrix coefficient 9 for C0B0 Left
//initial value: 0x00000000
typedef union __RegRecC0b0LeftMatrixCoefficients9{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A33                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0LeftMatrixCoefficients9, TRegRecC0b0LeftMatrixCoefficients9, *PTRegRecC0b0LeftMatrixCoefficients9;                               //0x100040

//Rectification Distortion Parameters 1 for C0B0 Left
//initial value: 0x000000
typedef union __RegRecC0b0LeftDistortionParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K0                                                :24         ; //Bits :[0:23], initial value: 0x0.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftDistortionParameters1, TRegRecC0b0LeftDistortionParameters1, *PTRegRecC0b0LeftDistortionParameters1;                               //0x100044

//Rectification Distortion Parameters 2 for C0B0 Left
//initial value: 0x000000
typedef union __RegRecC0b0LeftDistortionParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1                                                :22         ; //Bits :[0:21], initial value: 0x0.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftDistortionParameters2, TRegRecC0b0LeftDistortionParameters2, *PTRegRecC0b0LeftDistortionParameters2;                               //0x100048

//Rectification Distortion Parameters 3 for C0B0 Left
//initial value: 0x00000
typedef union __RegRecC0b0LeftDistortionParameters3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftDistortionParameters3, TRegRecC0b0LeftDistortionParameters3, *PTRegRecC0b0LeftDistortionParameters3;                               //0x10004C

//Rectification Distortion Parameters 4 for C0B0 Left
//initial value: 0x00000
typedef union __RegRecC0b0LeftDistortionParameters4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K3                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftDistortionParameters4, TRegRecC0b0LeftDistortionParameters4, *PTRegRecC0b0LeftDistortionParameters4;                               //0x100050

//Rectification Distortion Parameters 5 for C0B0 Left
//initial value: 0x00000
typedef union __RegRecC0b0LeftDistortionParameters5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K4                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftDistortionParameters5, TRegRecC0b0LeftDistortionParameters5, *PTRegRecC0b0LeftDistortionParameters5;                               //0x100054

//Rectification Focal Length Parameters 1 for C0B0 Left
//initial value: 0x00000
typedef union __RegRecC0b0LeftFocalLengthParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F0                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftFocalLengthParameters1, TRegRecC0b0LeftFocalLengthParameters1, *PTRegRecC0b0LeftFocalLengthParameters1;                               //0x100058

//Rectification Focal Length Parameters 2 for C0B0 Left
//initial value: 0x00000
typedef union __RegRecC0b0LeftFocalLengthParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F1                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftFocalLengthParameters2, TRegRecC0b0LeftFocalLengthParameters2, *PTRegRecC0b0LeftFocalLengthParameters2;                               //0x10005C

//Rectification Center Parameters 1 for C0B0 Left
//initial value: 0x00000
typedef union __RegRecC0b0LeftCenterParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C0                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftCenterParameters1, TRegRecC0b0LeftCenterParameters1, *PTRegRecC0b0LeftCenterParameters1;                               //0x100060

//Rectification Center Parameters 2 for C0B0 Left
//initial value: 0x00000
typedef union __RegRecC0b0LeftCenterParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C1                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0LeftCenterParameters2, TRegRecC0b0LeftCenterParameters2, *PTRegRecC0b0LeftCenterParameters2;                               //0x100064

//Rectification remap matrix coefficient 1 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A11                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients1, TRegRecC0b0RightMatrixCoefficients1, *PTRegRecC0b0RightMatrixCoefficients1;                               //0x100070

//Rectification remap matrix coefficient 2 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A12                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients2, TRegRecC0b0RightMatrixCoefficients2, *PTRegRecC0b0RightMatrixCoefficients2;                               //0x100074

//Rectification remap matrix coefficient 3 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A13                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients3, TRegRecC0b0RightMatrixCoefficients3, *PTRegRecC0b0RightMatrixCoefficients3;                               //0x100078

//Rectification remap matrix coefficient 4 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A21                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients4, TRegRecC0b0RightMatrixCoefficients4, *PTRegRecC0b0RightMatrixCoefficients4;                               //0x10007C

//Rectification remap matrix coefficient 5 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A22                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients5, TRegRecC0b0RightMatrixCoefficients5, *PTRegRecC0b0RightMatrixCoefficients5;                               //0x100080

//Rectification remap matrix coefficient 6 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients6{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A23                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients6, TRegRecC0b0RightMatrixCoefficients6, *PTRegRecC0b0RightMatrixCoefficients6;                               //0x100084

//Rectification remap matrix coefficient 7 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients7{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A31                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients7, TRegRecC0b0RightMatrixCoefficients7, *PTRegRecC0b0RightMatrixCoefficients7;                               //0x100088

//Rectification remap matrix coefficient 8 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients8{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A32                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients8, TRegRecC0b0RightMatrixCoefficients8, *PTRegRecC0b0RightMatrixCoefficients8;                               //0x10008C

//Rectification remap matrix coefficient 9 for C0B0 Right
//initial value: 0x00000000
typedef union __RegRecC0b0RightMatrixCoefficients9{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A33                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b0RightMatrixCoefficients9, TRegRecC0b0RightMatrixCoefficients9, *PTRegRecC0b0RightMatrixCoefficients9;                               //0x100090

//Rectification Distortion Parameters 1 for C0B0 Right
//initial value: 0x000000
typedef union __RegRecC0b0RightDistortionParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K0                                                :24         ; //Bits :[0:23], initial value: 0x0.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightDistortionParameters1, TRegRecC0b0RightDistortionParameters1, *PTRegRecC0b0RightDistortionParameters1;                               //0x100094

//Rectification Distortion Parameters 2 for C0B0 Right
//initial value: 0x000000
typedef union __RegRecC0b0RightDistortionParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1                                                :22         ; //Bits :[0:21], initial value: 0x0.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightDistortionParameters2, TRegRecC0b0RightDistortionParameters2, *PTRegRecC0b0RightDistortionParameters2;                               //0x100098

//Rectification Distortion Parameters 3 for C0B0 Right
//initial value: 0x00000
typedef union __RegRecC0b0RightDistortionParameters3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightDistortionParameters3, TRegRecC0b0RightDistortionParameters3, *PTRegRecC0b0RightDistortionParameters3;                               //0x10009C

//Rectification Distortion Parameters 4 for C0B0 Right
//initial value: 0x00000
typedef union __RegRecC0b0RightDistortionParameters4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K3                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightDistortionParameters4, TRegRecC0b0RightDistortionParameters4, *PTRegRecC0b0RightDistortionParameters4;                               //0x1000A0

//Rectification Distortion Parameters 5 for C0B0 Right
//initial value: 0x00000
typedef union __RegRecC0b0RightDistortionParameters5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K4                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightDistortionParameters5, TRegRecC0b0RightDistortionParameters5, *PTRegRecC0b0RightDistortionParameters5;                               //0x1000A4

//Rectification Focal Length Parameters 1 for C0B0 Right
//initial value: 0x00000
typedef union __RegRecC0b0RightFocalLengthParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F0                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightFocalLengthParameters1, TRegRecC0b0RightFocalLengthParameters1, *PTRegRecC0b0RightFocalLengthParameters1;                               //0x1000A8

//Rectification Focal Length Parameters 2 for C0B0 Right
//initial value: 0x00000
typedef union __RegRecC0b0RightFocalLengthParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F1                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightFocalLengthParameters2, TRegRecC0b0RightFocalLengthParameters2, *PTRegRecC0b0RightFocalLengthParameters2;                               //0x1000AC

//Rectification Center Parameters 1 for C0B0 Right
//initial value: 0x00000
typedef union __RegRecC0b0RightCenterParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C0                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightCenterParameters1, TRegRecC0b0RightCenterParameters1, *PTRegRecC0b0RightCenterParameters1;                               //0x1000B0

//Rectification Center Parameters 2 for C0B0 Right
//initial value: 0x00000
typedef union __RegRecC0b0RightCenterParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C1                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b0RightCenterParameters2, TRegRecC0b0RightCenterParameters2, *PTRegRecC0b0RightCenterParameters2;                               //0x1000B4

//Rectification remap matrix coefficient 1 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A11                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients1, TRegRecC0b1LeftMatrixCoefficients1, *PTRegRecC0b1LeftMatrixCoefficients1;                               //0x1000C0

//Rectification remap matrix coefficient 2 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A12                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients2, TRegRecC0b1LeftMatrixCoefficients2, *PTRegRecC0b1LeftMatrixCoefficients2;                               //0x1000C4

//Rectification remap matrix coefficient 3 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A13                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients3, TRegRecC0b1LeftMatrixCoefficients3, *PTRegRecC0b1LeftMatrixCoefficients3;                               //0x1000C8

//Rectification remap matrix coefficient 4 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A21                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients4, TRegRecC0b1LeftMatrixCoefficients4, *PTRegRecC0b1LeftMatrixCoefficients4;                               //0x1000CC

//Rectification remap matrix coefficient 5 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A22                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients5, TRegRecC0b1LeftMatrixCoefficients5, *PTRegRecC0b1LeftMatrixCoefficients5;                               //0x1000D0

//Rectification remap matrix coefficient 6 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients6{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A23                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients6, TRegRecC0b1LeftMatrixCoefficients6, *PTRegRecC0b1LeftMatrixCoefficients6;                               //0x1000D4

//Rectification remap matrix coefficient 7 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients7{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A31                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients7, TRegRecC0b1LeftMatrixCoefficients7, *PTRegRecC0b1LeftMatrixCoefficients7;                               //0x1000D8

//Rectification remap matrix coefficient 8 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients8{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A32                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients8, TRegRecC0b1LeftMatrixCoefficients8, *PTRegRecC0b1LeftMatrixCoefficients8;                               //0x1000DC

//Rectification remap matrix coefficient 9 for C0B1 Left
//initial value: 0x00000000
typedef union __RegRecC0b1LeftMatrixCoefficients9{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A33                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1LeftMatrixCoefficients9, TRegRecC0b1LeftMatrixCoefficients9, *PTRegRecC0b1LeftMatrixCoefficients9;                               //0x1000E0

//Rectification Distortion Parameters 1 for C0B1 Left
//initial value: 0x000000
typedef union __RegRecC0b1LeftDistortionParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K0                                                :24         ; //Bits :[0:23], initial value: 0x0.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftDistortionParameters1, TRegRecC0b1LeftDistortionParameters1, *PTRegRecC0b1LeftDistortionParameters1;                               //0x1000E4

//Rectification Distortion Parameters 2 for C0B1 Left
//initial value: 0x000000
typedef union __RegRecC0b1LeftDistortionParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1                                                :22         ; //Bits :[0:21], initial value: 0x0.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftDistortionParameters2, TRegRecC0b1LeftDistortionParameters2, *PTRegRecC0b1LeftDistortionParameters2;                               //0x1000E8

//Rectification Distortion Parameters 3 for C0B1 Left
//initial value: 0x00000
typedef union __RegRecC0b1LeftDistortionParameters3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftDistortionParameters3, TRegRecC0b1LeftDistortionParameters3, *PTRegRecC0b1LeftDistortionParameters3;                               //0x1000EC

//Rectification Distortion Parameters 4 for C0B1 Left
//initial value: 0x00000
typedef union __RegRecC0b1LeftDistortionParameters4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K3                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftDistortionParameters4, TRegRecC0b1LeftDistortionParameters4, *PTRegRecC0b1LeftDistortionParameters4;                               //0x1000F0

//Rectification Distortion Parameters 5 for C0B1 Left
//initial value: 0x00000
typedef union __RegRecC0b1LeftDistortionParameters5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K4                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftDistortionParameters5, TRegRecC0b1LeftDistortionParameters5, *PTRegRecC0b1LeftDistortionParameters5;                               //0x1000F4

//Rectification Focal Length Parameters 1 for C0B1 Left
//initial value: 0x00000
typedef union __RegRecC0b1LeftFocalLengthParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F0                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftFocalLengthParameters1, TRegRecC0b1LeftFocalLengthParameters1, *PTRegRecC0b1LeftFocalLengthParameters1;                               //0x1000F8

//Rectification Focal Length Parameters 2 for C0B1 Left
//initial value: 0x00000
typedef union __RegRecC0b1LeftFocalLengthParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F1                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftFocalLengthParameters2, TRegRecC0b1LeftFocalLengthParameters2, *PTRegRecC0b1LeftFocalLengthParameters2;                               //0x1000FC

//Rectification Center Parameters 1 for C0B1 Left
//initial value: 0x00000
typedef union __RegRecC0b1LeftCenterParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C0                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftCenterParameters1, TRegRecC0b1LeftCenterParameters1, *PTRegRecC0b1LeftCenterParameters1;                               //0x100100

//Rectification Center Parameters 2 for C0B1 Left
//initial value: 0x00000
typedef union __RegRecC0b1LeftCenterParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C1                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1LeftCenterParameters2, TRegRecC0b1LeftCenterParameters2, *PTRegRecC0b1LeftCenterParameters2;                               //0x100104

//Rectification remap matrix coefficient 1 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A11                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients1, TRegRecC0b1RightMatrixCoefficients1, *PTRegRecC0b1RightMatrixCoefficients1;                               //0x100110

//Rectification remap matrix coefficient 2 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A12                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients2, TRegRecC0b1RightMatrixCoefficients2, *PTRegRecC0b1RightMatrixCoefficients2;                               //0x100114

//Rectification remap matrix coefficient 3 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A13                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients3, TRegRecC0b1RightMatrixCoefficients3, *PTRegRecC0b1RightMatrixCoefficients3;                               //0x100118

//Rectification remap matrix coefficient 4 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A21                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients4, TRegRecC0b1RightMatrixCoefficients4, *PTRegRecC0b1RightMatrixCoefficients4;                               //0x10011C

//Rectification remap matrix coefficient 5 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A22                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients5, TRegRecC0b1RightMatrixCoefficients5, *PTRegRecC0b1RightMatrixCoefficients5;                               //0x100120

//Rectification remap matrix coefficient 6 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients6{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A23                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients6, TRegRecC0b1RightMatrixCoefficients6, *PTRegRecC0b1RightMatrixCoefficients6;                               //0x100124

//Rectification remap matrix coefficient 7 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients7{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A31                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients7, TRegRecC0b1RightMatrixCoefficients7, *PTRegRecC0b1RightMatrixCoefficients7;                               //0x100128

//Rectification remap matrix coefficient 8 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients8{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A32                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients8, TRegRecC0b1RightMatrixCoefficients8, *PTRegRecC0b1RightMatrixCoefficients8;                               //0x10012C

//Rectification remap matrix coefficient 9 for C0B1 Right
//initial value: 0x00000000
typedef union __RegRecC0b1RightMatrixCoefficients9{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A33                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC0b1RightMatrixCoefficients9, TRegRecC0b1RightMatrixCoefficients9, *PTRegRecC0b1RightMatrixCoefficients9;                               //0x100130

//Rectification Distortion Parameters 1 for C0B1 Right
//initial value: 0x000000
typedef union __RegRecC0b1RightDistortionParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K0                                                :24         ; //Bits :[0:23], initial value: 0x0.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightDistortionParameters1, TRegRecC0b1RightDistortionParameters1, *PTRegRecC0b1RightDistortionParameters1;                               //0x100134

//Rectification Distortion Parameters 2 for C0B1 Right
//initial value: 0x000000
typedef union __RegRecC0b1RightDistortionParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1                                                :22         ; //Bits :[0:21], initial value: 0x0.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightDistortionParameters2, TRegRecC0b1RightDistortionParameters2, *PTRegRecC0b1RightDistortionParameters2;                               //0x100138

//Rectification Distortion Parameters 3 for C0B1 Right
//initial value: 0x00000
typedef union __RegRecC0b1RightDistortionParameters3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightDistortionParameters3, TRegRecC0b1RightDistortionParameters3, *PTRegRecC0b1RightDistortionParameters3;                               //0x10013C

//Rectification Distortion Parameters 4 for C0B1 Right
//initial value: 0x00000
typedef union __RegRecC0b1RightDistortionParameters4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K3                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightDistortionParameters4, TRegRecC0b1RightDistortionParameters4, *PTRegRecC0b1RightDistortionParameters4;                               //0x100140

//Rectification Distortion Parameters 5 for C0B1 Right
//initial value: 0x00000
typedef union __RegRecC0b1RightDistortionParameters5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K4                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightDistortionParameters5, TRegRecC0b1RightDistortionParameters5, *PTRegRecC0b1RightDistortionParameters5;                               //0x100144

//Rectification Focal Length Parameters 1 for C0B1 Right
//initial value: 0x00000
typedef union __RegRecC0b1RightFocalLengthParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F0                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightFocalLengthParameters1, TRegRecC0b1RightFocalLengthParameters1, *PTRegRecC0b1RightFocalLengthParameters1;                               //0x100148

//Rectification Focal Length Parameters 2 for C0B1 Right
//initial value: 0x00000
typedef union __RegRecC0b1RightFocalLengthParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F1                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightFocalLengthParameters2, TRegRecC0b1RightFocalLengthParameters2, *PTRegRecC0b1RightFocalLengthParameters2;                               //0x10014C

//Rectification Center Parameters 1 for C0B1 Right
//initial value: 0x00000
typedef union __RegRecC0b1RightCenterParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C0                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightCenterParameters1, TRegRecC0b1RightCenterParameters1, *PTRegRecC0b1RightCenterParameters1;                               //0x100150

//Rectification Center Parameters 2 for C0B1 Right
//initial value: 0x00000
typedef union __RegRecC0b1RightCenterParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C1                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC0b1RightCenterParameters2, TRegRecC0b1RightCenterParameters2, *PTRegRecC0b1RightCenterParameters2;                               //0x100154

//Rectification remap matrix coefficient 1 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A11                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients1, TRegRecC1b0LeftMatrixCoefficients1, *PTRegRecC1b0LeftMatrixCoefficients1;                               //0x100160

//Rectification remap matrix coefficient 2 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A12                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients2, TRegRecC1b0LeftMatrixCoefficients2, *PTRegRecC1b0LeftMatrixCoefficients2;                               //0x100164

//Rectification remap matrix coefficient 3 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A13                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients3, TRegRecC1b0LeftMatrixCoefficients3, *PTRegRecC1b0LeftMatrixCoefficients3;                               //0x100168

//Rectification remap matrix coefficient 4 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A21                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients4, TRegRecC1b0LeftMatrixCoefficients4, *PTRegRecC1b0LeftMatrixCoefficients4;                               //0x10016C

//Rectification remap matrix coefficient 5 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A22                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients5, TRegRecC1b0LeftMatrixCoefficients5, *PTRegRecC1b0LeftMatrixCoefficients5;                               //0x100170

//Rectification remap matrix coefficient 6 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients6{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A23                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients6, TRegRecC1b0LeftMatrixCoefficients6, *PTRegRecC1b0LeftMatrixCoefficients6;                               //0x100174

//Rectification remap matrix coefficient 7 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients7{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A31                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients7, TRegRecC1b0LeftMatrixCoefficients7, *PTRegRecC1b0LeftMatrixCoefficients7;                               //0x100178

//Rectification remap matrix coefficient 8 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients8{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A32                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients8, TRegRecC1b0LeftMatrixCoefficients8, *PTRegRecC1b0LeftMatrixCoefficients8;                               //0x10017C

//Rectification remap matrix coefficient 9 for C1B0 Left
//initial value: 0x00000000
typedef union __RegRecC1b0LeftMatrixCoefficients9{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A33                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0LeftMatrixCoefficients9, TRegRecC1b0LeftMatrixCoefficients9, *PTRegRecC1b0LeftMatrixCoefficients9;                               //0x100180

//Rectification Distortion Parameters 1 for C1B0 Left
//initial value: 0x000000
typedef union __RegRecC1b0LeftDistortionParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K0                                                :24         ; //Bits :[0:23], initial value: 0x0.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftDistortionParameters1, TRegRecC1b0LeftDistortionParameters1, *PTRegRecC1b0LeftDistortionParameters1;                               //0x100184

//Rectification Distortion Parameters 2 for C1B0 Left
//initial value: 0x000000
typedef union __RegRecC1b0LeftDistortionParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1                                                :22         ; //Bits :[0:21], initial value: 0x0.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftDistortionParameters2, TRegRecC1b0LeftDistortionParameters2, *PTRegRecC1b0LeftDistortionParameters2;                               //0x100188

//Rectification Distortion Parameters 3 for C1B0 Left
//initial value: 0x00000
typedef union __RegRecC1b0LeftDistortionParameters3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftDistortionParameters3, TRegRecC1b0LeftDistortionParameters3, *PTRegRecC1b0LeftDistortionParameters3;                               //0x10018C

//Rectification Distortion Parameters 4 for C1B0 Left
//initial value: 0x00000
typedef union __RegRecC1b0LeftDistortionParameters4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K3                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftDistortionParameters4, TRegRecC1b0LeftDistortionParameters4, *PTRegRecC1b0LeftDistortionParameters4;                               //0x100190

//Rectification Distortion Parameters 5 for C1B0 Left
//initial value: 0x00000
typedef union __RegRecC1b0LeftDistortionParameters5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K4                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftDistortionParameters5, TRegRecC1b0LeftDistortionParameters5, *PTRegRecC1b0LeftDistortionParameters5;                               //0x100194

//Rectification Focal Length Parameters 1 for C1B0 Left
//initial value: 0x00000
typedef union __RegRecC1b0LeftFocalLengthParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F0                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftFocalLengthParameters1, TRegRecC1b0LeftFocalLengthParameters1, *PTRegRecC1b0LeftFocalLengthParameters1;                               //0x100198

//Rectification Focal Length Parameters 2 for C1B0 Left
//initial value: 0x00000
typedef union __RegRecC1b0LeftFocalLengthParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F1                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftFocalLengthParameters2, TRegRecC1b0LeftFocalLengthParameters2, *PTRegRecC1b0LeftFocalLengthParameters2;                               //0x10019C

//Rectification Center Parameters 1 for C1B0 Left
//initial value: 0x00000
typedef union __RegRecC1b0LeftCenterParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C0                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftCenterParameters1, TRegRecC1b0LeftCenterParameters1, *PTRegRecC1b0LeftCenterParameters1;                               //0x1001A0

//Rectification Center Parameters 2 for C1B0 Left
//initial value: 0x00000
typedef union __RegRecC1b0LeftCenterParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C1                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0LeftCenterParameters2, TRegRecC1b0LeftCenterParameters2, *PTRegRecC1b0LeftCenterParameters2;                               //0x1001A4

//Rectification remap matrix coefficient 1 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A11                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients1, TRegRecC1b0RightMatrixCoefficients1, *PTRegRecC1b0RightMatrixCoefficients1;                               //0x1001B0

//Rectification remap matrix coefficient 2 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A12                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients2, TRegRecC1b0RightMatrixCoefficients2, *PTRegRecC1b0RightMatrixCoefficients2;                               //0x1001B4

//Rectification remap matrix coefficient 3 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A13                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients3, TRegRecC1b0RightMatrixCoefficients3, *PTRegRecC1b0RightMatrixCoefficients3;                               //0x1001B8

//Rectification remap matrix coefficient 4 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A21                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients4, TRegRecC1b0RightMatrixCoefficients4, *PTRegRecC1b0RightMatrixCoefficients4;                               //0x1001BC

//Rectification remap matrix coefficient 5 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A22                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients5, TRegRecC1b0RightMatrixCoefficients5, *PTRegRecC1b0RightMatrixCoefficients5;                               //0x1001C0

//Rectification remap matrix coefficient 6 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients6{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A23                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients6, TRegRecC1b0RightMatrixCoefficients6, *PTRegRecC1b0RightMatrixCoefficients6;                               //0x1001C4

//Rectification remap matrix coefficient 7 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients7{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A31                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients7, TRegRecC1b0RightMatrixCoefficients7, *PTRegRecC1b0RightMatrixCoefficients7;                               //0x1001C8

//Rectification remap matrix coefficient 8 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients8{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A32                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients8, TRegRecC1b0RightMatrixCoefficients8, *PTRegRecC1b0RightMatrixCoefficients8;                               //0x1001CC

//Rectification remap matrix coefficient 9 for C1B0 Right
//initial value: 0x00000000
typedef union __RegRecC1b0RightMatrixCoefficients9{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A33                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b0RightMatrixCoefficients9, TRegRecC1b0RightMatrixCoefficients9, *PTRegRecC1b0RightMatrixCoefficients9;                               //0x1001D0

//Rectification Distortion Parameters 1 for C1B0 Right
//initial value: 0x000000
typedef union __RegRecC1b0RightDistortionParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K0                                                :24         ; //Bits :[0:23], initial value: 0x0.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightDistortionParameters1, TRegRecC1b0RightDistortionParameters1, *PTRegRecC1b0RightDistortionParameters1;                               //0x1001D4

//Rectification Distortion Parameters 2 for C1B0 Right
//initial value: 0x000000
typedef union __RegRecC1b0RightDistortionParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1                                                :22         ; //Bits :[0:21], initial value: 0x0.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightDistortionParameters2, TRegRecC1b0RightDistortionParameters2, *PTRegRecC1b0RightDistortionParameters2;                               //0x1001D8

//Rectification Distortion Parameters 3 for C1B0 Right
//initial value: 0x00000
typedef union __RegRecC1b0RightDistortionParameters3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightDistortionParameters3, TRegRecC1b0RightDistortionParameters3, *PTRegRecC1b0RightDistortionParameters3;                               //0x1001DC

//Rectification Distortion Parameters 4 for C1B0 Right
//initial value: 0x00000
typedef union __RegRecC1b0RightDistortionParameters4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K3                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightDistortionParameters4, TRegRecC1b0RightDistortionParameters4, *PTRegRecC1b0RightDistortionParameters4;                               //0x1001E0

//Rectification Distortion Parameters 5 for C1B0 Right
//initial value: 0x00000
typedef union __RegRecC1b0RightDistortionParameters5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K4                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightDistortionParameters5, TRegRecC1b0RightDistortionParameters5, *PTRegRecC1b0RightDistortionParameters5;                               //0x1001E4

//Rectification Focal Length Parameters 1 for C1B0 Right
//initial value: 0x00000
typedef union __RegRecC1b0RightFocalLengthParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F0                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightFocalLengthParameters1, TRegRecC1b0RightFocalLengthParameters1, *PTRegRecC1b0RightFocalLengthParameters1;                               //0x1001E8

//Rectification Focal Length Parameters 2 for C1B0 Right
//initial value: 0x00000
typedef union __RegRecC1b0RightFocalLengthParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F1                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightFocalLengthParameters2, TRegRecC1b0RightFocalLengthParameters2, *PTRegRecC1b0RightFocalLengthParameters2;                               //0x1001EC

//Rectification Center Parameters 1 for C1B0 Right
//initial value: 0x00000
typedef union __RegRecC1b0RightCenterParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C0                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightCenterParameters1, TRegRecC1b0RightCenterParameters1, *PTRegRecC1b0RightCenterParameters1;                               //0x1001F0

//Rectification Center Parameters 2 for C1B0 Right
//initial value: 0x00000
typedef union __RegRecC1b0RightCenterParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C1                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b0RightCenterParameters2, TRegRecC1b0RightCenterParameters2, *PTRegRecC1b0RightCenterParameters2;                               //0x1001F4

//Rectification remap matrix coefficient 1 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A11                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients1, TRegRecC1b1LeftMatrixCoefficients1, *PTRegRecC1b1LeftMatrixCoefficients1;                               //0x100200

//Rectification remap matrix coefficient 2 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A12                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients2, TRegRecC1b1LeftMatrixCoefficients2, *PTRegRecC1b1LeftMatrixCoefficients2;                               //0x100204

//Rectification remap matrix coefficient 3 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A13                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients3, TRegRecC1b1LeftMatrixCoefficients3, *PTRegRecC1b1LeftMatrixCoefficients3;                               //0x100208

//Rectification remap matrix coefficient 4 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A21                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients4, TRegRecC1b1LeftMatrixCoefficients4, *PTRegRecC1b1LeftMatrixCoefficients4;                               //0x10020C

//Rectification remap matrix coefficient 5 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A22                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients5, TRegRecC1b1LeftMatrixCoefficients5, *PTRegRecC1b1LeftMatrixCoefficients5;                               //0x100210

//Rectification remap matrix coefficient 6 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients6{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A23                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients6, TRegRecC1b1LeftMatrixCoefficients6, *PTRegRecC1b1LeftMatrixCoefficients6;                               //0x100214

//Rectification remap matrix coefficient 7 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients7{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A31                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients7, TRegRecC1b1LeftMatrixCoefficients7, *PTRegRecC1b1LeftMatrixCoefficients7;                               //0x100218

//Rectification remap matrix coefficient 8 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients8{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A32                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients8, TRegRecC1b1LeftMatrixCoefficients8, *PTRegRecC1b1LeftMatrixCoefficients8;                               //0x10021C

//Rectification remap matrix coefficient 9 for C1B1 Left
//initial value: 0x00000000
typedef union __RegRecC1b1LeftMatrixCoefficients9{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A33                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1LeftMatrixCoefficients9, TRegRecC1b1LeftMatrixCoefficients9, *PTRegRecC1b1LeftMatrixCoefficients9;                               //0x100220

//Rectification Distortion Parameters 1 for C1B1 Left
//initial value: 0x000000
typedef union __RegRecC1b1LeftDistortionParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K0                                                :24         ; //Bits :[0:23], initial value: 0x0.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftDistortionParameters1, TRegRecC1b1LeftDistortionParameters1, *PTRegRecC1b1LeftDistortionParameters1;                               //0x100224

//Rectification Distortion Parameters 2 for C1B1 Left
//initial value: 0x000000
typedef union __RegRecC1b1LeftDistortionParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1                                                :22         ; //Bits :[0:21], initial value: 0x0.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftDistortionParameters2, TRegRecC1b1LeftDistortionParameters2, *PTRegRecC1b1LeftDistortionParameters2;                               //0x100228

//Rectification Distortion Parameters 3 for C1B1 Left
//initial value: 0x00000
typedef union __RegRecC1b1LeftDistortionParameters3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftDistortionParameters3, TRegRecC1b1LeftDistortionParameters3, *PTRegRecC1b1LeftDistortionParameters3;                               //0x10022C

//Rectification Distortion Parameters 4 for C1B1 Left
//initial value: 0x00000
typedef union __RegRecC1b1LeftDistortionParameters4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K3                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftDistortionParameters4, TRegRecC1b1LeftDistortionParameters4, *PTRegRecC1b1LeftDistortionParameters4;                               //0x100230

//Rectification Distortion Parameters 5 for C1B1 Left
//initial value: 0x00000
typedef union __RegRecC1b1LeftDistortionParameters5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K4                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftDistortionParameters5, TRegRecC1b1LeftDistortionParameters5, *PTRegRecC1b1LeftDistortionParameters5;                               //0x100234

//Rectification Focal Length Parameters 1 for C1B1 Left
//initial value: 0x00000
typedef union __RegRecC1b1LeftFocalLengthParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F0                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftFocalLengthParameters1, TRegRecC1b1LeftFocalLengthParameters1, *PTRegRecC1b1LeftFocalLengthParameters1;                               //0x100238

//Rectification Focal Length Parameters 2 for C1B1 Left
//initial value: 0x00000
typedef union __RegRecC1b1LeftFocalLengthParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F1                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftFocalLengthParameters2, TRegRecC1b1LeftFocalLengthParameters2, *PTRegRecC1b1LeftFocalLengthParameters2;                               //0x10023C

//Rectification Center Parameters 1 for C1B1 Left
//initial value: 0x00000
typedef union __RegRecC1b1LeftCenterParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C0                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftCenterParameters1, TRegRecC1b1LeftCenterParameters1, *PTRegRecC1b1LeftCenterParameters1;                               //0x100240

//Rectification Center Parameters 2 for C1B1 Left
//initial value: 0x00000
typedef union __RegRecC1b1LeftCenterParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C1                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1LeftCenterParameters2, TRegRecC1b1LeftCenterParameters2, *PTRegRecC1b1LeftCenterParameters2;                               //0x100244

//Rectification remap matrix coefficient 1 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A11                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients1, TRegRecC1b1RightMatrixCoefficients1, *PTRegRecC1b1RightMatrixCoefficients1;                               //0x100250

//Rectification remap matrix coefficient 2 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A12                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients2, TRegRecC1b1RightMatrixCoefficients2, *PTRegRecC1b1RightMatrixCoefficients2;                               //0x100254

//Rectification remap matrix coefficient 3 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A13                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients3, TRegRecC1b1RightMatrixCoefficients3, *PTRegRecC1b1RightMatrixCoefficients3;                               //0x100258

//Rectification remap matrix coefficient 4 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A21                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients4, TRegRecC1b1RightMatrixCoefficients4, *PTRegRecC1b1RightMatrixCoefficients4;                               //0x10025C

//Rectification remap matrix coefficient 5 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A22                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients5, TRegRecC1b1RightMatrixCoefficients5, *PTRegRecC1b1RightMatrixCoefficients5;                               //0x100260

//Rectification remap matrix coefficient 6 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients6{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A23                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients6, TRegRecC1b1RightMatrixCoefficients6, *PTRegRecC1b1RightMatrixCoefficients6;                               //0x100264

//Rectification remap matrix coefficient 7 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients7{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A31                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients7, TRegRecC1b1RightMatrixCoefficients7, *PTRegRecC1b1RightMatrixCoefficients7;                               //0x100268

//Rectification remap matrix coefficient 8 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients8{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A32                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients8, TRegRecC1b1RightMatrixCoefficients8, *PTRegRecC1b1RightMatrixCoefficients8;                               //0x10026C

//Rectification remap matrix coefficient 9 for C1B1 Right
//initial value: 0x00000000
typedef union __RegRecC1b1RightMatrixCoefficients9{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t A33                                               :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
} RegRecC1b1RightMatrixCoefficients9, TRegRecC1b1RightMatrixCoefficients9, *PTRegRecC1b1RightMatrixCoefficients9;                               //0x100270

//Rectification Distortion Parameters 1 for C1B1 Right
//initial value: 0x000000
typedef union __RegRecC1b1RightDistortionParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K0                                                :24         ; //Bits :[0:23], initial value: 0x0.
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightDistortionParameters1, TRegRecC1b1RightDistortionParameters1, *PTRegRecC1b1RightDistortionParameters1;                               //0x100274

//Rectification Distortion Parameters 2 for C1B1 Right
//initial value: 0x000000
typedef union __RegRecC1b1RightDistortionParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1                                                :22         ; //Bits :[0:21], initial value: 0x0.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightDistortionParameters2, TRegRecC1b1RightDistortionParameters2, *PTRegRecC1b1RightDistortionParameters2;                               //0x100278

//Rectification Distortion Parameters 3 for C1B1 Right
//initial value: 0x00000
typedef union __RegRecC1b1RightDistortionParameters3{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightDistortionParameters3, TRegRecC1b1RightDistortionParameters3, *PTRegRecC1b1RightDistortionParameters3;                               //0x10027C

//Rectification Distortion Parameters 4 for C1B1 Right
//initial value: 0x00000
typedef union __RegRecC1b1RightDistortionParameters4{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K3                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightDistortionParameters4, TRegRecC1b1RightDistortionParameters4, *PTRegRecC1b1RightDistortionParameters4;                               //0x100280

//Rectification Distortion Parameters 5 for C1B1 Right
//initial value: 0x00000
typedef union __RegRecC1b1RightDistortionParameters5{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K4                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightDistortionParameters5, TRegRecC1b1RightDistortionParameters5, *PTRegRecC1b1RightDistortionParameters5;                               //0x100284

//Rectification Focal Length Parameters 1 for C1B1 Right
//initial value: 0x00000
typedef union __RegRecC1b1RightFocalLengthParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F0                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightFocalLengthParameters1, TRegRecC1b1RightFocalLengthParameters1, *PTRegRecC1b1RightFocalLengthParameters1;                               //0x100288

//Rectification Focal Length Parameters 2 for C1B1 Right
//initial value: 0x00000
typedef union __RegRecC1b1RightFocalLengthParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t F1                                                :19         ; //Bits :[0:18], initial value: 0x0.
        uint32_t Reserved                                          :13         ; //Bits :[19:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightFocalLengthParameters2, TRegRecC1b1RightFocalLengthParameters2, *PTRegRecC1b1RightFocalLengthParameters2;                               //0x10028C

//Rectification Center Parameters 1 for C1B1 Right
//initial value: 0x00000
typedef union __RegRecC1b1RightCenterParameters1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C0                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightCenterParameters1, TRegRecC1b1RightCenterParameters1, *PTRegRecC1b1RightCenterParameters1;                               //0x100290

//Rectification Center Parameters 2 for C1B1 Right
//initial value: 0x00000
typedef union __RegRecC1b1RightCenterParameters2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t C1                                                :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecC1b1RightCenterParameters2, TRegRecC1b1RightCenterParameters2, *PTRegRecC1b1RightCenterParameters2;                               //0x100294

//Rectification control register with multiple bits to setup hardware for camera 0
//initial value: 0x1b
typedef union __RegRecCamera0RecControlRegister{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Splerp                                            :1          ; //Bits :[0:0], initial value: 0x1. 1=Splerp mode, 0=Bilerp mode
        uint32_t ColorMode                                         :1          ; //Bits :[1:1], initial value: 0x1. 1=Color mode, use RGB Interpolation and Bayer demosaicing; 0 = Monochrome cameras bypass Bayer demosaicing and set RGB to constant.
        uint32_t ZeroCoefficients                                  :1          ; //Bits :[2:2], initial value: 0x0. Force address coefficients to register values in address generation for identity mode.
        uint32_t Rcolumn                                           :1          ; //Bits :[3:3], initial value: 0x1. Bayer pattern orientation, 1=red column, 0=blue column
        uint32_t Rrow                                              :1          ; //Bits :[4:4], initial value: 0x1. Bayer pattern orientation, 1=red row, 0=blue row
        uint32_t BrownModel                                        :1          ; //Bits :[5:5], initial value: 0x0. 0: A0 functionality; 1: select BrownModel, use val6 and val7 instead of val17 and val18
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0RecControlRegister, TRegRecCamera0RecControlRegister, *PTRegRecCamera0RecControlRegister;                               //0x1002B0

//Identity mode rectified pixel coordinates coefficient for camera 0.
//initial value: 0x0
typedef union __RegRecCamera0IdentityCoefficient{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t IdentityLeftXcoeff                                :8          ; //Bits :[0:7], initial value: 0x0.
        uint32_t IdentityLeftYcoeff                                :8          ; //Bits :[8:15], initial value: 0x0.
        uint32_t IdentityRightXcoeff                               :8          ; //Bits :[16:23], initial value: 0x0.
        uint32_t IdentityRightYcoeff                               :8          ; //Bits :[24:31], initial value: 0x0.
     } fields_read;
} RegRecCamera0IdentityCoefficient, TRegRecCamera0IdentityCoefficient, *PTRegRecCamera0IdentityCoefficient;                               //0x1002B4

//Number of lines per frame and pixels per line in the rectified output image for camera 0.
//initial value: 0x0
typedef union __RegRecCamera0RectifiedImageSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x0. Pixels per line in the rectified output image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x0. Lines per frame in the rectified output image.
     } fields_read;
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x0. Pixels per line in the rectified output image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x0. Lines per frame in the rectified output image.
     } fields_write;
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x0. Pixels per line in the rectified output image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x0. Lines per frame in the rectified output image.
     } fields_rmw; //for non-shadowed register
} RegRecCamera0RectifiedImageSize, TRegRecCamera0RectifiedImageSize, *PTRegRecCamera0RectifiedImageSize;                               //0x1002B8

//Number of lines per frame and pixels per line in the input image for camera 0.
//initial value: 0x00280100
typedef union __RegRecCamera0InputImageSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x100. Pixels per line in the input image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x28. Lines per frame in the input image.
     } fields_read;
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x100. Pixels per line in the input image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x28. Lines per frame in the input image.
     } fields_write;
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x100. Pixels per line in the input image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x28. Lines per frame in the input image.
     } fields_rmw; //for non-shadowed register
} RegRecCamera0InputImageSize, TRegRecCamera0InputImageSize, *PTRegRecCamera0InputImageSize;                               //0x1002BC

//In the frame, lines less than top edge are skipped when calculating exposure for camera 0.
//initial value: 0x0
typedef union __RegRecCamera0ExposureTopEdge{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposuretopedge                                   :12         ; //Bits :[0:11], initial value: 0x0. Top Edge limit for exposure control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0ExposureTopEdge, TRegRecCamera0ExposureTopEdge, *PTRegRecCamera0ExposureTopEdge;                               //0x1002C0

//Line numbers greater than bottom edge are skipped when calculating exposure for camera 0.
//initial value: 0x0
typedef union __RegRecCamera0ExposureBottomEdge{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposurebottomedge                                :12         ; //Bits :[0:11], initial value: 0x0. Bottom Edge limit for exposure control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0ExposureBottomEdge, TRegRecCamera0ExposureBottomEdge, *PTRegRecCamera0ExposureBottomEdge;                               //0x1002C4

//The first left edge number of pixels are skipped on each line when calculating exposure for camera 0.
//initial value: 0x0
typedef union __RegRecCamera0ExposureLeftEdge{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposureleftedge                                  :12         ; //Bits :[0:11], initial value: 0x0. Left Edge limit for exposure control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0ExposureLeftEdge, TRegRecCamera0ExposureLeftEdge, *PTRegRecCamera0ExposureLeftEdge;                               //0x1002C8

//The right edge number of pixels are skipped on the right side of the image when calculating exposure for camera
//0.
//initial value: 0x0
typedef union __RegRecCamera0ExposureRightEdge{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposurerightedge                                 :12         ; //Bits :[0:11], initial value: 0x0. Right Edge limit for exposure control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0ExposureRightEdge, TRegRecCamera0ExposureRightEdge, *PTRegRecCamera0ExposureRightEdge;                               //0x1002CC

//Pixels with value less than dark threshold are not counted for Dark Pixel Count for camera 0
//initial value: 0x0
typedef union __RegRecCamera0ExposureLeftDarkThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposureleftdarkthreshold                         :12         ; //Bits :[0:11], initial value: 0x0. Left camera dark threshold
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0ExposureLeftDarkThreshold, TRegRecCamera0ExposureLeftDarkThreshold, *PTRegRecCamera0ExposureLeftDarkThreshold;                               //0x1002D0

//The brightness threshold for left image for camera 0
//initial value: 0x0
typedef union __RegRecCamera0ExposureLeftBrightThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t ExposureleftbrightThreshold                       :12         ; //Bits :[0:11], initial value: 0x0. Left camera maximum value
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0ExposureLeftBrightThreshold, TRegRecCamera0ExposureLeftBrightThreshold, *PTRegRecCamera0ExposureLeftBrightThreshold;                               //0x1002D4

//The darkness threshold for right image for camera 0
//initial value: 0x0
typedef union __RegRecCamera0ExposureRightDarkThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposurerightdarkthreshold                        :12         ; //Bits :[0:11], initial value: 0x0. Right camera minimum value
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0ExposureRightDarkThreshold, TRegRecCamera0ExposureRightDarkThreshold, *PTRegRecCamera0ExposureRightDarkThreshold;                               //0x1002D8

//The brightness threshold for right image for camera 0
//initial value: 0x0
typedef union __RegRecCamera0ExposureRightBrightThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposurerightbrightthreshold                      :12         ; //Bits :[0:11], initial value: 0x0. Right camera maximum value
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0ExposureRightBrightThreshold, TRegRecCamera0ExposureRightBrightThreshold, *PTRegRecCamera0ExposureRightBrightThreshold;                               //0x1002DC

//The YUV matrix entry 00 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry00{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry00                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry00, TRegRecCamera0YuvMatrixEntry00, *PTRegRecCamera0YuvMatrixEntry00;                               //0x1002E4

//The YUV matrix entry 10 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry10{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry10                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry10, TRegRecCamera0YuvMatrixEntry10, *PTRegRecCamera0YuvMatrixEntry10;                               //0x1002E8

//The YUV matrix entry 20 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry20{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry20                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry20, TRegRecCamera0YuvMatrixEntry20, *PTRegRecCamera0YuvMatrixEntry20;                               //0x1002EC

//The YUV matrix entry 30 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry30{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry30                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry30, TRegRecCamera0YuvMatrixEntry30, *PTRegRecCamera0YuvMatrixEntry30;                               //0x1002F0

//The YUV matrix entry 01 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry01{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry01                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry01, TRegRecCamera0YuvMatrixEntry01, *PTRegRecCamera0YuvMatrixEntry01;                               //0x1002F4

//The YUV matrix entry 11 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry11{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry11                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry11, TRegRecCamera0YuvMatrixEntry11, *PTRegRecCamera0YuvMatrixEntry11;                               //0x1002F8

//The YUV matrix entry 21 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry21{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry21                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry21, TRegRecCamera0YuvMatrixEntry21, *PTRegRecCamera0YuvMatrixEntry21;                               //0x1002FC

//The YUV matrix entry 31 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry31{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry31                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry31, TRegRecCamera0YuvMatrixEntry31, *PTRegRecCamera0YuvMatrixEntry31;                               //0x100300

//The YUV matrix entry 02 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry02{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry02                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry02, TRegRecCamera0YuvMatrixEntry02, *PTRegRecCamera0YuvMatrixEntry02;                               //0x100304

//The YUV matrix entry 12 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry12{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry12                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry12, TRegRecCamera0YuvMatrixEntry12, *PTRegRecCamera0YuvMatrixEntry12;                               //0x100308

//The YUV matrix entry 22 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry22{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry22                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry22, TRegRecCamera0YuvMatrixEntry22, *PTRegRecCamera0YuvMatrixEntry22;                               //0x10030C

//The YUV matrix entry 32 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvMatrixEntry32{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry32                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvMatrixEntry32, TRegRecCamera0YuvMatrixEntry32, *PTRegRecCamera0YuvMatrixEntry32;                               //0x100310

//The YUV vector 0 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvVector0{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvVector0                                        :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvVector0, TRegRecCamera0YuvVector0, *PTRegRecCamera0YuvVector0;                               //0x100314

//The YUV vector 1 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvVector1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvVector1                                        :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvVector1, TRegRecCamera0YuvVector1, *PTRegRecCamera0YuvVector1;                               //0x100318

//The YUV vector 2 for camera 0
//initial value: 0x0
typedef union __RegRecCamera0YuvVector2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvVector2                                        :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera0YuvVector2, TRegRecCamera0YuvVector2, *PTRegRecCamera0YuvVector2;                               //0x10031C

//Rectification control register with multiple bits to setup hardware for camera 1
//initial value: 0x1b
typedef union __RegRecCamera1RecControlRegister{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Splerp                                            :1          ; //Bits :[0:0], initial value: 0x1. 1=Splerp mode, 0=Bilerp mode
        uint32_t ColorMode                                         :1          ; //Bits :[1:1], initial value: 0x1. 1=Color mode, use RGB Interpolation and Bayer demosaicing; 0 = Monochrome cameras bypass Bayer demosaicing and set RGB to constant.
        uint32_t ZeroCoefficients                                  :1          ; //Bits :[2:2], initial value: 0x0. Force address coefficients to register values in address generation for identity mode.
        uint32_t Rcolumn                                           :1          ; //Bits :[3:3], initial value: 0x1. Bayer pattern orientation, 1=red column, 0=blue column
        uint32_t Rrow                                              :1          ; //Bits :[4:4], initial value: 0x1. Bayer pattern orientation, 1=red row, 0=blue row
        uint32_t BrownModel                                        :1          ; //Bits :[5:5], initial value: 0x0. 0: A0 functionality; 1: select BrownModel, use val6 and val7 instead of val17 and val18
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1RecControlRegister, TRegRecCamera1RecControlRegister, *PTRegRecCamera1RecControlRegister;                               //0x100340

//Identity mode rectified pixel coordinates coefficient for camera 1.
//initial value: 0x0
typedef union __RegRecCamera1IdentityCoefficient{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t IdentityLeftXcoeff                                :8          ; //Bits :[0:7], initial value: 0x0.
        uint32_t IdentityLeftYcoeff                                :8          ; //Bits :[8:15], initial value: 0x0.
        uint32_t IdentityRightXcoeff                               :8          ; //Bits :[16:23], initial value: 0x0.
        uint32_t IdentityRightYcoeff                               :8          ; //Bits :[24:31], initial value: 0x0.
     } fields_read;
} RegRecCamera1IdentityCoefficient, TRegRecCamera1IdentityCoefficient, *PTRegRecCamera1IdentityCoefficient;                               //0x100344

//Number of lines per frame and pixels per line in the rectified output image for camera 1.
//initial value: 0x0
typedef union __RegRecCamera1RectifiedImageSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x0. Pixels per line in the rectified output image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x0. Lines per frame in the rectified output image.
     } fields_read;
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x0. Pixels per line in the rectified output image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x0. Lines per frame in the rectified output image.
     } fields_write;
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x0. Pixels per line in the rectified output image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x0. Lines per frame in the rectified output image.
     } fields_rmw; //for non-shadowed register
} RegRecCamera1RectifiedImageSize, TRegRecCamera1RectifiedImageSize, *PTRegRecCamera1RectifiedImageSize;                               //0x100348

//Number of lines per frame and pixels per line in the input image for camera 1.
//initial value: 0x00280100
typedef union __RegRecCamera1InputImageSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x100. Pixels per line in the input image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x28. Lines per frame in the input image.
     } fields_read;
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x100. Pixels per line in the input image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x28. Lines per frame in the input image.
     } fields_write;
    struct {
        uint32_t PixelsPerLine                                     :16         ; //Bits :[0:15], initial value: 0x100. Pixels per line in the input image.
        uint32_t LinesPerFrame                                     :16         ; //Bits :[16:31], initial value: 0x28. Lines per frame in the input image.
     } fields_rmw; //for non-shadowed register
} RegRecCamera1InputImageSize, TRegRecCamera1InputImageSize, *PTRegRecCamera1InputImageSize;                               //0x10034C

//In the frame, lines less than top edge are skipped when calculating exposure for camera 1.
//initial value: 0x0
typedef union __RegRecCamera1ExposureTopEdge{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposuretopedge                                   :12         ; //Bits :[0:11], initial value: 0x0. Top Edge limit for exposure control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1ExposureTopEdge, TRegRecCamera1ExposureTopEdge, *PTRegRecCamera1ExposureTopEdge;                               //0x100350

//Line numbers greater than bottom edge are skipped when calculating exposure for camera 1.
//initial value: 0x0
typedef union __RegRecCamera1ExposureBottomEdge{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposurebottomedge                                :12         ; //Bits :[0:11], initial value: 0x0. Bottom Edge limit for exposure control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1ExposureBottomEdge, TRegRecCamera1ExposureBottomEdge, *PTRegRecCamera1ExposureBottomEdge;                               //0x100354

//The first left edge number of pixels are skipped on each line when calculating exposure for camera 1.
//initial value: 0x0
typedef union __RegRecCamera1ExposureLeftEdge{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposureleftedge                                  :12         ; //Bits :[0:11], initial value: 0x0. Left Edge limit for exposure control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1ExposureLeftEdge, TRegRecCamera1ExposureLeftEdge, *PTRegRecCamera1ExposureLeftEdge;                               //0x100358

//The right edge number of pixels are skipped on the right side of the image when calculating exposure for camera
//1.
//initial value: 0x0
typedef union __RegRecCamera1ExposureRightEdge{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposurerightedge                                 :12         ; //Bits :[0:11], initial value: 0x0. Right Edge limit for exposure control
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1ExposureRightEdge, TRegRecCamera1ExposureRightEdge, *PTRegRecCamera1ExposureRightEdge;                               //0x10035C

//Pixels with value less than dark threshold are not counted for Dark Pixel Count for camera 1
//initial value: 0x0
typedef union __RegRecCamera1ExposureLeftDarkThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposureleftdarkthreshold                         :12         ; //Bits :[0:11], initial value: 0x0. Left camera dark threshold
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1ExposureLeftDarkThreshold, TRegRecCamera1ExposureLeftDarkThreshold, *PTRegRecCamera1ExposureLeftDarkThreshold;                               //0x100360

//The brightness threshold for left image for camera 1
//initial value: 0x0
typedef union __RegRecCamera1ExposureLeftBrightThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t ExposureleftbrightThreshold                       :12         ; //Bits :[0:11], initial value: 0x0. Left camera maximum value
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1ExposureLeftBrightThreshold, TRegRecCamera1ExposureLeftBrightThreshold, *PTRegRecCamera1ExposureLeftBrightThreshold;                               //0x100364

//The darkness threshold for right image for camera 1
//initial value: 0x0
typedef union __RegRecCamera1ExposureRightDarkThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposurerightdarkthreshold                        :12         ; //Bits :[0:11], initial value: 0x0. Right camera minimum value
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1ExposureRightDarkThreshold, TRegRecCamera1ExposureRightDarkThreshold, *PTRegRecCamera1ExposureRightDarkThreshold;                               //0x100368

//The brightness threshold for right image for camera 1
//initial value: 0x0
typedef union __RegRecCamera1ExposureRightBrightThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Exposurerightbrightthreshold                      :12         ; //Bits :[0:11], initial value: 0x0. Right camera maximum value
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1ExposureRightBrightThreshold, TRegRecCamera1ExposureRightBrightThreshold, *PTRegRecCamera1ExposureRightBrightThreshold;                               //0x10036C

//The YUV matrix entry 00 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry00{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry00                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry00, TRegRecCamera1YuvMatrixEntry00, *PTRegRecCamera1YuvMatrixEntry00;                               //0x100374

//The YUV matrix entry 10 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry10{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry10                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry10, TRegRecCamera1YuvMatrixEntry10, *PTRegRecCamera1YuvMatrixEntry10;                               //0x100378

//The YUV matrix entry 20 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry20{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry20                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry20, TRegRecCamera1YuvMatrixEntry20, *PTRegRecCamera1YuvMatrixEntry20;                               //0x10037C

//The YUV matrix entry 30 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry30{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry30                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry30, TRegRecCamera1YuvMatrixEntry30, *PTRegRecCamera1YuvMatrixEntry30;                               //0x100380

//The YUV matrix entry 01 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry01{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry01                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry01, TRegRecCamera1YuvMatrixEntry01, *PTRegRecCamera1YuvMatrixEntry01;                               //0x100384

//The YUV matrix entry 11 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry11{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry11                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry11, TRegRecCamera1YuvMatrixEntry11, *PTRegRecCamera1YuvMatrixEntry11;                               //0x100388

//The YUV matrix entry 21 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry21{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry21                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry21, TRegRecCamera1YuvMatrixEntry21, *PTRegRecCamera1YuvMatrixEntry21;                               //0x10038C

//The YUV matrix entry 31 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry31{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry31                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry31, TRegRecCamera1YuvMatrixEntry31, *PTRegRecCamera1YuvMatrixEntry31;                               //0x100390

//The YUV matrix entry 02 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry02{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry02                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry02, TRegRecCamera1YuvMatrixEntry02, *PTRegRecCamera1YuvMatrixEntry02;                               //0x100394

//The YUV matrix entry 12 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry12{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry12                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry12, TRegRecCamera1YuvMatrixEntry12, *PTRegRecCamera1YuvMatrixEntry12;                               //0x100398

//The YUV matrix entry 22 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry22{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry22                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry22, TRegRecCamera1YuvMatrixEntry22, *PTRegRecCamera1YuvMatrixEntry22;                               //0x10039C

//The YUV matrix entry 32 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvMatrixEntry32{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvMatrixEntry32                                  :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvMatrixEntry32, TRegRecCamera1YuvMatrixEntry32, *PTRegRecCamera1YuvMatrixEntry32;                               //0x1003A0

//The YUV vector 0 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvVector0{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvVector0                                        :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvVector0, TRegRecCamera1YuvVector0, *PTRegRecCamera1YuvVector0;                               //0x1003A4

//The YUV vector 1 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvVector1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvVector1                                        :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvVector1, TRegRecCamera1YuvVector1, *PTRegRecCamera1YuvVector1;                               //0x1003A8

//The YUV vector 2 for camera 1
//initial value: 0x0
typedef union __RegRecCamera1YuvVector2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t YuvVector2                                        :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecCamera1YuvVector2, TRegRecCamera1YuvVector2, *PTRegRecCamera1YuvVector2;                               //0x1003AC

//Translation table for MSB 2 address bits in the Range LUT
//initial value: 0xe4
typedef union __RegRecRangeLutTranslation{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t TranslationFor00                                  :2          ; //Bits :[0:1], initial value: 0x0. This value becomes camera select bits if lookup address is 00
        uint32_t TranslationFor01                                  :2          ; //Bits :[2:3], initial value: 0x1. This value becomes camera select bits if lookup address is 01
        uint32_t TranslationFor10                                  :2          ; //Bits :[4:5], initial value: 0x2. This value becomes camera select bits if lookup address is 10
        uint32_t TranslationFor11                                  :2          ; //Bits :[6:7], initial value: 0x3. This value becomes camera select bits if lookup address is 11
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegRecRangeLutTranslation, TRegRecRangeLutTranslation, *PTRegRecRangeLutTranslation;                               //0x1003C0

//Left image sum of Y values, which fall into the range of darkness and brightness threshold.
//initial value: 0x0
typedef union __RegRecExposureLeftSum{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ExposureLeftSumResult                             :32         ; //Bits :[0:31], initial value: 0x0. Expo
     } fields_read;
    struct {
        uint32_t ExposureLeftSumResult                             :32         ; //Bits :[0:31], initial value: 0x0. Expo
     } fields_rmw; //for non-shadowed register
} RegRecExposureLeftSum, TRegRecExposureLeftSum, *PTRegRecExposureLeftSum;                               //0x100400

//Right image sum of Y values, which fall into the range of darkness and brightness threshold.
//initial value: 0x0
typedef union __RegRecExposureRightSum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ExposureRightSumResult                            :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t ExposureRightSumResult                            :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecExposureRightSum, TRegRecExposureRightSum, *PTRegRecExposureRightSum;                               //0x100404

//left image number of pixels, whose Y values are less than the darkness threshold value
//initial value: 0x0
typedef union __RegRecExposureLeftDarkcount{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ExposureLeftDarkCountResult                       :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t ExposureLeftDarkCountResult                       :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecExposureLeftDarkcount, TRegRecExposureLeftDarkcount, *PTRegRecExposureLeftDarkcount;                               //0x100408

//Right image number of pixels, whose Y values are less than the darkness threshold value
//initial value: 0x0
typedef union __RegRecExposureRightDarkCount{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ExposureLeftDarkCountResult                       :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t ExposureLeftDarkCountResult                       :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecExposureRightDarkCount, TRegRecExposureRightDarkCount, *PTRegRecExposureRightDarkCount;                               //0x10040C

//left image number of pixels, whose Y values larger than the brightness threshold value
//initial value: 0x0
typedef union __RegRecExposureLeftBrightCount{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ExposureLeftBrightCountResult                     :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t ExposureLeftBrightCountResult                     :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecExposureLeftBrightCount, TRegRecExposureLeftBrightCount, *PTRegRecExposureLeftBrightCount;                               //0x100410

//Right image number of pixels, whose Y values are larger than the brightness threshold value
//initial value: 0x0
typedef union __RegRecExposureRightBrightCount{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ExposureLeftBrightCountResult                     :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t ExposureLeftBrightCountResult                     :20         ; //Bits :[0:19], initial value: 0x0.
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecExposureRightBrightCount, TRegRecExposureRightBrightCount, *PTRegRecExposureRightBrightCount;                               //0x100414

//Left image sum of red values
//initial value: 0x0
typedef union __RegRecWhiteBalanceLeftRedSum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WhiteBalanceLeftRedSumResult                      :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t WhiteBalanceLeftRedSumResult                      :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecWhiteBalanceLeftRedSum, TRegRecWhiteBalanceLeftRedSum, *PTRegRecWhiteBalanceLeftRedSum;                               //0x100440

//Left image sum of green1 values
//initial value: 0x0
typedef union __RegRecWhiteBalanceLeftGreen1Sum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WhiteBalanceLeftGreen1SumResult                   :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t WhiteBalanceLeftGreen1SumResult                   :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecWhiteBalanceLeftGreen1Sum, TRegRecWhiteBalanceLeftGreen1Sum, *PTRegRecWhiteBalanceLeftGreen1Sum;                               //0x100444

//Left image sum of green2 values
//initial value: 0x0
typedef union __RegRecWhiteBalanceLeftGreen2Sum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WhiteBalanceLeftGreen2SumResult                   :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t WhiteBalanceLeftGreen2SumResult                   :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecWhiteBalanceLeftGreen2Sum, TRegRecWhiteBalanceLeftGreen2Sum, *PTRegRecWhiteBalanceLeftGreen2Sum;                               //0x100448

//Left image sum of blue values
//initial value: 0x0
typedef union __RegRecWhiteBalanceLeftBlueSum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WhiteBalanceLeftBlueSumResult                     :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t WhiteBalanceLeftBlueSumResult                     :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecWhiteBalanceLeftBlueSum, TRegRecWhiteBalanceLeftBlueSum, *PTRegRecWhiteBalanceLeftBlueSum;                               //0x10044C

//Right image sum of red values
//initial value: 0x0
typedef union __RegRecWhiteBalanceRightRedSum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WhiteBalanceRightRedSumResult                     :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t WhiteBalanceRightRedSumResult                     :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecWhiteBalanceRightRedSum, TRegRecWhiteBalanceRightRedSum, *PTRegRecWhiteBalanceRightRedSum;                               //0x100450

//Right image sum of green1 values
//initial value: 0x0
typedef union __RegRecWhiteBalanceRightGreen1Sum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WhiteBalanceRightGreen1SumResult                  :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t WhiteBalanceRightGreen1SumResult                  :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecWhiteBalanceRightGreen1Sum, TRegRecWhiteBalanceRightGreen1Sum, *PTRegRecWhiteBalanceRightGreen1Sum;                               //0x100454

//Right image sum of green2 values
//initial value: 0x0
typedef union __RegRecWhiteBalanceRightGreen2Sum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WhiteBalanceRightGreen2SumResult                  :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t WhiteBalanceRightGreen2SumResult                  :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecWhiteBalanceRightGreen2Sum, TRegRecWhiteBalanceRightGreen2Sum, *PTRegRecWhiteBalanceRightGreen2Sum;                               //0x100458

//Right image sum of blue values
//initial value: 0x0
typedef union __RegRecWhiteBalanceRightBlueSum{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WhiteBalanceRightBlueSumResult                    :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_read;
    struct {
        uint32_t WhiteBalanceRightBlueSumResult                    :32         ; //Bits :[0:31], initial value: 0x0.
     } fields_rmw; //for non-shadowed register
} RegRecWhiteBalanceRightBlueSum, TRegRecWhiteBalanceRightBlueSum, *PTRegRecWhiteBalanceRightBlueSum;                               //0x10045C

//Do not modify the run bit while this signal is active
//initial value: 0x0
typedef union __RegRecNoRunChangeStatus{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NoRunChangeStatus                                 :1          ; //Bits :[0:0], initial value: 0x0.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t NoRunChangeStatus                                 :1          ; //Bits :[0:0], initial value: 0x0.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecNoRunChangeStatus, TRegRecNoRunChangeStatus, *PTRegRecNoRunChangeStatus;                               //0x100460

//Various rectification status bits. This register is sticky, cleared after register read.
//initial value: 0x00000000
typedef union __RegRecRecStatusRegister{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BufferOverrun                                     :1          ; //Bits :[0:0], initial value: 0x0. The rectification buffer has overflowed.
        uint32_t LeftBufferOverrun                                 :1          ; //Bits :[1:1], initial value: 0x0. The left data was overwritten by right data.
        uint32_t RightBufferOverrun                                :1          ; //Bits :[2:2], initial value: 0x0. The right data was overwritten by right data.
        uint32_t AddressGenerationRightDivideBy0                   :1          ; //Bits :[3:3], initial value: 0x0. The right address generation unit cause a divide by 0.
        uint32_t AddressGenerationLeftDivideBy0                    :1          ; //Bits :[4:4], initial value: 0x0. The left address generation unit cause a divide by 0.
        uint32_t RegifData                                         :1          ; //Bits :[5:5], initial value: 0x0. The data is coming from register test interface
        uint32_t TpgenData                                         :1          ; //Bits :[6:6], initial value: 0x0. The data is coming from the test pattern generator
        uint32_t FrameOverflow                                     :1          ; //Bits :[7:7], initial value: 0x0. There are too many frames in the buffer
        uint32_t RunRightOverflow                                  :1          ; //Bits :[8:8], initial value: 0x0. A right buffer overflow has occurred at some time during this run
        uint32_t RunLeftOverflow                                   :1          ; //Bits :[9:9], initial value: 0x0. A left buffer overflow has occurred at some time during this run
        uint32_t BufFrameOverflow                                  :1          ; //Bits :[10:10], initial value: 0x0. At some time during this run too many frames were in the buffer
        uint32_t RecRateInoutErr                                   :1          ; //Bits :[11:11], initial value: 0x0. Rec output rate is too slow and overflow will occur
        uint32_t CifFramelenError                                  :1          ; //Bits :[12:12], initial value: 0x0. received frame length does not match configuration
        uint32_t CifLinelenError                                   :1          ; //Bits :[13:13], initial value: 0x0. received line length does not match configuration
        uint32_t CifEolError                                       :1          ; //Bits :[14:14], initial value: 0x0. video sequencing error after eol received
        uint32_t CifSolError                                       :1          ; //Bits :[15:15], initial value: 0x0. video sequencing error after sol received
        uint32_t CifSofError                                       :1          ; //Bits :[16:16], initial value: 0x0. video sequencing error after sof received
        uint32_t CfgImageSizeError                                 :1          ; //Bits :[17:17], initial value: 0x0. output image size is large than input image size
        uint32_t Reserved                                          :10         ; //Bits :[18:27], initial value: 0x0. Reserved. Read always returns 0's
        uint32_t CameraSelect                                      :2          ; //Bits :[28:29], initial value: 0x0. Camera select bits from Cam Module
        uint32_t CfgMuxUnderflow                                   :1          ; //Bits :[30:30], initial value: 0x0. The camera config mux has underflowed
        uint32_t CfgMuxOverflow                                    :1          ; //Bits :[31:31], initial value: 0x0. The camera config mux has overflowed
     } fields_read;
    struct {
        uint32_t BufferOverrun                                     :1          ; //Bits :[0:0], initial value: 0x0. The rectification buffer has overflowed.
        uint32_t LeftBufferOverrun                                 :1          ; //Bits :[1:1], initial value: 0x0. The left data was overwritten by right data.
        uint32_t RightBufferOverrun                                :1          ; //Bits :[2:2], initial value: 0x0. The right data was overwritten by right data.
        uint32_t AddressGenerationRightDivideBy0                   :1          ; //Bits :[3:3], initial value: 0x0. The right address generation unit cause a divide by 0.
        uint32_t AddressGenerationLeftDivideBy0                    :1          ; //Bits :[4:4], initial value: 0x0. The left address generation unit cause a divide by 0.
        uint32_t RegifData                                         :1          ; //Bits :[5:5], initial value: 0x0. The data is coming from register test interface
        uint32_t TpgenData                                         :1          ; //Bits :[6:6], initial value: 0x0. The data is coming from the test pattern generator
        uint32_t FrameOverflow                                     :1          ; //Bits :[7:7], initial value: 0x0. There are too many frames in the buffer
        uint32_t RunRightOverflow                                  :1          ; //Bits :[8:8], initial value: 0x0. A right buffer overflow has occurred at some time during this run
        uint32_t RunLeftOverflow                                   :1          ; //Bits :[9:9], initial value: 0x0. A left buffer overflow has occurred at some time during this run
        uint32_t BufFrameOverflow                                  :1          ; //Bits :[10:10], initial value: 0x0. At some time during this run too many frames were in the buffer
        uint32_t RecRateInoutErr                                   :1          ; //Bits :[11:11], initial value: 0x0. Rec output rate is too slow and overflow will occur
        uint32_t CifFramelenError                                  :1          ; //Bits :[12:12], initial value: 0x0. received frame length does not match configuration
        uint32_t CifLinelenError                                   :1          ; //Bits :[13:13], initial value: 0x0. received line length does not match configuration
        uint32_t CifEolError                                       :1          ; //Bits :[14:14], initial value: 0x0. video sequencing error after eol received
        uint32_t CifSolError                                       :1          ; //Bits :[15:15], initial value: 0x0. video sequencing error after sol received
        uint32_t CifSofError                                       :1          ; //Bits :[16:16], initial value: 0x0. video sequencing error after sof received
        uint32_t CfgImageSizeError                                 :1          ; //Bits :[17:17], initial value: 0x0. output image size is large than input image size
        uint32_t Reserved                                          :10         ; //Bits :[18:27], initial value: 0x0. Reserved. Read always returns 0's
        uint32_t CameraSelect                                      :2          ; //Bits :[28:29], initial value: 0x0. Camera select bits from Cam Module
        uint32_t CfgMuxUnderflow                                   :1          ; //Bits :[30:30], initial value: 0x0. The camera config mux has underflowed
        uint32_t CfgMuxOverflow                                    :1          ; //Bits :[31:31], initial value: 0x0. The camera config mux has overflowed
     } fields_rmw; //for non-shadowed register
} RegRecRecStatusRegister, TRegRecRecStatusRegister, *PTRegRecRecStatusRegister;                               //0x100480

//Write data for ram 00 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam00OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelDataRam00                                    :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam00                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelDataRam00                                    :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam00                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelDataRam00                                    :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam00                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam00OfPixelData, TRegRecWriteRam00OfPixelData, *PTRegRecWriteRam00OfPixelData;                               //0x100500

//Write data for ram 01 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam01OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam01OfPixelData, TRegRecWriteRam01OfPixelData, *PTRegRecWriteRam01OfPixelData;                               //0x100504

//Write data for ram 02 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam02OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam02OfPixelData, TRegRecWriteRam02OfPixelData, *PTRegRecWriteRam02OfPixelData;                               //0x100508

//Write data for ram 03 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam03OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam03OfPixelData, TRegRecWriteRam03OfPixelData, *PTRegRecWriteRam03OfPixelData;                               //0x10050C

//Write data for ram 04 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam04OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam04OfPixelData, TRegRecWriteRam04OfPixelData, *PTRegRecWriteRam04OfPixelData;                               //0x100510

//Write data for ram 05 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam05OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam05OfPixelData, TRegRecWriteRam05OfPixelData, *PTRegRecWriteRam05OfPixelData;                               //0x100514

//Write data for ram 06 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam06OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam06OfPixelData, TRegRecWriteRam06OfPixelData, *PTRegRecWriteRam06OfPixelData;                               //0x100518

//Write data for ram 07 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam07OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam07OfPixelData, TRegRecWriteRam07OfPixelData, *PTRegRecWriteRam07OfPixelData;                               //0x10051C

//Write data for ram 08 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam08OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelOverflowDataRam08                            :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelData                                         :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelOverflowDataRam08                            :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelData                                         :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelOverflowDataRam08                            :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelData                                         :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam08OfPixelData, TRegRecWriteRam08OfPixelData, *PTRegRecWriteRam08OfPixelData;                               //0x100520

//Write data for ram 09 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam09OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam09OfPixelData, TRegRecWriteRam09OfPixelData, *PTRegRecWriteRam09OfPixelData;                               //0x100524

//Write data for ram 10 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam10OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam10OfPixelData, TRegRecWriteRam10OfPixelData, *PTRegRecWriteRam10OfPixelData;                               //0x100528

//Write data for ram 11 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam11OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam11OfPixelData, TRegRecWriteRam11OfPixelData, *PTRegRecWriteRam11OfPixelData;                               //0x10052C

//Write data for ram 12 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam12OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam12OfPixelData, TRegRecWriteRam12OfPixelData, *PTRegRecWriteRam12OfPixelData;                               //0x100530

//Write data for ram 13 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam13OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam13OfPixelData, TRegRecWriteRam13OfPixelData, *PTRegRecWriteRam13OfPixelData;                               //0x100534

//Write data for ram 14 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam14OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam14OfPixelData, TRegRecWriteRam14OfPixelData, *PTRegRecWriteRam14OfPixelData;                               //0x100538

//Write data for ram 15 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam15OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam15OfPixelData, TRegRecWriteRam15OfPixelData, *PTRegRecWriteRam15OfPixelData;                               //0x10053C

//Write data for ram 16 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam16OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam16                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam16                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam16                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam16OfPixelData, TRegRecWriteRam16OfPixelData, *PTRegRecWriteRam16OfPixelData;                               //0x100540

//Write data for ram 17 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam17OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam17OfPixelData, TRegRecWriteRam17OfPixelData, *PTRegRecWriteRam17OfPixelData;                               //0x100544

//Write data for ram 18 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam18OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam18OfPixelData, TRegRecWriteRam18OfPixelData, *PTRegRecWriteRam18OfPixelData;                               //0x100548

//Write data for ram 19 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam19OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam19OfPixelData, TRegRecWriteRam19OfPixelData, *PTRegRecWriteRam19OfPixelData;                               //0x10054C

//Write data for ram 20 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam20OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam20OfPixelData, TRegRecWriteRam20OfPixelData, *PTRegRecWriteRam20OfPixelData;                               //0x100550

//Write data for ram 21 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam21OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam21OfPixelData, TRegRecWriteRam21OfPixelData, *PTRegRecWriteRam21OfPixelData;                               //0x100554

//Write data for ram 22 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam22OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam22OfPixelData, TRegRecWriteRam22OfPixelData, *PTRegRecWriteRam22OfPixelData;                               //0x100558

//Write data for ram 23 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam23OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam23OfPixelData, TRegRecWriteRam23OfPixelData, *PTRegRecWriteRam23OfPixelData;                               //0x10055C

//Write data for ram 24 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam24OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam24                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam24                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t PixelOverflowDataRam24                            :1          ; //Bits :[12:12], initial value: 0x0. Overflow marker--1 = Left; 0 = Right
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam24OfPixelData, TRegRecWriteRam24OfPixelData, *PTRegRecWriteRam24OfPixelData;                               //0x100560

//Write data for ram 25 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam25OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam25OfPixelData, TRegRecWriteRam25OfPixelData, *PTRegRecWriteRam25OfPixelData;                               //0x100564

//Write data for ram 26 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam26OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam26OfPixelData, TRegRecWriteRam26OfPixelData, *PTRegRecWriteRam26OfPixelData;                               //0x100568

//Write data for ram 27 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam27OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam27OfPixelData, TRegRecWriteRam27OfPixelData, *PTRegRecWriteRam27OfPixelData;                               //0x10056C

//Write data for ram 28 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam28OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam28OfPixelData, TRegRecWriteRam28OfPixelData, *PTRegRecWriteRam28OfPixelData;                               //0x100570

//Write data for ram 29 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam29OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam29OfPixelData, TRegRecWriteRam29OfPixelData, *PTRegRecWriteRam29OfPixelData;                               //0x100574

//Write data for ram 30 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam30OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam30OfPixelData, TRegRecWriteRam30OfPixelData, *PTRegRecWriteRam30OfPixelData;                               //0x100578

//Write data for ram 31 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecWriteRam31OfPixelData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t PixelData                                         :13         ; //Bits :[0:12], initial value: 0x0.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecWriteRam31OfPixelData, TRegRecWriteRam31OfPixelData, *PTRegRecWriteRam31OfPixelData;                               //0x10057C

//The act of writing to this register causes all 32 registers to be written into the Pixel Buffer (32 rams), the
// data for this register write is a don't care
//initial value: 0x00000000
typedef union __RegRecPixelBufferWriteControlBit{ //register type:W shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Reserved                                          :32         ; //Bits :[0:31], initial value: 0x0. Reserved.
     } fields_rmw; //for non-shadowed register
} RegRecPixelBufferWriteControlBit, TRegRecPixelBufferWriteControlBit, *PTRegRecPixelBufferWriteControlBit;                               //0x100580

//This is the address used to write Pixel Buffer data
//initial value: 0x00000000
typedef union __RegRecPixelBufferWriteAddress{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WrAddr                                            :14         ; //Bits :[0:13], initial value: 0x0.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t WrAddr                                            :14         ; //Bits :[0:13], initial value: 0x0.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t WrAddr                                            :14         ; //Bits :[0:13], initial value: 0x0.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecPixelBufferWriteAddress, TRegRecPixelBufferWriteAddress, *PTRegRecPixelBufferWriteAddress;                               //0x100584

//Read data from ram 00 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam00OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam00OfPixelData, TRegRecReadRam00OfPixelData, *PTRegRecReadRam00OfPixelData;                               //0x100600

//Read data from ram 01 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam01OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam01OfPixelData, TRegRecReadRam01OfPixelData, *PTRegRecReadRam01OfPixelData;                               //0x100604

//Read data from ram 02 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam02OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam02OfPixelData, TRegRecReadRam02OfPixelData, *PTRegRecReadRam02OfPixelData;                               //0x100608

//Read data from ram 03 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam03OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam03OfPixelData, TRegRecReadRam03OfPixelData, *PTRegRecReadRam03OfPixelData;                               //0x10060C

//Read data from ram 04 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam04OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam04OfPixelData, TRegRecReadRam04OfPixelData, *PTRegRecReadRam04OfPixelData;                               //0x100610

//Read data from ram 05 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam05OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam05OfPixelData, TRegRecReadRam05OfPixelData, *PTRegRecReadRam05OfPixelData;                               //0x100614

//Read data from ram 06 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam06OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam06OfPixelData, TRegRecReadRam06OfPixelData, *PTRegRecReadRam06OfPixelData;                               //0x100618

//Read data from ram 07 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam07OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam07OfPixelData, TRegRecReadRam07OfPixelData, *PTRegRecReadRam07OfPixelData;                               //0x10061C

//Read data from ram 08 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam08OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam08OfPixelData, TRegRecReadRam08OfPixelData, *PTRegRecReadRam08OfPixelData;                               //0x100620

//Read data from ram 09 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam09OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam09OfPixelData, TRegRecReadRam09OfPixelData, *PTRegRecReadRam09OfPixelData;                               //0x100624

//Read data from ram 10 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam10OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam10OfPixelData, TRegRecReadRam10OfPixelData, *PTRegRecReadRam10OfPixelData;                               //0x100628

//Read data from ram 11 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam11OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam11OfPixelData, TRegRecReadRam11OfPixelData, *PTRegRecReadRam11OfPixelData;                               //0x10062C

//Read data from ram 12 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam12OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam12OfPixelData, TRegRecReadRam12OfPixelData, *PTRegRecReadRam12OfPixelData;                               //0x100630

//Read data from ram 13 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam13OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam13OfPixelData, TRegRecReadRam13OfPixelData, *PTRegRecReadRam13OfPixelData;                               //0x100634

//Read data from ram 14 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam14OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam14OfPixelData, TRegRecReadRam14OfPixelData, *PTRegRecReadRam14OfPixelData;                               //0x100638

//Read data from ram 15 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam15OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam15OfPixelData, TRegRecReadRam15OfPixelData, *PTRegRecReadRam15OfPixelData;                               //0x10063C

//Read data from ram 16 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam16OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam16OfPixelData, TRegRecReadRam16OfPixelData, *PTRegRecReadRam16OfPixelData;                               //0x100640

//Read data from ram 17 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam17OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam17OfPixelData, TRegRecReadRam17OfPixelData, *PTRegRecReadRam17OfPixelData;                               //0x100644

//Read data from ram 18 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam18OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam18OfPixelData, TRegRecReadRam18OfPixelData, *PTRegRecReadRam18OfPixelData;                               //0x100648

//Read data from ram 19 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam19OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam19OfPixelData, TRegRecReadRam19OfPixelData, *PTRegRecReadRam19OfPixelData;                               //0x10064C

//Read data from ram 20 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam20OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam20OfPixelData, TRegRecReadRam20OfPixelData, *PTRegRecReadRam20OfPixelData;                               //0x100650

//Read data from ram 21 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam21OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam21OfPixelData, TRegRecReadRam21OfPixelData, *PTRegRecReadRam21OfPixelData;                               //0x100654

//Read data from ram 22 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam22OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam22OfPixelData, TRegRecReadRam22OfPixelData, *PTRegRecReadRam22OfPixelData;                               //0x100658

//Read data from ram 23 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam23OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam23OfPixelData, TRegRecReadRam23OfPixelData, *PTRegRecReadRam23OfPixelData;                               //0x10065C

//Read data from ram 24 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam24OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam24OfPixelData, TRegRecReadRam24OfPixelData, *PTRegRecReadRam24OfPixelData;                               //0x100660

//Read data from ram 25 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam25OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam25OfPixelData, TRegRecReadRam25OfPixelData, *PTRegRecReadRam25OfPixelData;                               //0x100664

//Read data from ram 26 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam26OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam26OfPixelData, TRegRecReadRam26OfPixelData, *PTRegRecReadRam26OfPixelData;                               //0x100668

//Read data from ram 27 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam27OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam27OfPixelData, TRegRecReadRam27OfPixelData, *PTRegRecReadRam27OfPixelData;                               //0x10066C

//Read data from ram 28 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam28OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam28OfPixelData, TRegRecReadRam28OfPixelData, *PTRegRecReadRam28OfPixelData;                               //0x100670

//Read data from ram 29 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam29OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam29OfPixelData, TRegRecReadRam29OfPixelData, *PTRegRecReadRam29OfPixelData;                               //0x100674

//Read data from ram 30 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam30OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam30OfPixelData, TRegRecReadRam30OfPixelData, *PTRegRecReadRam30OfPixelData;                               //0x100678

//Read data from ram 31 of Pixel Buffer
//initial value: 0x00000000
typedef union __RegRecReadRam31OfPixelData{ //register type:Status shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_read;
    struct {
        uint32_t PixelData                                         :12         ; //Bits :[0:11], initial value: 0x0. Pixel Data
        uint32_t Valid                                             :1          ; //Bits :[12:12], initial value: 0x0. Read Data Valid
        uint32_t Overflow                                          :1          ; //Bits :[13:13], initial value: 0x0. Overflow detect
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecReadRam31OfPixelData, TRegRecReadRam31OfPixelData, *PTRegRecReadRam31OfPixelData;                               //0x10067C

//The act of writing this register causes all 32 status registers to be loaded for read from the Pixel Buffer (32
//rams), the data for this register write is a don't care
//initial value: 0x00000000
typedef union __RegRecPixelBufferReadControlBit{ //register type:W shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Reserved                                          :32         ; //Bits :[0:31], initial value: 0x0. Reserved.
     } fields_rmw; //for non-shadowed register
} RegRecPixelBufferReadControlBit, TRegRecPixelBufferReadControlBit, *PTRegRecPixelBufferReadControlBit;                               //0x100680

//This is the address used to read Pixel Buffer data
//initial value: 0x00000000
typedef union __RegRecPixelBufferReadAddress{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RdAddr                                            :14         ; //Bits :[0:13], initial value: 0x0.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t RdAddr                                            :14         ; //Bits :[0:13], initial value: 0x0.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t RdAddr                                            :14         ; //Bits :[0:13], initial value: 0x0.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecPixelBufferReadAddress, TRegRecPixelBufferReadAddress, *PTRegRecPixelBufferReadAddress;                               //0x100684

//Register based pixel and frame generator.
//initial value: 0x00000000
typedef union __RegRecRecTestRegIf{ //register type:WO shadowed:NO
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TestRegVsync                                      :1          ; //Bits :[0:0], initial value: 0x0. Writing this will send a vsync pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegValid                                      :1          ; //Bits :[1:1], initial value: 0x0. Writing this will send a valid pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegSof                                        :1          ; //Bits :[2:2], initial value: 0x0. Writing this will send an SOF pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegSol                                        :1          ; //Bits :[3:3], initial value: 0x0. Writing this will send an SOL pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegEol                                        :1          ; //Bits :[4:4], initial value: 0x0. Writing this will send an EOL pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegEof                                        :1          ; //Bits :[5:5], initial value: 0x0. Writing this will send an EOF pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegLeftPixelData                              :12         ; //Bits :[6:17], initial value: 0x0. Writing this will send a pulse containing left pixel data to the REC, emulating the same from the real camera interface.
        uint32_t TestRegRightPixelData                             :12         ; //Bits :[18:29], initial value: 0x0. Writing this will send a pulse containing right pixel data to the REC, emulating the same from the real camera interface.
        uint32_t Reserved                                          :2          ; //Bits :[30:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_write;
    struct {
        uint32_t TestRegVsync                                      :1          ; //Bits :[0:0], initial value: 0x0. Writing this will send a vsync pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegValid                                      :1          ; //Bits :[1:1], initial value: 0x0. Writing this will send a valid pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegSof                                        :1          ; //Bits :[2:2], initial value: 0x0. Writing this will send an SOF pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegSol                                        :1          ; //Bits :[3:3], initial value: 0x0. Writing this will send an SOL pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegEol                                        :1          ; //Bits :[4:4], initial value: 0x0. Writing this will send an EOL pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegEof                                        :1          ; //Bits :[5:5], initial value: 0x0. Writing this will send an EOF pulse to the REC, emulating the same from the real camera interface.
        uint32_t TestRegLeftPixelData                              :12         ; //Bits :[6:17], initial value: 0x0. Writing this will send a pulse containing left pixel data to the REC, emulating the same from the real camera interface.
        uint32_t TestRegRightPixelData                             :12         ; //Bits :[18:29], initial value: 0x0. Writing this will send a pulse containing right pixel data to the REC, emulating the same from the real camera interface.
        uint32_t Reserved                                          :2          ; //Bits :[30:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_rmw; //for non-shadowed register
} RegRecRecTestRegIf, TRegRecRecTestRegIf, *PTRegRecRecTestRegIf;                               //0x100700

//Test pattern generator vertical blanking value
//initial value: 0x00300b
typedef union __RegRecRecTpgenVblank{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VerticalBlank                                     :24         ; //Bits :[0:23], initial value: 0x300B. Test pattern generator top blank and bottom blank--one half of total vertical blanking
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t VerticalBlank                                     :24         ; //Bits :[0:23], initial value: 0x300B. Test pattern generator top blank and bottom blank--one half of total vertical blanking
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t VerticalBlank                                     :24         ; //Bits :[0:23], initial value: 0x300B. Test pattern generator top blank and bottom blank--one half of total vertical blanking
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecRecTpgenVblank, TRegRecRecTpgenVblank, *PTRegRecRecTpgenVblank;                               //0x100704

//Test pattern generator horizontal blanking value
//initial value: 0x000028
typedef union __RegRecRecTpgenHblank{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t HorizontalBlank                                   :24         ; //Bits :[0:23], initial value: 0x28. Test pattern generator left blank and right blank--one half of total horizontal blanking
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t HorizontalBlank                                   :24         ; //Bits :[0:23], initial value: 0x28. Test pattern generator left blank and right blank--one half of total horizontal blanking
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t HorizontalBlank                                   :24         ; //Bits :[0:23], initial value: 0x28. Test pattern generator left blank and right blank--one half of total horizontal blanking
        uint32_t Reserved                                          :8          ; //Bits :[24:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecRecTpgenHblank, TRegRecRecTpgenHblank, *PTRegRecRecTpgenHblank;                               //0x100708

//Test pattern generator starting pixel value
//initial value: 0x3010201
typedef union __RegRecRecTpgenStartValue{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LeftPixelStartValue                               :12         ; //Bits :[0:11], initial value: 0x201. Test pattern generator right pixel starting value
        uint32_t Reserved1                                         :4          ; //Bits :[12:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t RightPixelStartValue                              :12         ; //Bits :[16:27], initial value: 0x301. Test pattern generator left pixel starting value
        uint32_t Reserved2                                         :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t LeftPixelStartValue                               :12         ; //Bits :[0:11], initial value: 0x201. Test pattern generator right pixel starting value
        uint32_t Reserved1                                         :4          ; //Bits :[12:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t RightPixelStartValue                              :12         ; //Bits :[16:27], initial value: 0x301. Test pattern generator left pixel starting value
        uint32_t Reserved2                                         :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t LeftPixelStartValue                               :12         ; //Bits :[0:11], initial value: 0x201. Test pattern generator right pixel starting value
        uint32_t Reserved1                                         :4          ; //Bits :[12:15], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
        uint32_t RightPixelStartValue                              :12         ; //Bits :[16:27], initial value: 0x301. Test pattern generator left pixel starting value
        uint32_t Reserved2                                         :4          ; //Bits :[28:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecRecTpgenStartValue, TRegRecRecTpgenStartValue, *PTRegRecRecTpgenStartValue;                               //0x10070C

//Test pattern generator speed control
//initial value: 0x00000014
typedef union __RegRecRecTpgenSpeed{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SpeedControl                                      :8          ; //Bits :[0:7], initial value: 0x14. Test pattern generator number of sclks between pixel valids
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t SpeedControl                                      :8          ; //Bits :[0:7], initial value: 0x14. Test pattern generator number of sclks between pixel valids
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t SpeedControl                                      :8          ; //Bits :[0:7], initial value: 0x14. Test pattern generator number of sclks between pixel valids
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegRecRecTpgenSpeed, TRegRecRecTpgenSpeed, *PTRegRecRecTpgenSpeed;                               //0x100710

//Rec Output Frame Counter
//initial value: 0x00000000
typedef union __RegRecRecFrameCounter{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t OutputFrameCount                                  :32         ; //Bits :[0:31], initial value: 0x0. Output Frame Count
     } fields_read;
    struct {
        uint32_t OutputFrameCount                                  :32         ; //Bits :[0:31], initial value: 0x0. Output Frame Count
     } fields_rmw; //for non-shadowed register
} RegRecRecFrameCounter, TRegRecRecFrameCounter, *PTRegRecRecFrameCounter;                               //0x100714

//Rec Input Frame SCLK Count
//initial value: 0x00000000
typedef union __RegRecRecInframeSclkCount{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t InputFrameSclkCount                               :32         ; //Bits :[0:31], initial value: 0x0. Input Frame SCLK Count
     } fields_read;
    struct {
        uint32_t InputFrameSclkCount                               :32         ; //Bits :[0:31], initial value: 0x0. Input Frame SCLK Count
     } fields_rmw; //for non-shadowed register
} RegRecRecInframeSclkCount, TRegRecRecInframeSclkCount, *PTRegRecRecInframeSclkCount;                               //0x100718

//Rec Output Frame SCLK Count
//initial value: 0x00000000
typedef union __RegRecRecOutframeSclkCount{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t OutputFrameSclkCount                              :32         ; //Bits :[0:31], initial value: 0x0. Output Frame SCLK Count
     } fields_read;
    struct {
        uint32_t OutputFrameSclkCount                              :32         ; //Bits :[0:31], initial value: 0x0. Output Frame SCLK Count
     } fields_rmw; //for non-shadowed register
} RegRecRecOutframeSclkCount, TRegRecRecOutframeSclkCount, *PTRegRecRecOutframeSclkCount;                               //0x10071C

//##############################################################
//                      scp_registers area
//##############################################################
//RSM Bypass mode and threshold value control for RSM.
//initial value: 0x00800000
typedef union __RegScpRsmControlReg{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t RemoveThresh                                      :8          ; //Bits :[0:7], initial value: 0x0. Threshold for Outlier removal in RSM. 8bit integer (8.0)
        uint32_t SloRauDiffThresh                                  :7          ; //Bits :[8:14], initial value: 0x0. Threshold for SLO and RAU disparity difference in RSM. Fixed point 7bit (2.5)
        uint32_t DiffThresh                                        :8          ; //Bits :[15:22], initial value: 0x0. Threshold for SLO disparity difference to Center in RSM. Fixed point 8bit (3.5)
        uint32_t RsmBypass                                         :1          ; //Bits :[23:23], initial value: 0x1. RSM Bypass mode. 1=Bypass (default). At Bypass mode, SLO disparity input will be bypassed to RSM disparity output.
        uint32_t RsmBypassCg                                       :1          ; //Bits :[24:24], initial value: 0x0. Clock gate control for the block which is not used at RSM Bypass mode. 1=Clock gate. 0=Clock enabled (default). RSM_Bypass_CG must be 0 (=clock enabled) at least 1 clock period before and after RSM_Bypass_SD transition.
        uint32_t RsmBypassSd                                       :1          ; //Bits :[25:25], initial value: 0x0. SRAM shutdown control for SRAM1 which is not used at RSM Bypass mode in RSM. 1=Shutdown. 0=Enabled (default). RSM_Bypass_CG must be 0 (=clock enabled) at least 1 clock period before and after RSM_Bypass_SD transition. Also need to not read/write SRAM for 30 sclk cycle when SD goes low (waking up)
        uint32_t Reserved                                          :6          ; //Bits :[26:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpRsmControlReg, TRegScpRsmControlReg, *PTRegScpRsmControlReg;                                //0x20000

//Set additional censusPipeStall length for V blank
//initial value: 0x00000000
typedef union __RegScpAdditionalVblank{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t AdditionalVblank                                  :4          ; //Bits :[0:3], initial value: 0x0. Define number of scan line to add to 4 scan line censusPipeStall for V blank. When set N at this additional_vblank, censusPipeStall will be high for 4 + N scan line period for V blank. N can be set as 0 (default) to 15. For RSM bypass mode, please set 3. For RSM mode, please set 9.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpAdditionalVblank, TRegScpAdditionalVblank, *PTRegScpAdditionalVblank;                                //0x20004

//Local clock gate control for SCP
//initial value: 0x00000000
typedef union __RegScpLocalClkGateEnable{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t EnScpLocalClkGate                                 :1          ; //Bits :[0:0], initial value: 0x0. Enable SCP local clock gate for DS5-B0. 1=Enable (default). 0=Disable.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpLocalClkGateEnable, TRegScpLocalClkGateEnable, *PTRegScpLocalClkGateEnable;                                //0x20008

//Bit enables for enabling individual census comparisons.  Can be used to reduce the size of the census window.
//initial value: 0xffffffff
typedef union __RegScpCensusEnableReg{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t En                                                :32         ; //Bits :[0:31], initial value: 0xFFFFFFFF. One bit per census pixel
     } fields_read;
} RegScpCensusEnableReg, TRegScpCensusEnableReg, *PTRegScpCensusEnableReg;                                //0x20010

//Size of the SCP Input/Output images. Note for DS5, the input and output images sizes are always the same.
//initial value: 0x02D00500
typedef union __RegScpScpImageSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Width                                             :16         ; //Bits :[0:15], initial value: 0x500. Number of pixels per line in the input/output images. Valid values 256 to 1280
        uint32_t Height                                            :16         ; //Bits :[16:31], initial value: 0x2D0. Number of lines in the input/output images. Valid values 40 to 1024
     } fields_read;
    struct {
        uint32_t Width                                             :16         ; //Bits :[0:15], initial value: 0x500. Number of pixels per line in the input/output images. Valid values 256 to 1280
        uint32_t Height                                            :16         ; //Bits :[16:31], initial value: 0x2D0. Number of lines in the input/output images. Valid values 40 to 1024
     } fields_write;
    struct {
        uint32_t Width                                             :16         ; //Bits :[0:15], initial value: 0x500. Number of pixels per line in the input/output images. Valid values 256 to 1280
        uint32_t Height                                            :16         ; //Bits :[16:31], initial value: 0x2D0. Number of lines in the input/output images. Valid values 40 to 1024
     } fields_rmw; //for non-shadowed register
} RegScpScpImageSize, TRegScpScpImageSize, *PTRegScpScpImageSize;                                //0x2003C

//Set the Robbins-Munroe coefficients used for the stochastic approximation of          the median score on the correlation
//surface.
//initial value: 0x0
typedef union __RegScpDeepseaRobbinsMunroe{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t PlusIncrement                                     :8          ; //Bits :[0:7], initial value: 0x0. This value is added to the running-median estimate of the estimate is below      the sequentially-sampled correlation score.
        uint32_t MinusDecrement                                    :8          ; //Bits :[8:15], initial value: 0x0. This value is subtracted from the running-median estimate of the estimate is above             the sequentially-sampled correlation score.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpDeepseaRobbinsMunroe, TRegScpDeepseaRobbinsMunroe, *PTRegScpDeepseaRobbinsMunroe;                                //0x20718

//Sets the thresholds for filtering Left to Right winning scores.
//initial value: 0x0
typedef union __RegScpDeepseaScoreThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t ScoreThreshA                                      :10         ; //Bits :[0:9], initial value: 0x0. Contains a 10-bit binary number used directly as a threshold for the winning Left-Right score.             Interest operator bit 0 asserts if the winning score is greater than or equal Score Thresh A .
        uint32_t ScoreThreshB                                      :12         ; //Bits :[10:21], initial value: 0x0. Contains a 12-bit binary threshold for the winning Left-Right score.     Interest operator bit 1 asserts if the winning score is greater than Score Thresh B.
        uint32_t Reserved                                          :10         ; //Bits :[22:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpDeepseaScoreThreshold, TRegScpDeepseaScoreThreshold, *PTRegScpDeepseaScoreThreshold;                                //0x2071C

//Sets the threshold used to filter pre and post scores.
//initial value: 0x0
typedef union __RegScpDeepseaNeighborThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t DeepseaNeighborThreshold                          :10         ; //Bits :[0:9], initial value: 0x0. Contains a 10-bit binary number compared against the difference of the pre (and post)              score and the winning score. Interest operator bit 2 asserts if the post score is greater than Neighbor Threshold.              Interest operator bit 3 asserts if the pre score is greater than Neighbor Threshold.
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpDeepseaNeighborThreshold, TRegScpDeepseaNeighborThreshold, *PTRegScpDeepseaNeighborThreshold;                                //0x20720

//Sets the threshold used to compare between LR and RL disparities.
//initial value: 0x0
typedef union __RegScpDeepseaLrThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t LrAgreeThreshold                                  :11         ; //Bits :[0:10], initial value: 0x0. Contain an 11-bit binary number used directly as LR threshold. Interest operator bit 8              asserts if difference between the LR and RL disparities are less than threshold.
        uint32_t LrScoreAverageDisable                             :1          ; //Bits :[11:11], initial value: 0x0. Disables the averaging of LR and RL scores when set.
        uint32_t Reserved                                          :20         ; //Bits :[12:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpDeepseaLrThreshold, TRegScpDeepseaLrThreshold, *PTRegScpDeepseaLrThreshold;                                //0x20724

//Texture threshold
//initial value: 0x0
typedef union __RegScpDeepseaTextureThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t TextureDifferenceThreshold                        :12         ; //Bits :[0:11], initial value: 0x0. Bits 0..11 of the {Texture Thresh} configuration register contain a 12-bit binary number which is used directly. This value defines the threshold to use in the the Texture operator difference calculation.
        uint32_t TextureCountThreshold                             :6          ; //Bits :[12:17], initial value: 0x0. Bits 12..17 of the {Texture Thresh} configuration register contain a 5-bit binary number which is used directly to compare to the count of the number of significantly different pixel locations in the active census kernel neighborhood.
        uint32_t Reserved                                          :14         ; //Bits :[18:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpDeepseaTextureThreshold, TRegScpDeepseaTextureThreshold, *PTRegScpDeepseaTextureThreshold;                                //0x20728

//threshold for 2nd peak interest operator
//initial value: 0x0
typedef union __RegScpDeepseaSecondPeakThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t DeepseaSecondPeakThreshold                        :10         ; //Bits :[0:9], initial value: 0x0. Second Peak Threshold
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpDeepseaSecondPeakThreshold, TRegScpDeepseaSecondPeakThreshold, *PTRegScpDeepseaSecondPeakThreshold;                                //0x2072C

//threshold for Meadian interest operator
//initial value: 0x0
typedef union __RegScpDeepseaMedianThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t DeepseaMedianThreshold                            :10         ; //Bits :[0:9], initial value: 0x0. Median Threshold
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpDeepseaMedianThreshold, TRegScpDeepseaMedianThreshold, *PTRegScpDeepseaMedianThreshold;                                //0x20730

//Z data masking function, which was in the PRS block on DS5.            ZEncoder Reg0 is used when Interest=0
//initial value: 0xffff0000
typedef union __RegScpZencoderReg0{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t OrMaskBits                                        :16         ; //Bits :[0:15], initial value: 0x0. Bits [15:0] are ORed with the Z output data to generate prs_dout
        uint32_t AndMaskBits                                       :16         ; //Bits :[16:31], initial value: 0xFFFF. Bits [31:16] are ANDed with the Z output data to generate prs_dout
     } fields_read;
} RegScpZencoderReg0, TRegScpZencoderReg0, *PTRegScpZencoderReg0;                                //0x2074C

//Z data masking function, which was in the PRS block on DS3.           ZEncoder Reg1 is used when Interest=1
//initial value: 0xffff0000
typedef union __RegScpZencoderReg1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t OrMaskBits                                        :16         ; //Bits :[0:15], initial value: 0x0. Bits [15:0] are ORed with the Z output data to generate prs_dout
        uint32_t AndMaskBits                                       :16         ; //Bits :[16:31], initial value: 0xFFFF. Bits [31:16] are ANDed with the Z output data to generate prs_dout
     } fields_read;
} RegScpZencoderReg1, TRegScpZencoderReg1, *PTRegScpZencoderReg1;                                //0x20750

//Minimum horizontal and vertical support vectors. If the color differences computed are less than the minimum values,
//use the minimum.
//initial value: 0x12311311
typedef union __RegScpRauSupportVectorMinima{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Minwest                                           :4          ; //Bits :[0:3], initial value: 0x1. Sets the left Horizontal Minimum when the color differences calculation has                          Fewer than horizontalSumMin pixels. If the Color Control register has RAU color disabled, then minWest defines the west offset for a fixed region.
        uint32_t Mineast                                           :4          ; //Bits :[4:7], initial value: 0x1. Sets the right Horizontal Minimum when the color differences calculation has                          Fewer than horizontalSumMin pixels. If the Color Control register has RAU color disabled, then minEast defines the east offset for a fixed region.
        uint32_t Minwesum                                          :4          ; //Bits :[8:11], initial value: 0x3. Sets the horizontal sum minimum, usually leftMin + rightMin +1. Valid values 3 through 15.
        uint32_t Minnorth                                          :4          ; //Bits :[12:15], initial value: 0x1. Sets the up vertical minimimum when the color differences calculation has                          Fewer than verticalSumMin pixels.  If the Color Control register has RAU color disabled, then minNorth defines the north offset for a fixed region.
        uint32_t Minsouth                                          :4          ; //Bits :[16:19], initial value: 0x1. Sets the down Vertical Minimum when the color differences calculation has                          Fewer than verticalSumMin pixels.  If the Color Control register has RAU color disabled, then minSouth defines the south offset for a fixed region.
        uint32_t Minnssum                                          :4          ; //Bits :[20:23], initial value: 0x3. Sets the vertical sum minimum- usually upMin+downMin+1. Valid values 1 through 7.
        uint32_t Ushrink                                           :4          ; //Bits :[24:27], initial value: 0x2. Sets the horizontal shrink factor. Valid values 0 through 4.
        uint32_t Vshrink                                           :4          ; //Bits :[28:31], initial value: 0x1. Sets the vertical shrink factor. Valid values 0 and 1.
     } fields_read;
} RegScpRauSupportVectorMinima, TRegScpRauSupportVectorMinima, *PTRegScpRauSupportVectorMinima;                                //0x20754

//Disables color functions, for instance when using a monochrome camera
//initial value: 0x0000
typedef union __RegScpColorControl{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Disablesadcolor                                   :1          ; //Bits :[0:0], initial value: 0x0. Disables Sum of Absolute Differences function
        uint32_t Disableraucolor                                   :1          ; //Bits :[1:1], initial value: 0x0. disable RAU color function and use region defined by minimum support vectors
        uint32_t Disableslorightcolor                              :1          ; //Bits :[2:2], initial value: 0x0. disable SLO right image color function and use default penalties
        uint32_t Disablesloleftcolor                               :1          ; //Bits :[3:3], initial value: 0x0. disable SLO left image color function and use default penalties
        uint32_t Disablesadnormalize                               :1          ; //Bits :[4:4], initial value: 0x0. In the SAD function, disable normalization and use the unmodified RGB values.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpColorControl, TRegScpColorControl, *PTRegScpColorControl;                                //0x20758

//Sets RAU difference threshold
//initial value: 0x3fc3fcff
typedef union __RegScpRauThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Raudiffthresholdred                               :10         ; //Bits :[0:9], initial value: 0xFF. Sets the RAU color difference comparison threshold for the Red component.
        uint32_t Raudiffthresholdgreen                             :10         ; //Bits :[10:19], initial value: 0xFF. Sets the RAU color difference comparison threshold for the Green component.
        uint32_t Raudiffthresholdblue                              :10         ; //Bits :[20:29], initial value: 0x3FC. Sets the RAU color difference comparison threshold for the Blue component.
        uint32_t Reserved                                          :2          ; //Bits :[30:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpRauThreshold, TRegScpRauThreshold, *PTRegScpRauThreshold;                                //0x20760

//Sets SLO color difference threshold.
//initial value: 0x3fc3fcff
typedef union __RegScpSloThreshold{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t Diffthresholdred                                  :10         ; //Bits :[0:9], initial value: 0xFF. Sets the SLO color difference comparison threshold for the Red component.
        uint32_t Diffthresholdgreen                                :10         ; //Bits :[10:19], initial value: 0xFF. Sets the SLO color difference comparison threshold for the Green component.
        uint32_t Diffthresholdblue                                 :10         ; //Bits :[20:29], initial value: 0x3FC. Sets the SLO color difference comparison threshold for the Blue component.
        uint32_t Reserved                                          :2          ; //Bits :[30:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpSloThreshold, TRegScpSloThreshold, *PTRegScpSloThreshold;                                //0x20764

//Sets SLO K1 penalty when not modified by color comparisons
//initial value: 0x00ff
typedef union __RegScpSloK1penalty{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1penalty                                         :9          ; //Bits :[0:8], initial value: 0xFF. Sets the SLO K1 Penalty to apply when not modified by color comparisons. Valid values 1 through 511.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpSloK1penalty, TRegScpSloK1penalty, *PTRegScpSloK1penalty;                                //0x2076C

//Sets SLO K2 penalty when not modified by color comparisons
//initial value: 0x00ff
typedef union __RegScpSloK2penalty{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2penalty                                         :9          ; //Bits :[0:8], initial value: 0xFF. Sets the SLO K2 Penalty to apply when not modified by color comparisons. Valid values 1 through 511.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpSloK2penalty, TRegScpSloK2penalty, *PTRegScpSloK2penalty;                                //0x20770

//Sets SLO K1 penalty when modified by one color comparison
//initial value: 0x00ff
typedef union __RegScpSloK1penaltymod1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1penaltymod1                                     :9          ; //Bits :[0:8], initial value: 0xFF. Sets the SLO K1 Penalty to apply when modified by one color comparison. Valid values 1 through 511.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpSloK1penaltymod1, TRegScpSloK1penaltymod1, *PTRegScpSloK1penaltymod1;                                //0x20774

//Sets the SLO K1 Penalty to apply when modified by two color comparisons
//initial value: 0x00ff
typedef union __RegScpSloK1penaltymod2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K1penaltymod2                                     :9          ; //Bits :[0:8], initial value: 0xFF. Sets the SLO K2 Penalty to apply when not modified by color comparisons. Valid values 1 through 511.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpSloK1penaltymod2, TRegScpSloK1penaltymod2, *PTRegScpSloK1penaltymod2;                                //0x20778

//Sets SLO K2 penalty when modified by one color comparison
//initial value: 0x00ff
typedef union __RegScpSloK2penaltymod1{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2penaltymod1                                     :9          ; //Bits :[0:8], initial value: 0xFF. Sets the SLO K1 Penalty to apply when modified by one color comparison. Valid values 1 through 511.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpSloK2penaltymod1, TRegScpSloK2penaltymod1, *PTRegScpSloK2penaltymod1;                                //0x2077C

//Sets the SLO K2 Penalty to apply when modified by two color comparisons
//initial value: 0x00ff
typedef union __RegScpSloK2penaltymod2{ //register type:RW shadowed:YES
    uint32_t value_read;
    uint32_t value_write;
    struct {
        uint32_t K2penaltymod2                                     :9          ; //Bits :[0:8], initial value: 0xFF. Sets the SLO K2 Penalty to apply when modified by one color comparison. Valid values 1 through 511.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Write has no effect. Read always returns 0's
     } fields_read;
} RegScpSloK2penaltymod2, TRegScpSloK2penaltymod2, *PTRegScpSloK2penaltymod2;                                //0x20780

//32 deep by 8-bit lookup table for scaling Hamming Distance Values in bcc
//initial value:
typedef union __RegScpHammingDistanceLookupTable{ //register type:Memory shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Data                                              :8          ; //Bits :[0:7], initial value: 0x0.  Addressed by Hamming Distance, output is scaled value
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_rmw; //for non-shadowed register
} RegScpHammingDistanceLookupTable, TRegScpHammingDistanceLookupTable, *PTRegScpHammingDistanceLookupTable;                                //0x20800

//256 deep by 8-bit lookup table for scaling color Sum Of Distance Values in bcc
//initial value:
typedef union __RegScpSadLookupTable{ //register type:Memory shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Data                                              :8          ; //Bits :[0:7], initial value: 0x0.  Addressed by SAD, output is scaled value
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_rmw; //for non-shadowed register
} RegScpSadLookupTable, TRegScpSadLookupTable, *PTRegScpSadLookupTable;                                //0x20C00

//106 deep by 16-bit lookup table for scaling color Sum Of Distance Values in bcc
//initial value:
typedef union __RegScpRauInverseTable{ //register type:Memory shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Data                                              :16         ; //Bits :[0:15], initial value: 0x0.  addressed by RAU pixel sum, output is inverse value
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_rmw; //for non-shadowed register
} RegScpRauInverseTable, TRegScpRauInverseTable, *PTRegScpRauInverseTable;                                //0x21000

//512 deep lookup table for converting thresholds to interest
//initial value:
typedef union __RegScpInterestLookupTable{ //register type:Memory shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Data                                              :2          ; //Bits :[0:1], initial value: 0x0.  Data is the 2 bit interest value
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_rmw; //for non-shadowed register
} RegScpInterestLookupTable, TRegScpInterestLookupTable, *PTRegScpInterestLookupTable;                                //0x22000

//4096 entry lookup table for converting left-right score values to a 5-bit sub-pixel value
//initial value:
typedef union __RegScpSubPixelLookupTable{ //register type:Memory shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Data                                              :5          ; //Bits :[0:4], initial value: 0x0.  Data is 5 bits sub pixel value
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_rmw; //for non-shadowed register
} RegScpSubPixelLookupTable, TRegScpSubPixelLookupTable, *PTRegScpSubPixelLookupTable;                                //0x24000

//4 sets of 4096 deep lookup table for converting disparity to range data.
//initial value:
typedef union __RegScpRangeLookupTable{ //register type:Memory shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Data                                              :16         ; //Bits :[0:15], initial value: 0x0.  Data is the 16 bit range value
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_rmw; //for non-shadowed register
} RegScpRangeLookupTable, TRegScpRangeLookupTable, *PTRegScpRangeLookupTable;                                //0x30000

//128 deep Alpha lookup table for RSM.
//initial value:
typedef union __RegScpAlphaLookupTable{ //register type:Memory shadowed:NO
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Data                                              :5          ; //Bits :[0:4], initial value: 0x0.  Data is the 5 bit Weighting Factor Alpha value
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Write has no effect.
     } fields_rmw; //for non-shadowed register
} RegScpAlphaLookupTable, TRegScpAlphaLookupTable, *PTRegScpAlphaLookupTable;                                //0x23000

//##############################################################
//                      see_registers area
//##############################################################
//Control reg to set frame size, SCK phase/polarity, and transfer mode
//initial value: 0x0002000
typedef union __RegSeeCtrl0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DataFrameSize                                     :4          ; //Bits :[0:3], initial value: 0x0. Size-1 (bits) of each data item;  0=32 bits, 1=2 bits, 15=16 bits;  This must be set to 7 in memory read mode.
        uint32_t ByteMemoryMode                                    :1          ; //Bits :[4:4], initial value: 0x0. Perform memory access in byte mode
        uint32_t TxPacingEnable                                    :1          ; //Bits :[5:5], initial value: 0x0. Enable Tx Pacing mode
        uint32_t SerialClockPhase                                  :1          ; //Bits :[6:6], initial value: 0x0. SCK phase;  0: data captured on first edge,  1: data captured on second edge
        uint32_t SerialClockPolarity                               :1          ; //Bits :[7:7], initial value: 0x0. SCK polarity; 0: idle clock state is 0,  1: idle clock state is 1
        uint32_t TransferMode                                      :2          ; //Bits :[8:9], initial value: 0x0. Transfer mode; 00: Xmit and Rcv,  01: Xmit only,  10: reserved,  11: memory read
        uint32_t Reserved1                                         :2          ; //Bits :[10:11], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ReadEndianSwap                                    :1          ; //Bits :[12:12], initial value: 0x0. Endian swap FIFO data reads
        uint32_t SpiOeDisable                                      :1          ; //Bits :[13:13], initial value: 0x1. 1: tri-state all SPI pins, 0: normal operation
        uint32_t SpiExtRxClk                                       :1          ; //Bits :[14:14], initial value: 0x0. 1: enable MISO data capture with SPI_CLK,  0: grab with internal timing
        uint32_t Reserved2                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DummyClockCount                                   :4          ; //Bits :[16:19], initial value: 0x0. Number of dummy clocks between opcode and SPI memory read data
     } fields_read;
    struct {
        uint32_t DataFrameSize                                     :4          ; //Bits :[0:3], initial value: 0x0. Size-1 (bits) of each data item;  0=32 bits, 1=2 bits, 15=16 bits;  This must be set to 7 in memory read mode.
        uint32_t ByteMemoryMode                                    :1          ; //Bits :[4:4], initial value: 0x0. Perform memory access in byte mode
        uint32_t TxPacingEnable                                    :1          ; //Bits :[5:5], initial value: 0x0. Enable Tx Pacing mode
        uint32_t SerialClockPhase                                  :1          ; //Bits :[6:6], initial value: 0x0. SCK phase;  0: data captured on first edge,  1: data captured on second edge
        uint32_t SerialClockPolarity                               :1          ; //Bits :[7:7], initial value: 0x0. SCK polarity; 0: idle clock state is 0,  1: idle clock state is 1
        uint32_t TransferMode                                      :2          ; //Bits :[8:9], initial value: 0x0. Transfer mode; 00: Xmit and Rcv,  01: Xmit only,  10: reserved,  11: memory read
        uint32_t Reserved1                                         :2          ; //Bits :[10:11], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ReadEndianSwap                                    :1          ; //Bits :[12:12], initial value: 0x0. Endian swap FIFO data reads
        uint32_t SpiOeDisable                                      :1          ; //Bits :[13:13], initial value: 0x1. 1: tri-state all SPI pins, 0: normal operation
        uint32_t SpiExtRxClk                                       :1          ; //Bits :[14:14], initial value: 0x0. 1: enable MISO data capture with SPI_CLK,  0: grab with internal timing
        uint32_t Reserved2                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DummyClockCount                                   :4          ; //Bits :[16:19], initial value: 0x0. Number of dummy clocks between opcode and SPI memory read data
     } fields_write;
    struct {
        uint32_t DataFrameSize                                     :4          ; //Bits :[0:3], initial value: 0x0. Size-1 (bits) of each data item;  0=32 bits, 1=2 bits, 15=16 bits;  This must be set to 7 in memory read mode.
        uint32_t ByteMemoryMode                                    :1          ; //Bits :[4:4], initial value: 0x0. Perform memory access in byte mode
        uint32_t TxPacingEnable                                    :1          ; //Bits :[5:5], initial value: 0x0. Enable Tx Pacing mode
        uint32_t SerialClockPhase                                  :1          ; //Bits :[6:6], initial value: 0x0. SCK phase;  0: data captured on first edge,  1: data captured on second edge
        uint32_t SerialClockPolarity                               :1          ; //Bits :[7:7], initial value: 0x0. SCK polarity; 0: idle clock state is 0,  1: idle clock state is 1
        uint32_t TransferMode                                      :2          ; //Bits :[8:9], initial value: 0x0. Transfer mode; 00: Xmit and Rcv,  01: Xmit only,  10: reserved,  11: memory read
        uint32_t Reserved1                                         :2          ; //Bits :[10:11], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ReadEndianSwap                                    :1          ; //Bits :[12:12], initial value: 0x0. Endian swap FIFO data reads
        uint32_t SpiOeDisable                                      :1          ; //Bits :[13:13], initial value: 0x1. 1: tri-state all SPI pins, 0: normal operation
        uint32_t SpiExtRxClk                                       :1          ; //Bits :[14:14], initial value: 0x0. 1: enable MISO data capture with SPI_CLK,  0: grab with internal timing
        uint32_t Reserved2                                         :1          ; //Bits :[15:15], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t DummyClockCount                                   :4          ; //Bits :[16:19], initial value: 0x0. Number of dummy clocks between opcode and SPI memory read data
     } fields_rmw; //for non-shadowed register
} RegSeeCtrl0, TRegSeeCtrl0, *PTRegSeeCtrl0;                                //0x10400

//Memory Read mode transfer count
//initial value: 0x0000
typedef union __RegSeeCtrl1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NumberDataFrames                                  :16         ; //Bits :[0:15], initial value: 0x0. Number of data frames to receive in memory read mode;  0=1 dword to transfer, 1=2 dwords, etc.
     } fields_read;
    struct {
        uint32_t NumberDataFrames                                  :16         ; //Bits :[0:15], initial value: 0x0. Number of data frames to receive in memory read mode;  0=1 dword to transfer, 1=2 dwords, etc.
     } fields_write;
    struct {
        uint32_t NumberDataFrames                                  :16         ; //Bits :[0:15], initial value: 0x0. Number of data frames to receive in memory read mode;  0=1 dword to transfer, 1=2 dwords, etc.
     } fields_rmw; //for non-shadowed register
} RegSeeCtrl1, TRegSeeCtrl1, *PTRegSeeCtrl1;                                //0x10404

//SPI module enable/reset
//initial value: 0x000000
typedef union __RegSeeSpiEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SsiEn                                             :1          ; //Bits :[0:0], initial value: 0x0. SPI module enable;  0: reset/disabled (TX and RX FIFOs are reset), 1: enabled
     } fields_read;
    struct {
        uint32_t SsiEn                                             :1          ; //Bits :[0:0], initial value: 0x0. SPI module enable;  0: reset/disabled (TX and RX FIFOs are reset), 1: enabled
     } fields_write;
    struct {
        uint32_t SsiEn                                             :1          ; //Bits :[0:0], initial value: 0x0. SPI module enable;  0: reset/disabled (TX and RX FIFOs are reset), 1: enabled
     } fields_rmw; //for non-shadowed register
} RegSeeSpiEnable, TRegSeeSpiEnable, *PTRegSeeSpiEnable;                                //0x10408

//SHA256 data wr
//initial value: 0xDEADF00D
typedef union __RegSeeShaDataWr{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ShaDataWr                                         :32         ; //Bits :[0:31], initial value: 0xDEADF00D. SHA256 hash data write (LCP), non-swapped, [31:24] is first message byte
     } fields_read;
    struct {
        uint32_t ShaDataWr                                         :32         ; //Bits :[0:31], initial value: 0xDEADF00D. SHA256 hash data write (LCP), non-swapped, [31:24] is first message byte
     } fields_rmw; //for non-shadowed register
} RegSeeShaDataWr, TRegSeeShaDataWr, *PTRegSeeShaDataWr;                                //0x1040C

//SHA256 data wr, endian swapped
//initial value: 0xDEADF00D
typedef union __RegSeeShaDataWrSwapped{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ShaDataWrSwapped                                  :32         ; //Bits :[0:31], initial value: 0xDEADF00D. SHA256 hash data write (LCP), endian-swapped, [7:0] is first message byte
     } fields_read;
    struct {
        uint32_t ShaDataWrSwapped                                  :32         ; //Bits :[0:31], initial value: 0xDEADF00D. SHA256 hash data write (LCP), endian-swapped, [7:0] is first message byte
     } fields_rmw; //for non-shadowed register
} RegSeeShaDataWrSwapped, TRegSeeShaDataWrSwapped, *PTRegSeeShaDataWrSwapped;                                //0x10410

//SPI clock divisor.  Must (normally) be even and greater than 1.
//initial value: 0x0000000
typedef union __RegSeeBaudRateDivisor{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Sckdv                                             :8          ; //Bits :[0:7], initial value: 0x0. SPI clock divisor.  Fsclk_out = Fapb / SCKDV
     } fields_read;
    struct {
        uint32_t Sckdv                                             :8          ; //Bits :[0:7], initial value: 0x0. SPI clock divisor.  Fsclk_out = Fapb / SCKDV
     } fields_write;
    struct {
        uint32_t Sckdv                                             :8          ; //Bits :[0:7], initial value: 0x0. SPI clock divisor.  Fsclk_out = Fapb / SCKDV
     } fields_rmw; //for non-shadowed register
} RegSeeBaudRateDivisor, TRegSeeBaudRateDivisor, *PTRegSeeBaudRateDivisor;                                //0x10414

//Transmit FIFO interrupt threshold
//initial value: 0x0
typedef union __RegSeeTransmitFifoThreshold{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Tft                                               :8          ; //Bits :[0:7], initial value: 0x0. Transmit FIFO interrupt threshold;  sets the level at or below which the TX FIFO Threshold IRQ will trigger
     } fields_read;
    struct {
        uint32_t Tft                                               :8          ; //Bits :[0:7], initial value: 0x0. Transmit FIFO interrupt threshold;  sets the level at or below which the TX FIFO Threshold IRQ will trigger
     } fields_write;
    struct {
        uint32_t Tft                                               :8          ; //Bits :[0:7], initial value: 0x0. Transmit FIFO interrupt threshold;  sets the level at or below which the TX FIFO Threshold IRQ will trigger
     } fields_rmw; //for non-shadowed register
} RegSeeTransmitFifoThreshold, TRegSeeTransmitFifoThreshold, *PTRegSeeTransmitFifoThreshold;                                //0x10418

//Receive FIFO interrupt threshold
//initial value: 0x0
typedef union __RegSeeReceiveFifoThreshold{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Rft                                               :8          ; //Bits :[0:7], initial value: 0x0. Receive FIFO interrupt threshold;  sets the level at or above which the RX FIFO Threshold IRQ will trigger
     } fields_read;
    struct {
        uint32_t Rft                                               :8          ; //Bits :[0:7], initial value: 0x0. Receive FIFO interrupt threshold;  sets the level at or above which the RX FIFO Threshold IRQ will trigger
     } fields_write;
    struct {
        uint32_t Rft                                               :8          ; //Bits :[0:7], initial value: 0x0. Receive FIFO interrupt threshold;  sets the level at or above which the RX FIFO Threshold IRQ will trigger
     } fields_rmw; //for non-shadowed register
} RegSeeReceiveFifoThreshold, TRegSeeReceiveFifoThreshold, *PTRegSeeReceiveFifoThreshold;                                //0x1041C

//Transmit FIFO Level
//initial value: 0x0
typedef union __RegSeeTransmitFifoLevel{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Tft                                               :8          ; //Bits :[0:7], initial value: 0x0. Number of items in the Transmit FIFO
     } fields_read;
    struct {
        uint32_t Tft                                               :8          ; //Bits :[0:7], initial value: 0x0. Number of items in the Transmit FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeTransmitFifoLevel, TRegSeeTransmitFifoLevel, *PTRegSeeTransmitFifoLevel;                                //0x10420

//Receive FIFO Level
//initial value: 0x0
typedef union __RegSeeReceiveFifoLevel{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Rft                                               :8          ; //Bits :[0:7], initial value: 0x0. Number of items in the Receive FIFO
     } fields_read;
    struct {
        uint32_t Rft                                               :8          ; //Bits :[0:7], initial value: 0x0. Number of items in the Receive FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeReceiveFifoLevel, TRegSeeReceiveFifoLevel, *PTRegSeeReceiveFifoLevel;                                //0x10424

//Module FIFO and Busy status
//initial value: 0x6
typedef union __RegSeeStatusRegister{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Busy                                              :1          ; //Bits :[0:0], initial value: 0x0. Module busy status; 0: idle, 1: transfer in process
        uint32_t Tfnf                                              :1          ; //Bits :[1:1], initial value: 0x1. Transmit FIFO Not Full;  0: full, 1: not-full
        uint32_t Tfe                                               :1          ; //Bits :[2:2], initial value: 0x1. transmit FIFO Empty;  0: not-empty, 1:empty
        uint32_t Rfne                                              :1          ; //Bits :[3:3], initial value: 0x0. Receive FIFO Not Empty;  0: empty,  1: not-empty
        uint32_t Rff                                               :1          ; //Bits :[4:4], initial value: 0x0. Receive FIFO Full;  0: not-full, 1: full
     } fields_read;
    struct {
        uint32_t Busy                                              :1          ; //Bits :[0:0], initial value: 0x0. Module busy status; 0: idle, 1: transfer in process
        uint32_t Tfnf                                              :1          ; //Bits :[1:1], initial value: 0x1. Transmit FIFO Not Full;  0: full, 1: not-full
        uint32_t Tfe                                               :1          ; //Bits :[2:2], initial value: 0x1. transmit FIFO Empty;  0: not-empty, 1:empty
        uint32_t Rfne                                              :1          ; //Bits :[3:3], initial value: 0x0. Receive FIFO Not Empty;  0: empty,  1: not-empty
        uint32_t Rff                                               :1          ; //Bits :[4:4], initial value: 0x0. Receive FIFO Full;  0: not-full, 1: full
     } fields_rmw; //for non-shadowed register
} RegSeeStatusRegister, TRegSeeStatusRegister, *PTRegSeeStatusRegister;                                //0x10428

//Interrupt Mask register: for each bit,  0 masks an IRQ, 1 enables it
//initial value: 0x0
typedef union __RegSeeInterruptMask{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Txeim                                             :1          ; //Bits :[0:0], initial value: 0x0. Transmit FIFO Threshold IRQ enable
        uint32_t Txoim                                             :1          ; //Bits :[1:1], initial value: 0x0. Transmit FIFO Overflow enable
        uint32_t Rxuim                                             :1          ; //Bits :[2:2], initial value: 0x0. Receive FIFO Underflow enable
        uint32_t Rxoim                                             :1          ; //Bits :[3:3], initial value: 0x0. Receive FIFO Overflow enable
        uint32_t Rxfim                                             :1          ; //Bits :[4:4], initial value: 0x0. Receive FIFO Threshold IRQ enable
     } fields_read;
    struct {
        uint32_t Txeim                                             :1          ; //Bits :[0:0], initial value: 0x0. Transmit FIFO Threshold IRQ enable
        uint32_t Txoim                                             :1          ; //Bits :[1:1], initial value: 0x0. Transmit FIFO Overflow enable
        uint32_t Rxuim                                             :1          ; //Bits :[2:2], initial value: 0x0. Receive FIFO Underflow enable
        uint32_t Rxoim                                             :1          ; //Bits :[3:3], initial value: 0x0. Receive FIFO Overflow enable
        uint32_t Rxfim                                             :1          ; //Bits :[4:4], initial value: 0x0. Receive FIFO Threshold IRQ enable
     } fields_write;
    struct {
        uint32_t Txeim                                             :1          ; //Bits :[0:0], initial value: 0x0. Transmit FIFO Threshold IRQ enable
        uint32_t Txoim                                             :1          ; //Bits :[1:1], initial value: 0x0. Transmit FIFO Overflow enable
        uint32_t Rxuim                                             :1          ; //Bits :[2:2], initial value: 0x0. Receive FIFO Underflow enable
        uint32_t Rxoim                                             :1          ; //Bits :[3:3], initial value: 0x0. Receive FIFO Overflow enable
        uint32_t Rxfim                                             :1          ; //Bits :[4:4], initial value: 0x0. Receive FIFO Threshold IRQ enable
     } fields_rmw; //for non-shadowed register
} RegSeeInterruptMask, TRegSeeInterruptMask, *PTRegSeeInterruptMask;                                //0x1042C

//Interrupt Status: for each bit, 0: IRQ not active, 1: IRQ requesting
//initial value: 0x0
typedef union __RegSeeInterruptStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Txeis                                             :1          ; //Bits :[0:0], initial value: 0x0. Transmit FIFO Threshold IRQ status
        uint32_t Txois                                             :1          ; //Bits :[1:1], initial value: 0x0. Transmit FIFO Overflow status
        uint32_t Rxuis                                             :1          ; //Bits :[2:2], initial value: 0x0. Receive FIFO Underflow status
        uint32_t Rxois                                             :1          ; //Bits :[3:3], initial value: 0x0. Receive FIFO Overflow status
        uint32_t Rxfis                                             :1          ; //Bits :[4:4], initial value: 0x0. Receive FIFO Threshold IRQ status
     } fields_read;
    struct {
        uint32_t Txeis                                             :1          ; //Bits :[0:0], initial value: 0x0. Transmit FIFO Threshold IRQ status
        uint32_t Txois                                             :1          ; //Bits :[1:1], initial value: 0x0. Transmit FIFO Overflow status
        uint32_t Rxuis                                             :1          ; //Bits :[2:2], initial value: 0x0. Receive FIFO Underflow status
        uint32_t Rxois                                             :1          ; //Bits :[3:3], initial value: 0x0. Receive FIFO Overflow status
        uint32_t Rxfis                                             :1          ; //Bits :[4:4], initial value: 0x0. Receive FIFO Threshold IRQ status
     } fields_rmw; //for non-shadowed register
} RegSeeInterruptStatus, TRegSeeInterruptStatus, *PTRegSeeInterruptStatus;                                //0x10430

//Unmasked  Interrupt Status: for each bit, 0 means IRQ not active, 1 means IRQ requesting
//initial value: 0x1
typedef union __RegSeeRawInterruptStatus{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Txeir                                             :1          ; //Bits :[0:0], initial value: 0x1. Raw Transmit FIFO Threshold IRQ status
        uint32_t Txoir                                             :1          ; //Bits :[1:1], initial value: 0x0. Raw Transmit FIFO Overflow status
        uint32_t Rxuir                                             :1          ; //Bits :[2:2], initial value: 0x0. Raw Receive FIFO Underflow status
        uint32_t Rxoir                                             :1          ; //Bits :[3:3], initial value: 0x0. Raw Receive FIFO Overflow status
        uint32_t Rxfir                                             :1          ; //Bits :[4:4], initial value: 0x0. Raw Receive FIFO Threshold IRQ status
     } fields_read;
    struct {
        uint32_t Txeir                                             :1          ; //Bits :[0:0], initial value: 0x1. Raw Transmit FIFO Threshold IRQ status
        uint32_t Txoir                                             :1          ; //Bits :[1:1], initial value: 0x0. Raw Transmit FIFO Overflow status
        uint32_t Rxuir                                             :1          ; //Bits :[2:2], initial value: 0x0. Raw Receive FIFO Underflow status
        uint32_t Rxoir                                             :1          ; //Bits :[3:3], initial value: 0x0. Raw Receive FIFO Overflow status
        uint32_t Rxfir                                             :1          ; //Bits :[4:4], initial value: 0x0. Raw Receive FIFO Threshold IRQ status
     } fields_rmw; //for non-shadowed register
} RegSeeRawInterruptStatus, TRegSeeRawInterruptStatus, *PTRegSeeRawInterruptStatus;                                //0x10434

//Reads the current Transmit FIFO Overflow stats and clears the IRQ
//initial value: 0x0
typedef union __RegSeeClearTransmitFifoOverflow{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Txoicr                                            :1          ; //Bits :[0:0], initial value: 0x0. Transmit FIFO Overflow IRQ Clear when read
     } fields_read;
    struct {
        uint32_t Txoicr                                            :1          ; //Bits :[0:0], initial value: 0x0. Transmit FIFO Overflow IRQ Clear when read
     } fields_rmw; //for non-shadowed register
} RegSeeClearTransmitFifoOverflow, TRegSeeClearTransmitFifoOverflow, *PTRegSeeClearTransmitFifoOverflow;                                //0x10438

//Reads the current receive FIFO Overflow stats and clears the IRQ
//initial value: 0x0
typedef union __RegSeeClearReceiveFifoOverflow{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Rxoicr                                            :1          ; //Bits :[0:0], initial value: 0x0. Receive FIFO Overflow IRQ Clear when read
     } fields_read;
    struct {
        uint32_t Rxoicr                                            :1          ; //Bits :[0:0], initial value: 0x0. Receive FIFO Overflow IRQ Clear when read
     } fields_rmw; //for non-shadowed register
} RegSeeClearReceiveFifoOverflow, TRegSeeClearReceiveFifoOverflow, *PTRegSeeClearReceiveFifoOverflow;                                //0x1043C

//Reads the current receive FIFO Underflow stats and clears the IRQ
//initial value: 0x0
typedef union __RegSeeClearReceiveFifoUnderflow{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Rxuicr                                            :1          ; //Bits :[0:0], initial value: 0x0. Receive FIFO Underflow IRQ Clear when read
     } fields_read;
    struct {
        uint32_t Rxuicr                                            :1          ; //Bits :[0:0], initial value: 0x0. Receive FIFO Underflow IRQ Clear when read
     } fields_rmw; //for non-shadowed register
} RegSeeClearReceiveFifoUnderflow, TRegSeeClearReceiveFifoUnderflow, *PTRegSeeClearReceiveFifoUnderflow;                                //0x10440

//Read and Clear TX Overflow, RX Underflow, RX Overflow IRQs when read
//initial value: 0x0
typedef union __RegSeeIrqClear{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Icr                                               :1          ; //Bits :[0:0], initial value: 0x0. 1 if TXO, RXU, RXO IRQs are active, these will be cleared after the read operation
     } fields_read;
    struct {
        uint32_t Icr                                               :1          ; //Bits :[0:0], initial value: 0x0. 1 if TXO, RXU, RXO IRQs are active, these will be cleared after the read operation
     } fields_rmw; //for non-shadowed register
} RegSeeIrqClear, TRegSeeIrqClear, *PTRegSeeIrqClear;                                //0x10448

//SHA256 Control reg
//initial value: 0xDEADF00D
typedef union __RegSeeShaCmd{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DigestReset                                       :1          ; //Bits :[0:0], initial value: 0x1. Reset the digest values to standard default values (self-clearing)
        uint32_t SpiInputEndianSwap                                :1          ; //Bits :[1:1], initial value: 0x0. Enable endian dword swap of SPI Rx data
        uint32_t SpiHashEnable                                     :1          ; //Bits :[2:2], initial value: 0x1. Enable hashing of SPI Rx data
        uint32_t HashCtlReset                                      :1          ; //Bits :[3:3], initial value: 0x1. Reset hash state machine and input FIFO
        uint32_t SpiSkipLast                                       :1          ; //Bits :[4:4], initial value: 0x0. Skip hashing last byte(s) from SPI Rx
        uint32_t HashReadOrder                                     :1          ; //Bits :[5:5], initial value: 0x0. Select hash read order.  0: H..A,  1: A..H
        uint32_t Reserved1                                         :10         ; //Bits :[6:15], initial value: 0x3C0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ShaRountcount                                     :7          ; //Bits :[16:22], initial value: 0x2D. Reports the SHA state machine round count position.
        uint32_t ShaBusy                                           :1          ; //Bits :[23:23], initial value: 0x1. 0: SHA engine idle,  1: SHA engine processing data
        uint32_t Reserved2                                         :8          ; //Bits :[24:31], initial value: 0xDE. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t DigestReset                                       :1          ; //Bits :[0:0], initial value: 0x1. Reset the digest values to standard default values (self-clearing)
        uint32_t SpiInputEndianSwap                                :1          ; //Bits :[1:1], initial value: 0x0. Enable endian dword swap of SPI Rx data
        uint32_t SpiHashEnable                                     :1          ; //Bits :[2:2], initial value: 0x1. Enable hashing of SPI Rx data
        uint32_t HashCtlReset                                      :1          ; //Bits :[3:3], initial value: 0x1. Reset hash state machine and input FIFO
        uint32_t SpiSkipLast                                       :1          ; //Bits :[4:4], initial value: 0x0. Skip hashing last byte(s) from SPI Rx
        uint32_t HashReadOrder                                     :1          ; //Bits :[5:5], initial value: 0x0. Select hash read order.  0: H..A,  1: A..H
        uint32_t Reserved1                                         :10         ; //Bits :[6:15], initial value: 0x3C0. Reserved. Writes have no effect. Read always returns 0's:
        uint32_t ShaRountcount                                     :7          ; //Bits :[16:22], initial value: 0x2D. Reports the SHA state machine round count position.
        uint32_t ShaBusy                                           :1          ; //Bits :[23:23], initial value: 0x1. 0: SHA engine idle,  1: SHA engine processing data
        uint32_t Reserved2                                         :8          ; //Bits :[24:31], initial value: 0xDE. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegSeeShaCmd, TRegSeeShaCmd, *PTRegSeeShaCmd;                                //0x1044C

//SHA256 digest
//initial value: 0xDEADF00D
typedef union __RegSeeShaDigest{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Digest                                            :32         ; //Bits :[0:31], initial value: 0xDEADF00D. SHA256 Digest, big swapped
     } fields_read;
    struct {
        uint32_t Digest                                            :32         ; //Bits :[0:31], initial value: 0xDEADF00D. SHA256 Digest, big swapped
     } fields_rmw; //for non-shadowed register
} RegSeeShaDigest, TRegSeeShaDigest, *PTRegSeeShaDigest;                                //0x10450

//SHA256 digest, endian_swapped
//initial value: 0xDEADF00D
typedef union __RegSeeShaDigestSwapped{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DigestSwapped                                     :32         ; //Bits :[0:31], initial value: 0xDEADF00D. SHA256 Digest, little-swapped
     } fields_read;
    struct {
        uint32_t DigestSwapped                                     :32         ; //Bits :[0:31], initial value: 0xDEADF00D. SHA256 Digest, little-swapped
     } fields_rmw; //for non-shadowed register
} RegSeeShaDigestSwapped, TRegSeeShaDigestSwapped, *PTRegSeeShaDigestSwapped;                                //0x10454

//Module Identification Code
//initial value: 0x00001357
typedef union __RegSeeIdentificationCode{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Idcode                                            :32         ; //Bits :[0:31], initial value: 0x1357. Module identification;  fixed value of 0x0000_1357
     } fields_read;
    struct {
        uint32_t Idcode                                            :32         ; //Bits :[0:31], initial value: 0x1357. Module identification;  fixed value of 0x0000_1357
     } fields_rmw; //for non-shadowed register
} RegSeeIdentificationCode, TRegSeeIdentificationCode, *PTRegSeeIdentificationCode;                                //0x10458

//Module Version
//initial value: 0x00000002
typedef union __RegSeeVersion{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x2. Module version;  fixed value of 0x0000_0002
     } fields_read;
    struct {
        uint32_t Version                                           :32         ; //Bits :[0:31], initial value: 0x2. Module version;  fixed value of 0x0000_0002
     } fields_rmw; //for non-shadowed register
} RegSeeVersion, TRegSeeVersion, *PTRegSeeVersion;                                //0x1045C

//Tx and Rx FIFO access space; 36 dwords that push a dword in the TX FIFO on a write operation or pop a dword from
//the RX FIFO on a read operation
//initial value: 0x0
typedef union __RegSeeDataReg0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg0, TRegSeeDataReg0, *PTRegSeeDataReg0;                                //0x10460

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg1, TRegSeeDataReg1, *PTRegSeeDataReg1;                                //0x10464

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg2, TRegSeeDataReg2, *PTRegSeeDataReg2;                                //0x10468

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg3, TRegSeeDataReg3, *PTRegSeeDataReg3;                                //0x1046C

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg4{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg4, TRegSeeDataReg4, *PTRegSeeDataReg4;                                //0x10470

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg5{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg5, TRegSeeDataReg5, *PTRegSeeDataReg5;                                //0x10474

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg6{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg6, TRegSeeDataReg6, *PTRegSeeDataReg6;                                //0x10478

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg7{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg7, TRegSeeDataReg7, *PTRegSeeDataReg7;                                //0x1047C

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg8{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg8, TRegSeeDataReg8, *PTRegSeeDataReg8;                                //0x10480

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg9{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg9, TRegSeeDataReg9, *PTRegSeeDataReg9;                                //0x10484

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg10{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg10, TRegSeeDataReg10, *PTRegSeeDataReg10;                                //0x10488

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg11{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg11, TRegSeeDataReg11, *PTRegSeeDataReg11;                                //0x1048C

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg12{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg12, TRegSeeDataReg12, *PTRegSeeDataReg12;                                //0x10490

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg13{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg13, TRegSeeDataReg13, *PTRegSeeDataReg13;                                //0x10494

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg14{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg14, TRegSeeDataReg14, *PTRegSeeDataReg14;                                //0x10498

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg15{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg15, TRegSeeDataReg15, *PTRegSeeDataReg15;                                //0x1049C

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg16{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg16, TRegSeeDataReg16, *PTRegSeeDataReg16;                                //0x104A0

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg17{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg17, TRegSeeDataReg17, *PTRegSeeDataReg17;                                //0x104A4

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg18{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg18, TRegSeeDataReg18, *PTRegSeeDataReg18;                                //0x104A8

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg19{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg19, TRegSeeDataReg19, *PTRegSeeDataReg19;                                //0x104AC

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg20{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg20, TRegSeeDataReg20, *PTRegSeeDataReg20;                                //0x104B0

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg21{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg21, TRegSeeDataReg21, *PTRegSeeDataReg21;                                //0x104B4

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg22{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg22, TRegSeeDataReg22, *PTRegSeeDataReg22;                                //0x104B8

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg23{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg23, TRegSeeDataReg23, *PTRegSeeDataReg23;                                //0x104BC

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg24{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg24, TRegSeeDataReg24, *PTRegSeeDataReg24;                                //0x104C0

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg25{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg25, TRegSeeDataReg25, *PTRegSeeDataReg25;                                //0x104C4

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg26{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg26, TRegSeeDataReg26, *PTRegSeeDataReg26;                                //0x104C8

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg27{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg27, TRegSeeDataReg27, *PTRegSeeDataReg27;                                //0x104CC

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg28{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg28, TRegSeeDataReg28, *PTRegSeeDataReg28;                                //0x104D0

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg29{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg29, TRegSeeDataReg29, *PTRegSeeDataReg29;                                //0x104D4

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg30{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg30, TRegSeeDataReg30, *PTRegSeeDataReg30;                                //0x104D8

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg31{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg31, TRegSeeDataReg31, *PTRegSeeDataReg31;                                //0x104DC

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg32{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg32, TRegSeeDataReg32, *PTRegSeeDataReg32;                                //0x104E0

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg33{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg33, TRegSeeDataReg33, *PTRegSeeDataReg33;                                //0x104E4

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg34{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg34, TRegSeeDataReg34, *PTRegSeeDataReg34;                                //0x104E8

//Tx and Rx FIFO access space shadow
//initial value: 0x0
typedef union __RegSeeDataReg35{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_read;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_write;
    struct {
        uint32_t Dr                                                :32         ; //Bits :[0:31], initial value: 0x0. Data register: write operation pushes 32 bits into TX FIFO, read pops 32 bits from RX FIFO
     } fields_rmw; //for non-shadowed register
} RegSeeDataReg35, TRegSeeDataReg35, *PTRegSeeDataReg35;                                //0x104EC

//Tx and Rx FIFO size information
//initial value: 0x00200020
typedef union __RegSeeFifoInfo{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TxFifoSize                                        :16         ; //Bits :[0:15], initial value: 0x20. TX FIFO size
        uint32_t RxFifoSize                                        :16         ; //Bits :[16:31], initial value: 0x20. RX FIFO size
     } fields_read;
    struct {
        uint32_t TxFifoSize                                        :16         ; //Bits :[0:15], initial value: 0x20. TX FIFO size
        uint32_t RxFifoSize                                        :16         ; //Bits :[16:31], initial value: 0x20. RX FIFO size
     } fields_rmw; //for non-shadowed register
} RegSeeFifoInfo, TRegSeeFifoInfo, *PTRegSeeFifoInfo;                                //0x104F0

//##############################################################
//                    tproc_registers area
//##############################################################
//initial value: 0x0
typedef union __RegTprocRegstprocen{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocmasteren                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable for all Tproc logic except registers
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2en                                    :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3en                                    :1          ; //Bits :[8:8], initial value: 0x0. EP specific Enable
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep4en                                    :1          ; //Bits :[12:12], initial value: 0x0. EP specific Enable
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocdbgen                                    :1          ; //Bits :[16:16], initial value: 0x0. Enable for CW signals (debug only)
     } fields_read;
    struct {
        uint32_t Regstprocmasteren                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable for all Tproc logic except registers
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2en                                    :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3en                                    :1          ; //Bits :[8:8], initial value: 0x0. EP specific Enable
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep4en                                    :1          ; //Bits :[12:12], initial value: 0x0. EP specific Enable
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocdbgen                                    :1          ; //Bits :[16:16], initial value: 0x0. Enable for CW signals (debug only)
     } fields_write;
    struct {
        uint32_t Regstprocmasteren                                 :1          ; //Bits :[0:0], initial value: 0x0. Master enable for all Tproc logic except registers
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2en                                    :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3en                                    :1          ; //Bits :[8:8], initial value: 0x0. EP specific Enable
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep4en                                    :1          ; //Bits :[12:12], initial value: 0x0. EP specific Enable
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocdbgen                                    :1          ; //Bits :[16:16], initial value: 0x0. Enable for CW signals (debug only)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocen, TRegTprocRegstprocen, *PTRegTprocRegstprocen;                                //0x16400

//initial value: 0x10
typedef union __RegTprocRegstprocbypass{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocbypasstrb                                :1          ; //Bits :[0:0], initial value: 0x0. Bypass HW TRB buffers and control. Fallback feature
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocbypassevents                             :1          ; //Bits :[4:4], initial value: 0x1. Bypass HW events buffers and control. Fallback feature
     } fields_read;
    struct {
        uint32_t Regstprocbypasstrb                                :1          ; //Bits :[0:0], initial value: 0x0. Bypass HW TRB buffers and control. Fallback feature
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocbypassevents                             :1          ; //Bits :[4:4], initial value: 0x1. Bypass HW events buffers and control. Fallback feature
     } fields_write;
    struct {
        uint32_t Regstprocbypasstrb                                :1          ; //Bits :[0:0], initial value: 0x0. Bypass HW TRB buffers and control. Fallback feature
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocbypassevents                             :1          ; //Bits :[4:4], initial value: 0x1. Bypass HW events buffers and control. Fallback feature
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocbypass, TRegTprocRegstprocbypass, *PTRegTprocRegstprocbypass;                                //0x16404

//initial value: 0x0
typedef union __RegTprocRegstprocisomode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2isomode                               :1          ; //Bits :[0:0], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3isomode                               :1          ; //Bits :[4:4], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4isomode                               :1          ; //Bits :[8:8], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
     } fields_read;
    struct {
        uint32_t Regstprocep2isomode                               :1          ; //Bits :[0:0], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3isomode                               :1          ; //Bits :[4:4], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4isomode                               :1          ; //Bits :[8:8], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
     } fields_write;
    struct {
        uint32_t Regstprocep2isomode                               :1          ; //Bits :[0:0], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3isomode                               :1          ; //Bits :[4:4], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4isomode                               :1          ; //Bits :[8:8], initial value: 0x0. Set EP for ISO mode (0 = BULK mode)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocisomode, TRegTprocRegstprocisomode, *PTRegTprocRegstprocisomode;                                //0x16408

//initial value: 0x1000010
typedef union __RegTprocRegstprocep2framecfg{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep2nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep2tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRB
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep2flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_read;
    struct {
        uint32_t Regstprocep2flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep2nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep2tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRB
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep2flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_write;
    struct {
        uint32_t Regstprocep2flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep2nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep2tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRB
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep2flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2framecfg, TRegTprocRegstprocep2framecfg, *PTRegTprocRegstprocep2framecfg;                                //0x1640C

//initial value: 0x1000010
typedef union __RegTprocRegstprocep3framecfg{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep3nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep3tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRB
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep3flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_read;
    struct {
        uint32_t Regstprocep3flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep3nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep3tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRB
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep3flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_write;
    struct {
        uint32_t Regstprocep3flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep3nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep3tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRB
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep3flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3framecfg, TRegTprocRegstprocep3framecfg, *PTRegTprocRegstprocep3framecfg;                                //0x16410

//initial value: 0x1000010
typedef union __RegTprocRegstprocep4framecfg{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep4nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep4tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRBs
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep4flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_read;
    struct {
        uint32_t Regstprocep4flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep4nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep4tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRBs
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep4flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_write;
    struct {
        uint32_t Regstprocep4flushwheader                          :1          ; //Bits :[0:0], initial value: 0x0. Always send header on frame error, even if not sending frame
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4flushwzlp                             :1          ; //Bits :[4:4], initial value: 0x1. Always send ZLP on frame error, even if not needed.
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4hdrerrbiten                           :1          ; //Bits :[8:8], initial value: 0x0. Enable Error bit functionallity on UVC header
        uint32_t Reserved9                                         :3          ; //Bits :[9:11], initial value: 0x0 Reserved.
        uint32_t Regstprocep4nodatafrm                             :1          ; //Bits :[12:12], initial value: 0x0. Set this field if sending a frame with none-stream only data
        uint32_t Reserved13                                        :3          ; //Bits :[13:15], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forcezlp                              :1          ; //Bits :[16:16], initial value: 0x0. Send ZLP at the end of every frame, even if not needed
        uint32_t Reserved17                                        :3          ; //Bits :[17:19], initial value: 0x0 Reserved.
        uint32_t Regstprocep4tailmetaen                            :1          ; //Bits :[20:20], initial value: 0x0. Enable tail metadata TRBs
        uint32_t Reserved21                                        :3          ; //Bits :[21:23], initial value: 0x0 Reserved.
        uint32_t Regstprocep4flushonovf                            :1          ; //Bits :[24:24], initial value: 0x1. Flush remaining frame data on overflow (don't send it to host)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4framecfg, TRegTprocRegstprocep4framecfg, *PTRegTprocRegstprocep4framecfg;                                //0x16414

//initial value: 0x1000
typedef union __RegTprocRegstprocep2gran{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_read;
    struct {
        uint32_t Regstprocep2gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_write;
    struct {
        uint32_t Regstprocep2gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2gran, TRegTprocRegstprocep2gran, *PTRegTprocRegstprocep2gran;                                //0x16418

//initial value: 0x1000
typedef union __RegTprocRegstprocep3gran{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_read;
    struct {
        uint32_t Regstprocep3gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_write;
    struct {
        uint32_t Regstprocep3gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3gran, TRegTprocRegstprocep3gran, *PTRegTprocRegstprocep3gran;                                //0x1641C

//initial value: 0x1000
typedef union __RegTprocRegstprocep4gran{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_read;
    struct {
        uint32_t Regstprocep4gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_write;
    struct {
        uint32_t Regstprocep4gran                                  :20         ; //Bits :[0:19], initial value: 0x1000. Frame data TRB SIZ field (Granularity)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4gran, TRegTprocRegstprocep4gran, *PTRegTprocRegstprocep4gran;                                //0x16420

//initial value: 0x1
typedef union __RegTprocRegstprocep2trbthrsld{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_read;
    struct {
        uint32_t Regstprocep2trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_write;
    struct {
        uint32_t Regstprocep2trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2trbthrsld, TRegTprocRegstprocep2trbthrsld, *PTRegTprocRegstprocep2trbthrsld;                                //0x16424

//initial value: 0x1
typedef union __RegTprocRegstprocep3trbthrsld{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_read;
    struct {
        uint32_t Regstprocep3trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_write;
    struct {
        uint32_t Regstprocep3trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3trbthrsld, TRegTprocRegstprocep3trbthrsld, *PTRegTprocRegstprocep3trbthrsld;                                //0x16428

//initial value: 0x1
typedef union __RegTprocRegstprocep4trbthrsld{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_read;
    struct {
        uint32_t Regstprocep4trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_write;
    struct {
        uint32_t Regstprocep4trbthrsld                             :4          ; //Bits :[0:3], initial value: 0x1. TRB FIFO threshold to start draining (value = 16 - number of TRB in FIFO)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4trbthrsld, TRegTprocRegstprocep4trbthrsld, *PTRegTprocRegstprocep4trbthrsld;                                //0x1642C

//initial value: 0x0
typedef union __RegTprocRegstprocep2eventclr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_read;
    struct {
        uint32_t Regstprocep2eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_write;
    struct {
        uint32_t Regstprocep2eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2eventclr, TRegTprocRegstprocep2eventclr, *PTRegTprocRegstprocep2eventclr;                                //0x16430

//initial value: 0x0
typedef union __RegTprocRegstprocep3eventclr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_read;
    struct {
        uint32_t Regstprocep3eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_write;
    struct {
        uint32_t Regstprocep3eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3eventclr, TRegTprocRegstprocep3eventclr, *PTRegTprocRegstprocep3eventclr;                                //0x16434

//initial value: 0x0
typedef union __RegTprocRegstprocep4eventclr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_read;
    struct {
        uint32_t Regstprocep4eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_write;
    struct {
        uint32_t Regstprocep4eventclr                              :1          ; //Bits :[0:0], initial value: 0x0. FW event clear signal (should be written after write to EVNTCNT)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4eventclr, TRegTprocRegstprocep4eventclr, *PTRegTprocRegstprocep4eventclr;                                //0x16438

//initial value: 0x0
typedef union __RegTprocRegstprocep2active{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_read;
    struct {
        uint32_t Regstprocep2wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_write;
    struct {
        uint32_t Regstprocep2wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2active, TRegTprocRegstprocep2active, *PTRegTprocRegstprocep2active;                                //0x1643C

//initial value: 0x0
typedef union __RegTprocRegstprocep3active{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_read;
    struct {
        uint32_t Regstprocep3wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_write;
    struct {
        uint32_t Regstprocep3wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3active, TRegTprocRegstprocep3active, *PTRegTprocRegstprocep3active;                                //0x16440

//initial value: 0x0
typedef union __RegTprocRegstprocep4active{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_read;
    struct {
        uint32_t Regstprocep4wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_write;
    struct {
        uint32_t Regstprocep4wractive                              :1          ; //Bits :[0:0], initial value: 0x0. EP specific Enable for write FSMs and counters
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4rdactive                              :1          ; //Bits :[4:4], initial value: 0x0. EP specific Enable for read FSMs and counters
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4GracefulStop                          :1          ; //Bits :[8:8], initial value: 0x0. 1: masks new frames to VDF on Stop
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4active, TRegTprocRegstprocep4active, *PTRegTprocRegstprocep4active;                                //0x16444

//initial value: 0x200000
typedef union __RegTprocRegstprocep2minaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2minaddr                               :32         ; //Bits :[0:31], initial value: 0x200000. Native bus minimum address for EP2 buffer
     } fields_read;
    struct {
        uint32_t Regstprocep2minaddr                               :32         ; //Bits :[0:31], initial value: 0x200000. Native bus minimum address for EP2 buffer
     } fields_write;
    struct {
        uint32_t Regstprocep2minaddr                               :32         ; //Bits :[0:31], initial value: 0x200000. Native bus minimum address for EP2 buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2minaddr, TRegTprocRegstprocep2minaddr, *PTRegTprocRegstprocep2minaddr;                                //0x16448

//initial value: 0x20FFFF
typedef union __RegTprocRegstprocep2maxaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2maxaddr                               :32         ; //Bits :[0:31], initial value: 0x20FFFF. Native bus maximum address for EP2 buffer
     } fields_read;
    struct {
        uint32_t Regstprocep2maxaddr                               :32         ; //Bits :[0:31], initial value: 0x20FFFF. Native bus maximum address for EP2 buffer
     } fields_write;
    struct {
        uint32_t Regstprocep2maxaddr                               :32         ; //Bits :[0:31], initial value: 0x20FFFF. Native bus maximum address for EP2 buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2maxaddr, TRegTprocRegstprocep2maxaddr, *PTRegTprocRegstprocep2maxaddr;                                //0x1644C

//initial value: 0x220000
typedef union __RegTprocRegstprocep3minaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3minaddr                               :32         ; //Bits :[0:31], initial value: 0x220000. Native bus minimum address for EP3 buffer
     } fields_read;
    struct {
        uint32_t Regstprocep3minaddr                               :32         ; //Bits :[0:31], initial value: 0x220000. Native bus minimum address for EP3 buffer
     } fields_write;
    struct {
        uint32_t Regstprocep3minaddr                               :32         ; //Bits :[0:31], initial value: 0x220000. Native bus minimum address for EP3 buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3minaddr, TRegTprocRegstprocep3minaddr, *PTRegTprocRegstprocep3minaddr;                                //0x16450

//initial value: 0x22FFFF
typedef union __RegTprocRegstprocep3maxaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3maxaddr                               :32         ; //Bits :[0:31], initial value: 0x22FFFF. Native bus maximum address for EP3 buffer
     } fields_read;
    struct {
        uint32_t Regstprocep3maxaddr                               :32         ; //Bits :[0:31], initial value: 0x22FFFF. Native bus maximum address for EP3 buffer
     } fields_write;
    struct {
        uint32_t Regstprocep3maxaddr                               :32         ; //Bits :[0:31], initial value: 0x22FFFF. Native bus maximum address for EP3 buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3maxaddr, TRegTprocRegstprocep3maxaddr, *PTRegTprocRegstprocep3maxaddr;                                //0x16454

//initial value: 0x240000
typedef union __RegTprocRegstprocep4minaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4minaddr                               :32         ; //Bits :[0:31], initial value: 0x240000. Native bus minimum address for EP4 buffer
     } fields_read;
    struct {
        uint32_t Regstprocep4minaddr                               :32         ; //Bits :[0:31], initial value: 0x240000. Native bus minimum address for EP4 buffer
     } fields_write;
    struct {
        uint32_t Regstprocep4minaddr                               :32         ; //Bits :[0:31], initial value: 0x240000. Native bus minimum address for EP4 buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4minaddr, TRegTprocRegstprocep4minaddr, *PTRegTprocRegstprocep4minaddr;                                //0x16458

//initial value: 0x24FFFF
typedef union __RegTprocRegstprocep4maxaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4maxaddr                               :32         ; //Bits :[0:31], initial value: 0x24FFFF. Native bus maximum address for EP4 buffer
     } fields_read;
    struct {
        uint32_t Regstprocep4maxaddr                               :32         ; //Bits :[0:31], initial value: 0x24FFFF. Native bus maximum address for EP4 buffer
     } fields_write;
    struct {
        uint32_t Regstprocep4maxaddr                               :32         ; //Bits :[0:31], initial value: 0x24FFFF. Native bus maximum address for EP4 buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4maxaddr, TRegTprocRegstprocep4maxaddr, *PTRegTprocRegstprocep4maxaddr;                                //0x1645C

//initial value: 0xC
typedef union __RegTprocRegstprocep2hdrsize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_read;
    struct {
        uint32_t Regstprocep2hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_write;
    struct {
        uint32_t Regstprocep2hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2hdrsize, TRegTprocRegstprocep2hdrsize, *PTRegTprocRegstprocep2hdrsize;                                //0x16460

//initial value: 0xC
typedef union __RegTprocRegstprocep3hdrsize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_read;
    struct {
        uint32_t Regstprocep3hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_write;
    struct {
        uint32_t Regstprocep3hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3hdrsize, TRegTprocRegstprocep3hdrsize, *PTRegTprocRegstprocep3hdrsize;                                //0x16464

//initial value: 0xC
typedef union __RegTprocRegstprocep4hdrsize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_read;
    struct {
        uint32_t Regstprocep4hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_write;
    struct {
        uint32_t Regstprocep4hdrsize                               :12         ; //Bits :[0:11], initial value: 0xC. Header size in bytes (including UVC, Embedded and NSE)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4hdrsize, TRegTprocRegstprocep4hdrsize, *PTRegTprocRegstprocep4hdrsize;                                //0x1646C

//initial value: 0x0
typedef union __RegTprocRegstprocendxferen{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocendxferen                                :1          ; //Bits :[0:0], initial value: 0x0. Send EndXfer command on frame error
     } fields_read;
    struct {
        uint32_t Regstprocendxferen                                :1          ; //Bits :[0:0], initial value: 0x0. Send EndXfer command on frame error
     } fields_write;
    struct {
        uint32_t Regstprocendxferen                                :1          ; //Bits :[0:0], initial value: 0x0. Send EndXfer command on frame error
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocendxferen, TRegTprocRegstprocendxferen, *PTRegTprocRegstprocendxferen;                                //0x16470

//initial value: 0x0
typedef union __RegTprocRegstprocep2fwhalt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_read;
    struct {
        uint32_t Regstprocep2fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_write;
    struct {
        uint32_t Regstprocep2fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2fwhalt, TRegTprocRegstprocep2fwhalt, *PTRegTprocRegstprocep2fwhalt;                                //0x16474

//initial value: 0x0
typedef union __RegTprocRegstprocep3fwhalt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_read;
    struct {
        uint32_t Regstprocep3fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_write;
    struct {
        uint32_t Regstprocep3fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3fwhalt, TRegTprocRegstprocep3fwhalt, *PTRegTprocRegstprocep3fwhalt;                                //0x16478

//initial value: 0x0
typedef union __RegTprocRegstprocep4fwhalt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_read;
    struct {
        uint32_t Regstprocep4fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_write;
    struct {
        uint32_t Regstprocep4fwhalt                                :1          ; //Bits :[0:0], initial value: 0x0. Stop Tproc from sending new frames (to use while manually updating NSE data and not using shadow update)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4fwhalt, TRegTprocRegstprocep4fwhalt, *PTRegTprocRegstprocep4fwhalt;                                //0x1647C

//initial value: 0x0
typedef union __RegTprocRegstprocep2flushfrmid{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_read;
    struct {
        uint32_t Regstprocep2flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_write;
    struct {
        uint32_t Regstprocep2flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2flushfrmid, TRegTprocRegstprocep2flushfrmid, *PTRegTprocRegstprocep2flushfrmid;                                //0x16480

//initial value: 0x0
typedef union __RegTprocRegstprocep3flushfrmid{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_read;
    struct {
        uint32_t Regstprocep3flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_write;
    struct {
        uint32_t Regstprocep3flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3flushfrmid, TRegTprocRegstprocep3flushfrmid, *PTRegTprocRegstprocep3flushfrmid;                                //0x16484

//initial value: 0x0
typedef union __RegTprocRegstprocep4flushfrmid{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_read;
    struct {
        uint32_t Regstprocep4flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_write;
    struct {
        uint32_t Regstprocep4flushfrmid                            :4          ; //Bits :[0:3], initial value: 0x0. set frame ID to be flushed by Tproc
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4flushfrmid, TRegTprocRegstprocep4flushfrmid, *PTRegTprocRegstprocep4flushfrmid;                                //0x16488

//initial value: 0x406
typedef union __RegTprocRegstprocstartxfercmd{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocstartxfercmd                             :32         ; //Bits :[0:31], initial value: 0x406. Synopsys core StartXfer command code
     } fields_read;
    struct {
        uint32_t Regstprocstartxfercmd                             :32         ; //Bits :[0:31], initial value: 0x406. Synopsys core StartXfer command code
     } fields_write;
    struct {
        uint32_t Regstprocstartxfercmd                             :32         ; //Bits :[0:31], initial value: 0x406. Synopsys core StartXfer command code
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocstartxfercmd, TRegTprocRegstprocstartxfercmd, *PTRegTprocRegstprocstartxfercmd;                                //0x1648C

//initial value: 0x407
typedef union __RegTprocRegstprocupdxfercmd{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocupdxfercmd                               :32         ; //Bits :[0:31], initial value: 0x407. Synopsys core UpdateXfer command code
     } fields_read;
    struct {
        uint32_t Regstprocupdxfercmd                               :32         ; //Bits :[0:31], initial value: 0x407. Synopsys core UpdateXfer command code
     } fields_write;
    struct {
        uint32_t Regstprocupdxfercmd                               :32         ; //Bits :[0:31], initial value: 0x407. Synopsys core UpdateXfer command code
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocupdxfercmd, TRegTprocRegstprocupdxfercmd, *PTRegTprocRegstprocupdxfercmd;                                //0x16490

//initial value: 0x408
typedef union __RegTprocRegstprocendxfercmd{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocendxfercmd                               :32         ; //Bits :[0:31], initial value: 0x408. Synopsys core EndXfer command code
     } fields_read;
    struct {
        uint32_t Regstprocendxfercmd                               :32         ; //Bits :[0:31], initial value: 0x408. Synopsys core EndXfer command code
     } fields_write;
    struct {
        uint32_t Regstprocendxfercmd                               :32         ; //Bits :[0:31], initial value: 0x408. Synopsys core EndXfer command code
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocendxfercmd, TRegTprocRegstprocendxfercmd, *PTRegTprocRegstprocendxfercmd;                                //0x16494

//initial value: 0x0
typedef union __RegTprocRegstproceppriority{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstproceppriority                               :3          ; //Bits :[0:2], initial value: 0x0. set priority for a specific EP. Events and commands for that EP will be performed first
     } fields_read;
    struct {
        uint32_t Regstproceppriority                               :3          ; //Bits :[0:2], initial value: 0x0. set priority for a specific EP. Events and commands for that EP will be performed first
     } fields_write;
    struct {
        uint32_t Regstproceppriority                               :3          ; //Bits :[0:2], initial value: 0x0. set priority for a specific EP. Events and commands for that EP will be performed first
     } fields_rmw; //for non-shadowed register
} RegTprocRegstproceppriority, TRegTprocRegstproceppriority, *PTRegTprocRegstproceppriority;                                //0x16498

//initial value: 0x0
typedef union __RegTprocRegstproccmdqflush{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2cmdqflush                             :1          ; //Bits :[0:0], initial value: 0x0. Flush Command queue
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3cmdqflush                             :1          ; //Bits :[4:4], initial value: 0x0. Flush Command queue
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4cmdqflush                             :1          ; //Bits :[8:8], initial value: 0x0. Flush Command queue
     } fields_read;
    struct {
        uint32_t Regstprocep2cmdqflush                             :1          ; //Bits :[0:0], initial value: 0x0. Flush Command queue
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3cmdqflush                             :1          ; //Bits :[4:4], initial value: 0x0. Flush Command queue
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4cmdqflush                             :1          ; //Bits :[8:8], initial value: 0x0. Flush Command queue
     } fields_write;
    struct {
        uint32_t Regstprocep2cmdqflush                             :1          ; //Bits :[0:0], initial value: 0x0. Flush Command queue
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3cmdqflush                             :1          ; //Bits :[4:4], initial value: 0x0. Flush Command queue
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4cmdqflush                             :1          ; //Bits :[8:8], initial value: 0x0. Flush Command queue
     } fields_rmw; //for non-shadowed register
} RegTprocRegstproccmdqflush, TRegTprocRegstproccmdqflush, *PTRegTprocRegstproccmdqflush;                                //0x1649C

//initial value: 0x0
typedef union __RegTprocRegstprocep2tailmetaaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_read;
    struct {
        uint32_t Regstprocep2tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_write;
    struct {
        uint32_t Regstprocep2tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2tailmetaaddr, TRegTprocRegstprocep2tailmetaaddr, *PTRegTprocRegstprocep2tailmetaaddr;                                //0x164A0

//initial value: 0x0
typedef union __RegTprocRegstprocep3tailmetaaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_read;
    struct {
        uint32_t Regstprocep3tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_write;
    struct {
        uint32_t Regstprocep3tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3tailmetaaddr, TRegTprocRegstprocep3tailmetaaddr, *PTRegTprocRegstprocep3tailmetaaddr;                                //0x164A4

//initial value: 0x0
typedef union __RegTprocRegstprocep4tailmetaaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_read;
    struct {
        uint32_t Regstprocep4tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_write;
    struct {
        uint32_t Regstprocep4tailmetaaddr                          :32         ; //Bits :[0:31], initial value: 0x0. Tail metadata TD start address
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4tailmetaaddr, TRegTprocRegstprocep4tailmetaaddr, *PTRegTprocRegstprocep4tailmetaaddr;                                //0x164A8

//initial value: 0x274000
typedef union __RegTprocRegstprocep2tdstartaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274000. TD start address
     } fields_read;
    struct {
        uint32_t Regstprocep2tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274000. TD start address
     } fields_write;
    struct {
        uint32_t Regstprocep2tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274000. TD start address
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2tdstartaddr, TRegTprocRegstprocep2tdstartaddr, *PTRegTprocRegstprocep2tdstartaddr;                                //0x164AC

//initial value: 0x274100
typedef union __RegTprocRegstprocep3tdstartaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274100. TD start address
     } fields_read;
    struct {
        uint32_t Regstprocep3tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274100. TD start address
     } fields_write;
    struct {
        uint32_t Regstprocep3tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274100. TD start address
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3tdstartaddr, TRegTprocRegstprocep3tdstartaddr, *PTRegTprocRegstprocep3tdstartaddr;                                //0x164B0

//initial value: 0x274200
typedef union __RegTprocRegstprocep4tdstartaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274200. TD start address
     } fields_read;
    struct {
        uint32_t Regstprocep4tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274200. TD start address
     } fields_write;
    struct {
        uint32_t Regstprocep4tdstartaddr                           :32         ; //Bits :[0:31], initial value: 0x274200. TD start address
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4tdstartaddr, TRegTprocRegstprocep4tdstartaddr, *PTRegTprocRegstprocep4tdstartaddr;                                //0x164B4

//initial value: 0x0
typedef union __RegTprocRegstprocep2frmid{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2wrfrmid                               :4          ; //Bits :[0:3], initial value: 0x0. Frame ID for frame being written to VDF buffer
        uint32_t Regstprocep2rdfrmid                               :4          ; //Bits :[4:7], initial value: 0x0. Frame ID for frame being read from VDF buffer
     } fields_read;
    struct {
        uint32_t Regstprocep2wrfrmid                               :4          ; //Bits :[0:3], initial value: 0x0. Frame ID for frame being written to VDF buffer
        uint32_t Regstprocep2rdfrmid                               :4          ; //Bits :[4:7], initial value: 0x0. Frame ID for frame being read from VDF buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2frmid, TRegTprocRegstprocep2frmid, *PTRegTprocRegstprocep2frmid;                                //0x164B8

//initial value: 0x0
typedef union __RegTprocRegstprocep3frmid{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3wrfrmid                               :4          ; //Bits :[0:3], initial value: 0x0. Frame ID for frame being written to VDF buffer
        uint32_t Regstprocep3rdfrmid                               :4          ; //Bits :[4:7], initial value: 0x0. Frame ID for frame being read from VDF buffer
     } fields_read;
    struct {
        uint32_t Regstprocep3wrfrmid                               :4          ; //Bits :[0:3], initial value: 0x0. Frame ID for frame being written to VDF buffer
        uint32_t Regstprocep3rdfrmid                               :4          ; //Bits :[4:7], initial value: 0x0. Frame ID for frame being read from VDF buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3frmid, TRegTprocRegstprocep3frmid, *PTRegTprocRegstprocep3frmid;                                //0x164BC

//initial value: 0x0
typedef union __RegTprocRegstprocep4frmid{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4wrfrmid                               :4          ; //Bits :[0:3], initial value: 0x0. Frame ID for frame being written to VDF buffer
        uint32_t Regstprocep4rdfrmid                               :4          ; //Bits :[4:7], initial value: 0x0. Frame ID for frame being read from VDF buffer
     } fields_read;
    struct {
        uint32_t Regstprocep4wrfrmid                               :4          ; //Bits :[0:3], initial value: 0x0. Frame ID for frame being written to VDF buffer
        uint32_t Regstprocep4rdfrmid                               :4          ; //Bits :[4:7], initial value: 0x0. Frame ID for frame being read from VDF buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4frmid, TRegTprocRegstprocep4frmid, *PTRegTprocRegstprocep4frmid;                                //0x164C0

//initial value: 0x0
typedef union __RegTprocRegstprocep2shadowupd{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_read;
    struct {
        uint32_t Regstprocep2shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_write;
    struct {
        uint32_t Regstprocep2shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2shadowupd, TRegTprocRegstprocep2shadowupd, *PTRegTprocRegstprocep2shadowupd;                                //0x164C4

//initial value: 0x0
typedef union __RegTprocRegstprocep3shadowupd{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_read;
    struct {
        uint32_t Regstprocep3shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_write;
    struct {
        uint32_t Regstprocep3shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3shadowupd, TRegTprocRegstprocep3shadowupd, *PTRegTprocRegstprocep3shadowupd;                                //0x164C8

//initial value: 0x0
typedef union __RegTprocRegstprocep4shadowupd{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_read;
    struct {
        uint32_t Regstprocep4shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_write;
    struct {
        uint32_t Regstprocep4shadowupd                             :1          ; //Bits :[0:0], initial value: 0x0. Shadow update pulse
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4shadowupd, TRegTprocRegstprocep4shadowupd, *PTRegTprocRegstprocep4shadowupd;                                //0x164CC

//initial value: 0x0
typedef union __RegTprocRegstprocupdcfg{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocupdonboth                                :1          ; //Bits :[0:0], initial value: 0x0. Shadow update for EP2+3 when both EP2+3 are between frames
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocupdonep2                                 :1          ; //Bits :[4:4], initial value: 0x0. Shadow update for EP2+3 when EP2 is between frames
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocupdonep3                                 :1          ; //Bits :[8:8], initial value: 0x0. Shadow update for EP2+3 when EP3 is between frames
     } fields_read;
    struct {
        uint32_t Regstprocupdonboth                                :1          ; //Bits :[0:0], initial value: 0x0. Shadow update for EP2+3 when both EP2+3 are between frames
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocupdonep2                                 :1          ; //Bits :[4:4], initial value: 0x0. Shadow update for EP2+3 when EP2 is between frames
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocupdonep3                                 :1          ; //Bits :[8:8], initial value: 0x0. Shadow update for EP2+3 when EP3 is between frames
     } fields_write;
    struct {
        uint32_t Regstprocupdonboth                                :1          ; //Bits :[0:0], initial value: 0x0. Shadow update for EP2+3 when both EP2+3 are between frames
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocupdonep2                                 :1          ; //Bits :[4:4], initial value: 0x0. Shadow update for EP2+3 when EP2 is between frames
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocupdonep3                                 :1          ; //Bits :[8:8], initial value: 0x0. Shadow update for EP2+3 when EP3 is between frames
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocupdcfg, TRegTprocRegstprocupdcfg, *PTRegTprocRegstprocupdcfg;                                //0x164D0

//initial value: 0x0
typedef union __RegTprocRegstprocep2bufminaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_read;
    struct {
        uint32_t Regstprocep2bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_write;
    struct {
        uint32_t Regstprocep2bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2bufminaddr, TRegTprocRegstprocep2bufminaddr, *PTRegTprocRegstprocep2bufminaddr;                                //0x164D4

//initial value: 0x3FFF
typedef union __RegTprocRegstprocep2bufmaxaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_read;
    struct {
        uint32_t Regstprocep2bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_write;
    struct {
        uint32_t Regstprocep2bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2bufmaxaddr, TRegTprocRegstprocep2bufmaxaddr, *PTRegTprocRegstprocep2bufmaxaddr;                                //0x164D8

//initial value: 0x0
typedef union __RegTprocRegstprocep3bufminaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_read;
    struct {
        uint32_t Regstprocep3bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_write;
    struct {
        uint32_t Regstprocep3bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3bufminaddr, TRegTprocRegstprocep3bufminaddr, *PTRegTprocRegstprocep3bufminaddr;                                //0x164DC

//initial value: 0x3FFF
typedef union __RegTprocRegstprocep3bufmaxaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_read;
    struct {
        uint32_t Regstprocep3bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_write;
    struct {
        uint32_t Regstprocep3bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3bufmaxaddr, TRegTprocRegstprocep3bufmaxaddr, *PTRegTprocRegstprocep3bufmaxaddr;                                //0x164E0

//initial value: 0x0
typedef union __RegTprocRegstprocep4bufminaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_read;
    struct {
        uint32_t Regstprocep4bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_write;
    struct {
        uint32_t Regstprocep4bufminaddr                            :32         ; //Bits :[0:31], initial value: 0x0. Internal Minimum address for VDF buffer (should be always zero)
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4bufminaddr, TRegTprocRegstprocep4bufminaddr, *PTRegTprocRegstprocep4bufminaddr;                                //0x164E4

//initial value: 0x3FFF
typedef union __RegTprocRegstprocep4bufmaxaddr{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_read;
    struct {
        uint32_t Regstprocep4bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_write;
    struct {
        uint32_t Regstprocep4bufmaxaddr                            :32         ; //Bits :[0:31], initial value: 0x3FFF. Internal Maximum address for VDF buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4bufmaxaddr, TRegTprocRegstprocep4bufmaxaddr, *PTRegTprocRegstprocep4bufmaxaddr;                                //0x164E8

//initial value: 0x0
typedef union __RegTprocRegstprocep2force{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_read;
    struct {
        uint32_t Regstprocep2forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_write;
    struct {
        uint32_t Regstprocep2forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep2forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2force, TRegTprocRegstprocep2force, *PTRegTprocRegstprocep2force;                                //0x164EC

//initial value: 0x0
typedef union __RegTprocRegstprocep3force{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_read;
    struct {
        uint32_t Regstprocep3forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_write;
    struct {
        uint32_t Regstprocep3forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep3forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3force, TRegTprocRegstprocep3force, *PTRegTprocRegstprocep3force;                                //0x164F0

//initial value: 0x0
typedef union __RegTprocRegstprocep4force{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_read;
    struct {
        uint32_t Regstprocep4forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_write;
    struct {
        uint32_t Regstprocep4forceerr                              :1          ; //Bits :[0:0], initial value: 0x0. Force frame error to the current frame being written to VDF buffer
        uint32_t Reserved1                                         :3          ; //Bits :[1:3], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forcesof                              :1          ; //Bits :[4:4], initial value: 0x0. Force SOF signal at Tproc input
        uint32_t Reserved5                                         :3          ; //Bits :[5:7], initial value: 0x0 Reserved.
        uint32_t Regstprocep4forceeof                              :1          ; //Bits :[8:8], initial value: 0x0. Force EOF signal at Tproc input
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4force, TRegTprocRegstprocep4force, *PTRegTprocRegstprocep4force;                                //0x164F4

//initial value: 0x0
typedef union __RegTprocRegstproceventpntr{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2eventpntr                             :4          ; //Bits :[0:3], initial value: 0x0. Pointer to oldest un-treated event in buffer
        uint32_t Regstprocep3eventpntr                             :4          ; //Bits :[4:7], initial value: 0x0. Pointer to oldest un-treated event in buffer
        uint32_t Regstprocep4eventpntr                             :4          ; //Bits :[8:11], initial value: 0x0. Pointer to oldest un-treated event in buffer
     } fields_read;
    struct {
        uint32_t Regstprocep2eventpntr                             :4          ; //Bits :[0:3], initial value: 0x0. Pointer to oldest un-treated event in buffer
        uint32_t Regstprocep3eventpntr                             :4          ; //Bits :[4:7], initial value: 0x0. Pointer to oldest un-treated event in buffer
        uint32_t Regstprocep4eventpntr                             :4          ; //Bits :[8:11], initial value: 0x0. Pointer to oldest un-treated event in buffer
     } fields_rmw; //for non-shadowed register
} RegTprocRegstproceventpntr, TRegTprocRegstproceventpntr, *PTRegTprocRegstproceventpntr;                                //0x164F8

//initial value: 0x260000
typedef union __RegTprocRegstprocep2hdrtrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260000. Header TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep2hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260000. Header TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep2hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260000. Header TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2hdrtrb0, TRegTprocRegstprocep2hdrtrb0, *PTRegTprocRegstprocep2hdrtrb0;                                //0x16800

//initial value: 0x0
typedef union __RegTprocRegstprocep2hdrtrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep2hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep2hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2hdrtrb1, TRegTprocRegstprocep2hdrtrb1, *PTRegTprocRegstprocep2hdrtrb1;                                //0x16804

//initial value: 0x4
typedef union __RegTprocRegstprocep2hdrtrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep2hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep2hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2hdrtrb2, TRegTprocRegstprocep2hdrtrb2, *PTRegTprocRegstprocep2hdrtrb2;                                //0x16808

//initial value: 0x15
typedef union __RegTprocRegstprocep2hdrtrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep2hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep2hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2hdrtrb3, TRegTprocRegstprocep2hdrtrb3, *PTRegTprocRegstprocep2hdrtrb3;                                //0x1680C

//initial value: 0x260004
typedef union __RegTprocRegstprocep2metatrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260004. Metadata TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep2metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260004. Metadata TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep2metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260004. Metadata TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2metatrb0, TRegTprocRegstprocep2metatrb0, *PTRegTprocRegstprocep2metatrb0;                                //0x16810

//initial value: 0x0
typedef union __RegTprocRegstprocep2metatrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep2metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep2metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2metatrb1, TRegTprocRegstprocep2metatrb1, *PTRegTprocRegstprocep2metatrb1;                                //0x16814

//initial value: 0x4
typedef union __RegTprocRegstprocep2metatrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep2metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep2metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2metatrb2, TRegTprocRegstprocep2metatrb2, *PTRegTprocRegstprocep2metatrb2;                                //0x16818

//initial value: 0x15
typedef union __RegTprocRegstprocep2metatrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep2metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep2metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2metatrb3, TRegTprocRegstprocep2metatrb3, *PTRegTprocRegstprocep2metatrb3;                                //0x1681C

//initial value: 0x260008
typedef union __RegTprocRegstprocep2nsetrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260008. NSE TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep2nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260008. NSE TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep2nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260008. NSE TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2nsetrb0, TRegTprocRegstprocep2nsetrb0, *PTRegTprocRegstprocep2nsetrb0;                                //0x16820

//initial value: 0x0
typedef union __RegTprocRegstprocep2nsetrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep2nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep2nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2nsetrb1, TRegTprocRegstprocep2nsetrb1, *PTRegTprocRegstprocep2nsetrb1;                                //0x16824

//initial value: 0x4
typedef union __RegTprocRegstprocep2nsetrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep2nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep2nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2nsetrb2, TRegTprocRegstprocep2nsetrb2, *PTRegTprocRegstprocep2nsetrb2;                                //0x16828

//initial value: 0x15
typedef union __RegTprocRegstprocep2nsetrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep2nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep2nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2nsetrb3, TRegTprocRegstprocep2nsetrb3, *PTRegTprocRegstprocep2nsetrb3;                                //0x1682C

//initial value: 0x0
typedef union __RegTprocRegstprocep2frmdattrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep2frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep2frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2frmdattrb0, TRegTprocRegstprocep2frmdattrb0, *PTRegTprocRegstprocep2frmdattrb0;                                //0x16830

//initial value: 0x0
typedef union __RegTprocRegstprocep2frmdattrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep2frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep2frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2frmdattrb1, TRegTprocRegstprocep2frmdattrb1, *PTRegTprocRegstprocep2frmdattrb1;                                //0x16834

//initial value: 0x0
typedef union __RegTprocRegstprocep2frmdattrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep2frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep2frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2frmdattrb2, TRegTprocRegstprocep2frmdattrb2, *PTRegTprocRegstprocep2frmdattrb2;                                //0x16838

//initial value: 0x811
typedef union __RegTprocRegstprocep2frmdattrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep2frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep2frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2frmdattrb3, TRegTprocRegstprocep2frmdattrb3, *PTRegTprocRegstprocep2frmdattrb3;                                //0x1683C

//initial value: 0x274030
typedef union __RegTprocRegstprocep2dataltrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274030. Data loop TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep2dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274030. Data loop TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep2dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274030. Data loop TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2dataltrb0, TRegTprocRegstprocep2dataltrb0, *PTRegTprocRegstprocep2dataltrb0;                                //0x16840

//initial value: 0x0
typedef union __RegTprocRegstprocep2dataltrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep2dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep2dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2dataltrb1, TRegTprocRegstprocep2dataltrb1, *PTRegTprocRegstprocep2dataltrb1;                                //0x16844

//initial value: 0x0
typedef union __RegTprocRegstprocep2dataltrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep2dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep2dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2dataltrb2, TRegTprocRegstprocep2dataltrb2, *PTRegTprocRegstprocep2dataltrb2;                                //0x16848

//initial value: 0x81
typedef union __RegTprocRegstprocep2dataltrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep2dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep2dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2dataltrb3, TRegTprocRegstprocep2dataltrb3, *PTRegTprocRegstprocep2dataltrb3;                                //0x1684C

//initial value: 0x0
typedef union __RegTprocRegstprocep2zlptrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep2zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep2zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2zlptrb0, TRegTprocRegstprocep2zlptrb0, *PTRegTprocRegstprocep2zlptrb0;                                //0x16850

//initial value: 0x0
typedef union __RegTprocRegstprocep2zlptrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep2zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep2zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2zlptrb1, TRegTprocRegstprocep2zlptrb1, *PTRegTprocRegstprocep2zlptrb1;                                //0x16854

//initial value: 0x0
typedef union __RegTprocRegstprocep2zlptrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep2zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep2zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2zlptrb2, TRegTprocRegstprocep2zlptrb2, *PTRegTprocRegstprocep2zlptrb2;                                //0x16858

//initial value: 0x813
typedef union __RegTprocRegstprocep2zlptrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep2zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep2zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2zlptrb3, TRegTprocRegstprocep2zlptrb3, *PTRegTprocRegstprocep2zlptrb3;                                //0x1685C

//initial value: 0x0
typedef union __RegTprocRegstprocep2event0{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event0                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 0
     } fields_read;
    struct {
        uint32_t Regstprocep2event0                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event0, TRegTprocRegstprocep2event0, *PTRegTprocRegstprocep2event0;                                //0x16C00

//initial value: 0x0
typedef union __RegTprocRegstprocep2event1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event1                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 1
     } fields_read;
    struct {
        uint32_t Regstprocep2event1                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event1, TRegTprocRegstprocep2event1, *PTRegTprocRegstprocep2event1;                                //0x16C04

//initial value: 0x0
typedef union __RegTprocRegstprocep2event2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event2                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 2
     } fields_read;
    struct {
        uint32_t Regstprocep2event2                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event2, TRegTprocRegstprocep2event2, *PTRegTprocRegstprocep2event2;                                //0x16C08

//initial value: 0x0
typedef union __RegTprocRegstprocep2event3{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event3                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 3
     } fields_read;
    struct {
        uint32_t Regstprocep2event3                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event3, TRegTprocRegstprocep2event3, *PTRegTprocRegstprocep2event3;                                //0x16C0C

//initial value: 0x0
typedef union __RegTprocRegstprocep2event4{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event4                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 4
     } fields_read;
    struct {
        uint32_t Regstprocep2event4                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 4
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event4, TRegTprocRegstprocep2event4, *PTRegTprocRegstprocep2event4;                                //0x16C10

//initial value: 0x0
typedef union __RegTprocRegstprocep2event5{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event5                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 5
     } fields_read;
    struct {
        uint32_t Regstprocep2event5                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 5
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event5, TRegTprocRegstprocep2event5, *PTRegTprocRegstprocep2event5;                                //0x16C14

//initial value: 0x0
typedef union __RegTprocRegstprocep2event6{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event6                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 6
     } fields_read;
    struct {
        uint32_t Regstprocep2event6                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 6
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event6, TRegTprocRegstprocep2event6, *PTRegTprocRegstprocep2event6;                                //0x16C18

//initial value: 0x0
typedef union __RegTprocRegstprocep2event7{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event7                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 7
     } fields_read;
    struct {
        uint32_t Regstprocep2event7                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 7
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event7, TRegTprocRegstprocep2event7, *PTRegTprocRegstprocep2event7;                                //0x16C1C

//initial value: 0x0
typedef union __RegTprocRegstprocep2event8{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event8                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 8
     } fields_read;
    struct {
        uint32_t Regstprocep2event8                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 8
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event8, TRegTprocRegstprocep2event8, *PTRegTprocRegstprocep2event8;                                //0x16C20

//initial value: 0x0
typedef union __RegTprocRegstprocep2event9{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep2event9                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 9
     } fields_read;
    struct {
        uint32_t Regstprocep2event9                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 9
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep2event9, TRegTprocRegstprocep2event9, *PTRegTprocRegstprocep2event9;                                //0x16C24

//initial value: 0x260080
typedef union __RegTprocRegstprocep3hdrtrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260080. Header TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep3hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260080. Header TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep3hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260080. Header TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3hdrtrb0, TRegTprocRegstprocep3hdrtrb0, *PTRegTprocRegstprocep3hdrtrb0;                                //0x16900

//initial value: 0x0
typedef union __RegTprocRegstprocep3hdrtrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep3hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep3hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3hdrtrb1, TRegTprocRegstprocep3hdrtrb1, *PTRegTprocRegstprocep3hdrtrb1;                                //0x16904

//initial value: 0x4
typedef union __RegTprocRegstprocep3hdrtrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep3hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep3hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3hdrtrb2, TRegTprocRegstprocep3hdrtrb2, *PTRegTprocRegstprocep3hdrtrb2;                                //0x16908

//initial value: 0x15
typedef union __RegTprocRegstprocep3hdrtrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep3hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep3hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3hdrtrb3, TRegTprocRegstprocep3hdrtrb3, *PTRegTprocRegstprocep3hdrtrb3;                                //0x1690C

//initial value: 0x260084
typedef union __RegTprocRegstprocep3metatrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260084. Metadata TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep3metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260084. Metadata TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep3metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260084. Metadata TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3metatrb0, TRegTprocRegstprocep3metatrb0, *PTRegTprocRegstprocep3metatrb0;                                //0x16910

//initial value: 0x0
typedef union __RegTprocRegstprocep3metatrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep3metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep3metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3metatrb1, TRegTprocRegstprocep3metatrb1, *PTRegTprocRegstprocep3metatrb1;                                //0x16914

//initial value: 0x4
typedef union __RegTprocRegstprocep3metatrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep3metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep3metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3metatrb2, TRegTprocRegstprocep3metatrb2, *PTRegTprocRegstprocep3metatrb2;                                //0x16918

//initial value: 0x15
typedef union __RegTprocRegstprocep3metatrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep3metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep3metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3metatrb3, TRegTprocRegstprocep3metatrb3, *PTRegTprocRegstprocep3metatrb3;                                //0x1691C

//initial value: 0x260088
typedef union __RegTprocRegstprocep3nsetrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260088. NSE TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep3nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260088. NSE TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep3nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260088. NSE TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3nsetrb0, TRegTprocRegstprocep3nsetrb0, *PTRegTprocRegstprocep3nsetrb0;                                //0x16920

//initial value: 0x0
typedef union __RegTprocRegstprocep3nsetrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep3nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep3nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3nsetrb1, TRegTprocRegstprocep3nsetrb1, *PTRegTprocRegstprocep3nsetrb1;                                //0x16924

//initial value: 0x4
typedef union __RegTprocRegstprocep3nsetrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep3nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep3nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3nsetrb2, TRegTprocRegstprocep3nsetrb2, *PTRegTprocRegstprocep3nsetrb2;                                //0x16928

//initial value: 0x15
typedef union __RegTprocRegstprocep3nsetrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep3nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep3nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3nsetrb3, TRegTprocRegstprocep3nsetrb3, *PTRegTprocRegstprocep3nsetrb3;                                //0x1692C

//initial value: 0x0
typedef union __RegTprocRegstprocep3frmdattrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep3frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep3frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3frmdattrb0, TRegTprocRegstprocep3frmdattrb0, *PTRegTprocRegstprocep3frmdattrb0;                                //0x16930

//initial value: 0x0
typedef union __RegTprocRegstprocep3frmdattrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep3frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep3frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3frmdattrb1, TRegTprocRegstprocep3frmdattrb1, *PTRegTprocRegstprocep3frmdattrb1;                                //0x16934

//initial value: 0x0
typedef union __RegTprocRegstprocep3frmdattrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep3frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep3frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3frmdattrb2, TRegTprocRegstprocep3frmdattrb2, *PTRegTprocRegstprocep3frmdattrb2;                                //0x16938

//initial value: 0x811
typedef union __RegTprocRegstprocep3frmdattrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep3frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep3frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3frmdattrb3, TRegTprocRegstprocep3frmdattrb3, *PTRegTprocRegstprocep3frmdattrb3;                                //0x1693C

//initial value: 0x274130
typedef union __RegTprocRegstprocep3dataltrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274130. Data loop TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep3dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274130. Data loop TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep3dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274130. Data loop TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3dataltrb0, TRegTprocRegstprocep3dataltrb0, *PTRegTprocRegstprocep3dataltrb0;                                //0x16940

//initial value: 0x0
typedef union __RegTprocRegstprocep3dataltrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep3dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep3dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3dataltrb1, TRegTprocRegstprocep3dataltrb1, *PTRegTprocRegstprocep3dataltrb1;                                //0x16944

//initial value: 0x0
typedef union __RegTprocRegstprocep3dataltrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep3dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep3dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3dataltrb2, TRegTprocRegstprocep3dataltrb2, *PTRegTprocRegstprocep3dataltrb2;                                //0x16948

//initial value: 0x81
typedef union __RegTprocRegstprocep3dataltrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep3dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep3dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3dataltrb3, TRegTprocRegstprocep3dataltrb3, *PTRegTprocRegstprocep3dataltrb3;                                //0x1694C

//initial value: 0x0
typedef union __RegTprocRegstprocep3zlptrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep3zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep3zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3zlptrb0, TRegTprocRegstprocep3zlptrb0, *PTRegTprocRegstprocep3zlptrb0;                                //0x16950

//initial value: 0x0
typedef union __RegTprocRegstprocep3zlptrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep3zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep3zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3zlptrb1, TRegTprocRegstprocep3zlptrb1, *PTRegTprocRegstprocep3zlptrb1;                                //0x16954

//initial value: 0x0
typedef union __RegTprocRegstprocep3zlptrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep3zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep3zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3zlptrb2, TRegTprocRegstprocep3zlptrb2, *PTRegTprocRegstprocep3zlptrb2;                                //0x16958

//initial value: 0x813
typedef union __RegTprocRegstprocep3zlptrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep3zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep3zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3zlptrb3, TRegTprocRegstprocep3zlptrb3, *PTRegTprocRegstprocep3zlptrb3;                                //0x1695C

//initial value: 0x0
typedef union __RegTprocRegstprocep3event0{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event0                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 0
     } fields_read;
    struct {
        uint32_t Regstprocep3event0                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event0, TRegTprocRegstprocep3event0, *PTRegTprocRegstprocep3event0;                                //0x16D00

//initial value: 0x0
typedef union __RegTprocRegstprocep3event1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event1                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 1
     } fields_read;
    struct {
        uint32_t Regstprocep3event1                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event1, TRegTprocRegstprocep3event1, *PTRegTprocRegstprocep3event1;                                //0x16D04

//initial value: 0x0
typedef union __RegTprocRegstprocep3event2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event2                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 2
     } fields_read;
    struct {
        uint32_t Regstprocep3event2                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event2, TRegTprocRegstprocep3event2, *PTRegTprocRegstprocep3event2;                                //0x16D08

//initial value: 0x0
typedef union __RegTprocRegstprocep3event3{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event3                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 3
     } fields_read;
    struct {
        uint32_t Regstprocep3event3                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event3, TRegTprocRegstprocep3event3, *PTRegTprocRegstprocep3event3;                                //0x16D0C

//initial value: 0x0
typedef union __RegTprocRegstprocep3event4{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event4                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 4
     } fields_read;
    struct {
        uint32_t Regstprocep3event4                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 4
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event4, TRegTprocRegstprocep3event4, *PTRegTprocRegstprocep3event4;                                //0x16D10

//initial value: 0x0
typedef union __RegTprocRegstprocep3event5{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event5                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 5
     } fields_read;
    struct {
        uint32_t Regstprocep3event5                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 5
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event5, TRegTprocRegstprocep3event5, *PTRegTprocRegstprocep3event5;                                //0x16D14

//initial value: 0x0
typedef union __RegTprocRegstprocep3event6{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event6                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 6
     } fields_read;
    struct {
        uint32_t Regstprocep3event6                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 6
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event6, TRegTprocRegstprocep3event6, *PTRegTprocRegstprocep3event6;                                //0x16D18

//initial value: 0x0
typedef union __RegTprocRegstprocep3event7{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event7                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 7
     } fields_read;
    struct {
        uint32_t Regstprocep3event7                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 7
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event7, TRegTprocRegstprocep3event7, *PTRegTprocRegstprocep3event7;                                //0x16D1C

//initial value: 0x0
typedef union __RegTprocRegstprocep3event8{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event8                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 8
     } fields_read;
    struct {
        uint32_t Regstprocep3event8                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 8
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event8, TRegTprocRegstprocep3event8, *PTRegTprocRegstprocep3event8;                                //0x16D20

//initial value: 0x0
typedef union __RegTprocRegstprocep3event9{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep3event9                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 9
     } fields_read;
    struct {
        uint32_t Regstprocep3event9                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 9
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep3event9, TRegTprocRegstprocep3event9, *PTRegTprocRegstprocep3event9;                                //0x16D24

//initial value: 0x260100
typedef union __RegTprocRegstprocep4hdrtrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260100. Header TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep4hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260100. Header TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep4hdrtrb0                               :32         ; //Bits :[0:31], initial value: 0x260100. Header TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4hdrtrb0, TRegTprocRegstprocep4hdrtrb0, *PTRegTprocRegstprocep4hdrtrb0;                                //0x16A00

//initial value: 0x0
typedef union __RegTprocRegstprocep4hdrtrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep4hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep4hdrtrb1                               :32         ; //Bits :[0:31], initial value: 0x0. Header TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4hdrtrb1, TRegTprocRegstprocep4hdrtrb1, *PTRegTprocRegstprocep4hdrtrb1;                                //0x16A04

//initial value: 0x4
typedef union __RegTprocRegstprocep4hdrtrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep4hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep4hdrtrb2                               :32         ; //Bits :[0:31], initial value: 0x4. Header TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4hdrtrb2, TRegTprocRegstprocep4hdrtrb2, *PTRegTprocRegstprocep4hdrtrb2;                                //0x16A08

//initial value: 0x15
typedef union __RegTprocRegstprocep4hdrtrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep4hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep4hdrtrb3                               :32         ; //Bits :[0:31], initial value: 0x15. Header TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4hdrtrb3, TRegTprocRegstprocep4hdrtrb3, *PTRegTprocRegstprocep4hdrtrb3;                                //0x16A0C

//initial value: 0x260104
typedef union __RegTprocRegstprocep4metatrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260104. Metadata TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep4metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260104. Metadata TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep4metatrb0                              :32         ; //Bits :[0:31], initial value: 0x260104. Metadata TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4metatrb0, TRegTprocRegstprocep4metatrb0, *PTRegTprocRegstprocep4metatrb0;                                //0x16A10

//initial value: 0x0
typedef union __RegTprocRegstprocep4metatrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep4metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep4metatrb1                              :32         ; //Bits :[0:31], initial value: 0x0. Metadata TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4metatrb1, TRegTprocRegstprocep4metatrb1, *PTRegTprocRegstprocep4metatrb1;                                //0x16A14

//initial value: 0x4
typedef union __RegTprocRegstprocep4metatrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep4metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep4metatrb2                              :32         ; //Bits :[0:31], initial value: 0x4. Metadata TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4metatrb2, TRegTprocRegstprocep4metatrb2, *PTRegTprocRegstprocep4metatrb2;                                //0x16A18

//initial value: 0x15
typedef union __RegTprocRegstprocep4metatrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep4metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep4metatrb3                              :32         ; //Bits :[0:31], initial value: 0x15. Metadata TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4metatrb3, TRegTprocRegstprocep4metatrb3, *PTRegTprocRegstprocep4metatrb3;                                //0x16A1C

//initial value: 0x260108
typedef union __RegTprocRegstprocep4nsetrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260108. NSE TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep4nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260108. NSE TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep4nsetrb0                               :32         ; //Bits :[0:31], initial value: 0x260108. NSE TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4nsetrb0, TRegTprocRegstprocep4nsetrb0, *PTRegTprocRegstprocep4nsetrb0;                                //0x16A20

//initial value: 0x0
typedef union __RegTprocRegstprocep4nsetrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep4nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep4nsetrb1                               :32         ; //Bits :[0:31], initial value: 0x0. NSE TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4nsetrb1, TRegTprocRegstprocep4nsetrb1, *PTRegTprocRegstprocep4nsetrb1;                                //0x16A24

//initial value: 0x4
typedef union __RegTprocRegstprocep4nsetrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep4nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep4nsetrb2                               :32         ; //Bits :[0:31], initial value: 0x4. NSE TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4nsetrb2, TRegTprocRegstprocep4nsetrb2, *PTRegTprocRegstprocep4nsetrb2;                                //0x16A28

//initial value: 0x15
typedef union __RegTprocRegstprocep4nsetrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep4nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep4nsetrb3                               :32         ; //Bits :[0:31], initial value: 0x15. NSE TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4nsetrb3, TRegTprocRegstprocep4nsetrb3, *PTRegTprocRegstprocep4nsetrb3;                                //0x16A2C

//initial value: 0x0
typedef union __RegTprocRegstprocep4frmdattrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep4frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep4frmdattrb0                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4frmdattrb0, TRegTprocRegstprocep4frmdattrb0, *PTRegTprocRegstprocep4frmdattrb0;                                //0x16A30

//initial value: 0x0
typedef union __RegTprocRegstprocep4frmdattrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep4frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep4frmdattrb1                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4frmdattrb1, TRegTprocRegstprocep4frmdattrb1, *PTRegTprocRegstprocep4frmdattrb1;                                //0x16A34

//initial value: 0x0
typedef union __RegTprocRegstprocep4frmdattrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep4frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep4frmdattrb2                            :32         ; //Bits :[0:31], initial value: 0x0. Frame data TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4frmdattrb2, TRegTprocRegstprocep4frmdattrb2, *PTRegTprocRegstprocep4frmdattrb2;                                //0x16A38

//initial value: 0x811
typedef union __RegTprocRegstprocep4frmdattrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep4frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep4frmdattrb3                            :32         ; //Bits :[0:31], initial value: 0x811. Frame data TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4frmdattrb3, TRegTprocRegstprocep4frmdattrb3, *PTRegTprocRegstprocep4frmdattrb3;                                //0x16A3C

//initial value: 0x274230
typedef union __RegTprocRegstprocep4dataltrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274230. Data loop TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep4dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274230. Data loop TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep4dataltrb0                             :32         ; //Bits :[0:31], initial value: 0x274230. Data loop TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4dataltrb0, TRegTprocRegstprocep4dataltrb0, *PTRegTprocRegstprocep4dataltrb0;                                //0x16A40

//initial value: 0x0
typedef union __RegTprocRegstprocep4dataltrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep4dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep4dataltrb1                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4dataltrb1, TRegTprocRegstprocep4dataltrb1, *PTRegTprocRegstprocep4dataltrb1;                                //0x16A44

//initial value: 0x0
typedef union __RegTprocRegstprocep4dataltrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep4dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep4dataltrb2                             :32         ; //Bits :[0:31], initial value: 0x0. Data loop TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4dataltrb2, TRegTprocRegstprocep4dataltrb2, *PTRegTprocRegstprocep4dataltrb2;                                //0x16A48

//initial value: 0x81
typedef union __RegTprocRegstprocep4dataltrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep4dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep4dataltrb3                             :32         ; //Bits :[0:31], initial value: 0x81. Data loop TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4dataltrb3, TRegTprocRegstprocep4dataltrb3, *PTRegTprocRegstprocep4dataltrb3;                                //0x16A4C

//initial value: 0x0
typedef union __RegTprocRegstprocep4zlptrb0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_read;
    struct {
        uint32_t Regstprocep4zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_write;
    struct {
        uint32_t Regstprocep4zlptrb0                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4zlptrb0, TRegTprocRegstprocep4zlptrb0, *PTRegTprocRegstprocep4zlptrb0;                                //0x16A50

//initial value: 0x0
typedef union __RegTprocRegstprocep4zlptrb1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_read;
    struct {
        uint32_t Regstprocep4zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_write;
    struct {
        uint32_t Regstprocep4zlptrb1                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4zlptrb1, TRegTprocRegstprocep4zlptrb1, *PTRegTprocRegstprocep4zlptrb1;                                //0x16A54

//initial value: 0x0
typedef union __RegTprocRegstprocep4zlptrb2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_read;
    struct {
        uint32_t Regstprocep4zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_write;
    struct {
        uint32_t Regstprocep4zlptrb2                               :32         ; //Bits :[0:31], initial value: 0x0. ZLP TRB DWORD 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4zlptrb2, TRegTprocRegstprocep4zlptrb2, *PTRegTprocRegstprocep4zlptrb2;                                //0x16A58

//initial value: 0x813
typedef union __RegTprocRegstprocep4zlptrb3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_read;
    struct {
        uint32_t Regstprocep4zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_write;
    struct {
        uint32_t Regstprocep4zlptrb3                               :32         ; //Bits :[0:31], initial value: 0x813. ZLP TRB DWORD 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4zlptrb3, TRegTprocRegstprocep4zlptrb3, *PTRegTprocRegstprocep4zlptrb3;                                //0x16A5C

//initial value: 0x0
typedef union __RegTprocRegstprocep4event0{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event0                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 0
     } fields_read;
    struct {
        uint32_t Regstprocep4event0                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 0
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event0, TRegTprocRegstprocep4event0, *PTRegTprocRegstprocep4event0;                                //0x16E00

//initial value: 0x0
typedef union __RegTprocRegstprocep4event1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event1                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 1
     } fields_read;
    struct {
        uint32_t Regstprocep4event1                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 1
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event1, TRegTprocRegstprocep4event1, *PTRegTprocRegstprocep4event1;                                //0x16E04

//initial value: 0x0
typedef union __RegTprocRegstprocep4event2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event2                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 2
     } fields_read;
    struct {
        uint32_t Regstprocep4event2                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 2
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event2, TRegTprocRegstprocep4event2, *PTRegTprocRegstprocep4event2;                                //0x16E08

//initial value: 0x0
typedef union __RegTprocRegstprocep4event3{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event3                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 3
     } fields_read;
    struct {
        uint32_t Regstprocep4event3                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 3
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event3, TRegTprocRegstprocep4event3, *PTRegTprocRegstprocep4event3;                                //0x16E0C

//initial value: 0x0
typedef union __RegTprocRegstprocep4event4{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event4                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 4
     } fields_read;
    struct {
        uint32_t Regstprocep4event4                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 4
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event4, TRegTprocRegstprocep4event4, *PTRegTprocRegstprocep4event4;                                //0x16E10

//initial value: 0x0
typedef union __RegTprocRegstprocep4event5{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event5                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 5
     } fields_read;
    struct {
        uint32_t Regstprocep4event5                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 5
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event5, TRegTprocRegstprocep4event5, *PTRegTprocRegstprocep4event5;                                //0x16E14

//initial value: 0x0
typedef union __RegTprocRegstprocep4event6{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event6                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 6
     } fields_read;
    struct {
        uint32_t Regstprocep4event6                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 6
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event6, TRegTprocRegstprocep4event6, *PTRegTprocRegstprocep4event6;                                //0x16E18

//initial value: 0x0
typedef union __RegTprocRegstprocep4event7{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event7                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 7
     } fields_read;
    struct {
        uint32_t Regstprocep4event7                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 7
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event7, TRegTprocRegstprocep4event7, *PTRegTprocRegstprocep4event7;                                //0x16E1C

//initial value: 0x0
typedef union __RegTprocRegstprocep4event8{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event8                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 8
     } fields_read;
    struct {
        uint32_t Regstprocep4event8                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 8
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event8, TRegTprocRegstprocep4event8, *PTRegTprocRegstprocep4event8;                                //0x16E20

//initial value: 0x0
typedef union __RegTprocRegstprocep4event9{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Regstprocep4event9                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 9
     } fields_read;
    struct {
        uint32_t Regstprocep4event9                                :32         ; //Bits :[0:31], initial value: 0x0. Event buffer entry 9
     } fields_rmw; //for non-shadowed register
} RegTprocRegstprocep4event9, TRegTprocRegstprocep4event9, *PTRegTprocRegstprocep4event9;                                //0x16E24

//##############################################################
//                      usb_registers area
//##############################################################
//Adjusts the voltage level for the threshold used t o detect valid high-speed data. This register is directly connected
//to the identically named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY
//for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
//initial value: 0x3
typedef union __RegUsbSquelchThresholdAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SquelchThresholdAdjustment                        :3          ; //Bits :[0:2], initial value: 0x3. A positive binary bit setting change results in a –5% incremental change in threshold voltage level, while a negative binary bit setting change results in a +5% incremental change in threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t SquelchThresholdAdjustment                        :3          ; //Bits :[0:2], initial value: 0x3. A positive binary bit setting change results in a –5% incremental change in threshold voltage level, while a negative binary bit setting change results in a +5% incremental change in threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t SquelchThresholdAdjustment                        :3          ; //Bits :[0:2], initial value: 0x3. A positive binary bit setting change results in a –5% incremental change in threshold voltage level, while a negative binary bit setting change results in a +5% incremental change in threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbSquelchThresholdAdjustment, TRegUsbSquelchThresholdAdjustment, *PTRegUsbSquelchThresholdAdjustment;                                //0x17000

//Adjusts the low- and full-speed single-ended source impedance while driving high. This register is directly connected
//to the identically named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY
//for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
//initial value: 0x3
typedef union __RegUsbFsLsSourceImpedanceAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FsLsSourceImpedanceAdjustment                     :4          ; //Bits :[0:3], initial value: 0x3. This parameter control is encoded in thermometer code. A positive thermometer code change results in a -2.5% incremental change in source impedance. A negative thermometer code change results in +2.5% incremental change in source impedance. Any non-thermometer code setting (that is, 1001) is not supported and reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t FsLsSourceImpedanceAdjustment                     :4          ; //Bits :[0:3], initial value: 0x3. This parameter control is encoded in thermometer code. A positive thermometer code change results in a -2.5% incremental change in source impedance. A negative thermometer code change results in +2.5% incremental change in source impedance. Any non-thermometer code setting (that is, 1001) is not supported and reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t FsLsSourceImpedanceAdjustment                     :4          ; //Bits :[0:3], initial value: 0x3. This parameter control is encoded in thermometer code. A positive thermometer code change results in a -2.5% incremental change in source impedance. A negative thermometer code change results in +2.5% incremental change in source impedance. Any non-thermometer code setting (that is, 1001) is not supported and reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbFsLsSourceImpedanceAdjustment, TRegUsbFsLsSourceImpedanceAdjustment, *PTRegUsbFsLsSourceImpedanceAdjustment;                                //0x17004

//This bus adjusts the voltage at which the DP0 and                         DM0 signals cross while transmitting
// in HS mode. This register is directly connected to the identically named inputs on the USB3 PHY instantiation.
//See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality
//of these inputs
//initial value: 0x3
typedef union __RegUsbTransmitterHighSpeedCrossoverAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TransmitterHighSpeedCrossoverAdjustment           :2          ; //Bits :[0:1], initial value: 0x3. 11: Default setting, 10: + 15 mV, 01: – 15 mV, 00: Reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t TransmitterHighSpeedCrossoverAdjustment           :2          ; //Bits :[0:1], initial value: 0x3. 11: Default setting, 10: + 15 mV, 01: – 15 mV, 00: Reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t TransmitterHighSpeedCrossoverAdjustment           :2          ; //Bits :[0:1], initial value: 0x3. 11: Default setting, 10: + 15 mV, 01: – 15 mV, 00: Reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbTransmitterHighSpeedCrossoverAdjustment, TRegUsbTransmitterHighSpeedCrossoverAdjustment, *PTRegUsbTransmitterHighSpeedCrossoverAdjustment;                                //0x17008

//This signal controls the amount of current sourced to DP0 and DM0after a J-to-K or K-to-J transition. The HS Transmitter
//pre-emphasis current is defined in terms of unit amounts. One unit amount is approximately 600 uA and is defined
//as 1X pre-emphasis current. This register is directly connected to the identically named inputs on the USB3 PHY
//instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description
//of the functionality of these inputs
//initial value: 0x00
typedef union __RegUsbHsTransmitterPreemphasisCurrentControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t HsTransmitterPreEmphasisCurrentControl            :2          ; //Bits :[0:1], initial value: 0x0. 11: HS Transmitter pre-emphasis circuit sources 3X preemphasis                             current.                             10: HS Transmitter pre-emphasis circuit sources 2X preemphasis current.                             01: HS Transmitter pre-emphasis circuit sources 1X preemphasis current.                             00 (design default): HS Transmitter pre-emphasis is disabled.                             If these signals are not used, set them to 2'b00.                             See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t HsTransmitterPreEmphasisCurrentControl            :2          ; //Bits :[0:1], initial value: 0x0. 11: HS Transmitter pre-emphasis circuit sources 3X preemphasis                             current.                             10: HS Transmitter pre-emphasis circuit sources 2X preemphasis current.                             01: HS Transmitter pre-emphasis circuit sources 1X preemphasis current.                             00 (design default): HS Transmitter pre-emphasis is disabled.                             If these signals are not used, set them to 2'b00.                             See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t HsTransmitterPreEmphasisCurrentControl            :2          ; //Bits :[0:1], initial value: 0x0. 11: HS Transmitter pre-emphasis circuit sources 3X preemphasis                             current.                             10: HS Transmitter pre-emphasis circuit sources 2X preemphasis current.                             01: HS Transmitter pre-emphasis circuit sources 1X preemphasis current.                             00 (design default): HS Transmitter pre-emphasis is disabled.                             If these signals are not used, set them to 2'b00.                             See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbHsTransmitterPreemphasisCurrentControl, TRegUsbHsTransmitterPreemphasisCurrentControl, *PTRegUsbHsTransmitterPreemphasisCurrentControl;                                //0x1700C

//Some applications require additional devices to be                         added on the USB, such as a series switch,
//which can add                         significant series resistance. This bus adjusts the driver source
//                  impedance to compensate for added series resistance on the                         USB. This
// register is directly connected to the identically named inputs on the USB3 PHY instantiation. See the Synopsys
//document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these
//inputs
//initial value: 0x01
typedef union __RegUsbUsbSourceImpedanceAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UsbSourceImpedanceAdjustment                      :2          ; //Bits :[0:1], initial value: 0x1. 11: Source impedance is decreased by approximately 4 Ω.                             10: Source impedance is decreased by approximately 2 Ω.                             01: Design default                             00: Source impedance is increased by approximately 1.5 Ω.                             Note: Any setting other than the default can result in source                             impedance variation across process, voltage, and temperature                             conditions that does not meet USB 2.0 specification limits.                             If this bus is not used, leave it at the default setting                             See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t UsbSourceImpedanceAdjustment                      :2          ; //Bits :[0:1], initial value: 0x1. 11: Source impedance is decreased by approximately 4 Ω.                             10: Source impedance is decreased by approximately 2 Ω.                             01: Design default                             00: Source impedance is increased by approximately 1.5 Ω.                             Note: Any setting other than the default can result in source                             impedance variation across process, voltage, and temperature                             conditions that does not meet USB 2.0 specification limits.                             If this bus is not used, leave it at the default setting                             See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t UsbSourceImpedanceAdjustment                      :2          ; //Bits :[0:1], initial value: 0x1. 11: Source impedance is decreased by approximately 4 Ω.                             10: Source impedance is decreased by approximately 2 Ω.                             01: Design default                             00: Source impedance is increased by approximately 1.5 Ω.                             Note: Any setting other than the default can result in source                             impedance variation across process, voltage, and temperature                             conditions that does not meet USB 2.0 specification limits.                             If this bus is not used, leave it at the default setting                             See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbUsbSourceImpedanceAdjustment, TRegUsbUsbSourceImpedanceAdjustment, *PTRegUsbUsbSourceImpedanceAdjustment;                                //0x17010

//Adjusts the rise and fall times of the high-speed                         waveform. This register is directly connected
//to the identically named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY
//for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs.
//initial value: 0x01
typedef union __RegUsbHsTransmitterRiseAndFallAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t HsTransmitterRiseAndFallAdjustment                :2          ; //Bits :[0:1], initial value: 0x1. A positive binary bit setting change results in a –4%                             incremental change in the HS rise and fall time. A negative binary                             bit setting change results in a +4% incremental change in the                             HS rise and fall time. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t HsTransmitterRiseAndFallAdjustment                :2          ; //Bits :[0:1], initial value: 0x1. A positive binary bit setting change results in a –4%                             incremental change in the HS rise and fall time. A negative binary                             bit setting change results in a +4% incremental change in the                             HS rise and fall time. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t HsTransmitterRiseAndFallAdjustment                :2          ; //Bits :[0:1], initial value: 0x1. A positive binary bit setting change results in a –4%                             incremental change in the HS rise and fall time. A negative binary                             bit setting change results in a +4% incremental change in the                             HS rise and fall time. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbHsTransmitterRiseAndFallAdjustment, TRegUsbHsTransmitterRiseAndFallAdjustment, *PTRegUsbHsTransmitterRiseAndFallAdjustment;                                //0x17014

//Adjusts the high-speed DC level voltage. This register is directly connected to the identically named inputs on
//the USB3 PHY instantiation. Adjusts the high-speed DC level voltage. See the Synopsys document 'SuperSpeed USB
// 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
//initial value: 0x3
typedef union __RegUsbHsDcVoltageLevelAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t HsDcVoltageLevelAdjustment                        :4          ; //Bits :[0:3], initial value: 0x3. A positive binary bit setting change results in a +1.25% incremental change in high-speed DC voltage level, while a negative binary bit setting change results in a –1.25% incremental change in high-speed DC voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t HsDcVoltageLevelAdjustment                        :4          ; //Bits :[0:3], initial value: 0x3. A positive binary bit setting change results in a +1.25% incremental change in high-speed DC voltage level, while a negative binary bit setting change results in a –1.25% incremental change in high-speed DC voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t HsDcVoltageLevelAdjustment                        :4          ; //Bits :[0:3], initial value: 0x3. A positive binary bit setting change results in a +1.25% incremental change in high-speed DC voltage level, while a negative binary bit setting change results in a –1.25% incremental change in high-speed DC voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbHsDcVoltageLevelAdjustment, TRegUsbHsDcVoltageLevelAdjustment, *PTRegUsbHsDcVoltageLevelAdjustment;                                //0x17018

//Sets the number of reference clock cycles to mask                         the incoming LFPS in U3 and U2 states.
//Masks the incoming                         LFPS for the number of reference clock cycles equal to the
//                value of pcs_rx_los_mask_val[9:0]. This control filters out short,                         non-compliant
//LFPS glitches sent by a non-compliant host.                         This register is directly connected to the
// identically named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY for
// TSMC LP 1V 2.5V  Databook' for the complete description of the functionality of these inputs
//initial value: 0x0F0
typedef union __RegUsbPcsRxLossOfSignalMaskValue{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t PcsRxLossOfSignalMaskValue                        :10         ; //Bits :[0:9], initial value: 0xF0. For normal operation, set to a targeted mask interval of 10 us                             (value = 10 us divided by  Tref_clk). If the ref_clkdiv2 signal is used, the                             value = 10 us divided by (2 * Tref_clk).                             Setting this bus to 10'b0 disables masking. The value should be defined when in reset.                             Changing this value during operation might disrupt normal operation of the link.
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t PcsRxLossOfSignalMaskValue                        :10         ; //Bits :[0:9], initial value: 0xF0. For normal operation, set to a targeted mask interval of 10 us                             (value = 10 us divided by  Tref_clk). If the ref_clkdiv2 signal is used, the                             value = 10 us divided by (2 * Tref_clk).                             Setting this bus to 10'b0 disables masking. The value should be defined when in reset.                             Changing this value during operation might disrupt normal operation of the link.
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t PcsRxLossOfSignalMaskValue                        :10         ; //Bits :[0:9], initial value: 0xF0. For normal operation, set to a targeted mask interval of 10 us                             (value = 10 us divided by  Tref_clk). If the ref_clkdiv2 signal is used, the                             value = 10 us divided by (2 * Tref_clk).                             Setting this bus to 10'b0 disables masking. The value should be defined when in reset.                             Changing this value during operation might disrupt normal operation of the link.
        uint32_t Reserved                                          :22         ; //Bits :[10:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbPcsRxLossOfSignalMaskValue, TRegUsbPcsRxLossOfSignalMaskValue, *PTRegUsbPcsRxLossOfSignalMaskValue;                                //0x1701C

//This static value sets the Tx driver de-emphasis value when pipeP_tx_deemph[1:0] is set to 2'b01 (according to
// the PIPE3 specification).This register is directly connected to the identically named inputs on the USB3 PHY instantiation.
//See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality
//of these inputs
//initial value: 0x015
typedef union __RegUsbTxDeemphasisAt3P5Db{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TxDeEmphasisAt3P5Db                               :6          ; //Bits :[0:5], initial value: 0x15. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t TxDeEmphasisAt3P5Db                               :6          ; //Bits :[0:5], initial value: 0x15. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t TxDeEmphasisAt3P5Db                               :6          ; //Bits :[0:5], initial value: 0x15. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbTxDeemphasisAt3P5Db, TRegUsbTxDeemphasisAt3P5Db, *PTRegUsbTxDeemphasisAt3P5Db;                                //0x17020

//This static value sets the Tx driver de-emphasis                         value when pipeP_tx_deemph[1:0] is set
//to 2'b10 (according to                         the PIPE3 specification). This bus is provided for completeness
//                         and as a second potential launch amplitude. This register is directly connected to the
//identically named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC
//LP 1V 2.5V  Databook' for the description of the functionality of these inputs
//initial value: 0x20
typedef union __RegUsbTxDeemphasisAt6Db{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TxDeemphasisAt6Db                                 :6          ; //Bits :[0:5], initial value: 0x20. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t TxDeemphasisAt6Db                                 :6          ; //Bits :[0:5], initial value: 0x20. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t TxDeemphasisAt6Db                                 :6          ; //Bits :[0:5], initial value: 0x20. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbTxDeemphasisAt6Db, TRegUsbTxDeemphasisAt6Db, *PTRegUsbTxDeemphasisAt6Db;                                //0x17024

//his static value sets the launch amplitude of the                         transmitter. This register is directly
//connected to the identically named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed
// USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
//initial value: 0x73
typedef union __RegUsbTxAmplitudeFullSwingMode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TxAmplitudeFullSwingMode                          :7          ; //Bits :[0:6], initial value: 0x73. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t TxAmplitudeFullSwingMode                          :7          ; //Bits :[0:6], initial value: 0x73. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t TxAmplitudeFullSwingMode                          :7          ; //Bits :[0:6], initial value: 0x73. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :25         ; //Bits :[7:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbTxAmplitudeFullSwingMode, TRegUsbTxAmplitudeFullSwingMode, *PTRegUsbTxAmplitudeFullSwingMode;                                //0x17028

//This signal controls the duration for which the HS pre-emphasis current is sourced onto DP0 or DM0. The HS Transmitter
//pre-emphasis duration is defined in terms of unit amounts. This register is directly connected to the identically
//named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V
// Databook' for the description of the functionality of these inputs
//initial value: 0x0
typedef union __RegUsbHsTransmitterPreemphasisDurationControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t HsTransmitterPreemphasisDurationControl           :1          ; //Bits :[0:0], initial value: 0x0. The HS Transmitter pre-emphasis duration is defined in terms of unit amounts. One unit of pre-emphasis duration is approximately 580 ps and is defined as 1X pre-emphasis duration. This signal is valid only if either TXPREEMPAMPTUNE0[1] or TXPREEMPAMPTUNE0[0] is set to 1'b1. 1: 1X, short pre-emphasis current duration                             0: 2X (design default), long pre-emphasis current duration. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t HsTransmitterPreemphasisDurationControl           :1          ; //Bits :[0:0], initial value: 0x0. The HS Transmitter pre-emphasis duration is defined in terms of unit amounts. One unit of pre-emphasis duration is approximately 580 ps and is defined as 1X pre-emphasis duration. This signal is valid only if either TXPREEMPAMPTUNE0[1] or TXPREEMPAMPTUNE0[0] is set to 1'b1. 1: 1X, short pre-emphasis current duration                             0: 2X (design default), long pre-emphasis current duration. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t HsTransmitterPreemphasisDurationControl           :1          ; //Bits :[0:0], initial value: 0x0. The HS Transmitter pre-emphasis duration is defined in terms of unit amounts. One unit of pre-emphasis duration is approximately 580 ps and is defined as 1X pre-emphasis duration. This signal is valid only if either TXPREEMPAMPTUNE0[1] or TXPREEMPAMPTUNE0[0] is set to 1'b1. 1: 1X, short pre-emphasis current duration                             0: 2X (design default), long pre-emphasis current duration. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbHsTransmitterPreemphasisDurationControl, TRegUsbHsTransmitterPreemphasisDurationControl, *PTRegUsbHsTransmitterPreemphasisDurationControl;                                //0x1703C

//Selects the range of spread spectrum modulation when ssc_en is asserted and the PHY is spreading the high-speed
//transmit clocks. Applies a fixed offset to the phase accumulator. This register is directly connected to the identically
//named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V
// Databook' for the description of the functionality of these inputs
//initial value: 0x000
typedef union __RegUsbSpreadSpectrumClockRange{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SpreadSpectrumClockRange                          :3          ; //Bits :[0:2], initial value: 0x0. 3'b000,  4,980.  3'b001 4,492.  3'b010 4,003.  3'b011 to 3'b111 reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t SpreadSpectrumClockRange                          :3          ; //Bits :[0:2], initial value: 0x0. 3'b000,  4,980.  3'b001 4,492.  3'b010 4,003.  3'b011 to 3'b111 reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t SpreadSpectrumClockRange                          :3          ; //Bits :[0:2], initial value: 0x0. 3'b000,  4,980.  3'b001 4,492.  3'b010 4,003.  3'b011 to 3'b111 reserved. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbSpreadSpectrumClockRange, TRegUsbSpreadSpectrumClockRange, *PTRegUsbSpreadSpectrumClockRange;                                //0x17040

//This signal places the high-speed blocks into Loopback mode and enables the                         high-speed
// receive and transmit logic concurrently. Enable this signal for test purpose only. This register is directly connected
//to the identically named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed USB 3.0 PHY
//for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
//initial value: 0x0
typedef union __RegUsbLoopbackTestEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LoopbackTestEnable                                :1          ; //Bits :[0:0], initial value: 0x0. 1: During HS data transmission, the HS receive logic is                             enabled.                             0: During HS data transmission, the HS receive logic is                             disabled.                              See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t LoopbackTestEnable                                :1          ; //Bits :[0:0], initial value: 0x0. 1: During HS data transmission, the HS receive logic is                             enabled.                             0: During HS data transmission, the HS receive logic is                             disabled.                              See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t LoopbackTestEnable                                :1          ; //Bits :[0:0], initial value: 0x0. 1: During HS data transmission, the HS receive logic is                             enabled.                             0: During HS data transmission, the HS receive logic is                             disabled.                              See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbLoopbackTestEnable, TRegUsbLoopbackTestEnable, *PTRegUsbLoopbackTestEnable;                                //0x17044

//This controller signal is an output from the USB 3.0 PHY's Session Valid comparator and indicates whether the session
//for an A-device is valid. This register is directly connected to the identically named inputs on the USB3 PHY instantiation.
//See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality
//of these inputs. No verification required, this is USB2 feature
//initial value: 0x0
typedef union __RegUsbADeviceSessionValidIndicator{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ADeviceSessionValidIndicator                      :1          ; //Bits :[0:0], initial value: 0x0. 1: Session for the A-device is valid.  0: Session for the A-device is not valid. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t ADeviceSessionValidIndicator                      :1          ; //Bits :[0:0], initial value: 0x0. 1: Session for the A-device is valid.  0: Session for the A-device is not valid. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbADeviceSessionValidIndicator, TRegUsbADeviceSessionValidIndicator, *PTRegUsbADeviceSessionValidIndicator;                                //0x17048

//This controller signal is an output from the USB 3.0 PHY's Session Valid comparator and indicates whether the session
//for a B-device is valid. This register is directly connected to the identically named inputs on the USB3 PHY instantiation.
//See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality
//of these inputs. No verification required, this is USB2 feature
//initial value: 0x0
typedef union __RegUsbBDeviceSessionValidIndicator{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t BDeviceSessionValidIndicator                      :1          ; //Bits :[0:0], initial value: 0x0. 1: Session for the B-device is valid.  0: Session for the B-device is not valid. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t BDeviceSessionValidIndicator                      :1          ; //Bits :[0:0], initial value: 0x0. 1: Session for the B-device is valid.  0: Session for the B-device is not valid. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbBDeviceSessionValidIndicator, TRegUsbBDeviceSessionValidIndicator, *PTRegUsbBDeviceSessionValidIndicator;                                //0x1704C

//Reserved. This register is directly connected to the identically named inputs on the USB3 PHY instantiation. See
//the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality
//of these inputs
//initial value: 0x4
typedef union __RegUsbTxVoltageBoostLevel{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TxVoltageBoostLevel                               :3          ; //Bits :[0:2], initial value: 0x4. Reserved. Do not change. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t TxVoltageBoostLevel                               :3          ; //Bits :[0:2], initial value: 0x4. Reserved. Do not change. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t TxVoltageBoostLevel                               :3          ; //Bits :[0:2], initial value: 0x4. Reserved. Do not change. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbTxVoltageBoostLevel, TRegUsbTxVoltageBoostLevel, *PTRegUsbTxVoltageBoostLevel;                                //0x17050

//This register is directly connected to the identically named inputs on the USB3 PHY instantiation. See the Synopsys
//document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these
//inputs
//initial value: 0x5
typedef union __RegUsbLossOfSignalDetectorThresholdLevelControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LossOfSignalDetectorThresholdLevelControl         :3          ; //Bits :[0:2], initial value: 0x5. Reserved. Do not change. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t LossOfSignalDetectorThresholdLevelControl         :3          ; //Bits :[0:2], initial value: 0x5. Reserved. Do not change. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t LossOfSignalDetectorThresholdLevelControl         :3          ; //Bits :[0:2], initial value: 0x5. Reserved. Do not change. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbLossOfSignalDetectorThresholdLevelControl, TRegUsbLossOfSignalDetectorThresholdLevelControl, *PTRegUsbLossOfSignalDetectorThresholdLevelControl;                                //0x17054

//Adjusts the voltage level for the threshold used to detect a                         disconnect event at the host.
//This register is directly connected to the identically named inputs on the USB3 PHY instantiation. See the Synopsys
//document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these
//inputs
//initial value: 0x4
typedef union __RegUsbDisconnectThresholdAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DisconnectThresholdAdjustment                     :3          ; //Bits :[0:2], initial value: 0x4. A positive binary bit setting change results in a plus 1.5%                             incremental change in the threshold voltage level, while a negative binary bit setting change results in a minus 1.5% incremental change in the threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t DisconnectThresholdAdjustment                     :3          ; //Bits :[0:2], initial value: 0x4. A positive binary bit setting change results in a plus 1.5%                             incremental change in the threshold voltage level, while a negative binary bit setting change results in a minus 1.5% incremental change in the threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t DisconnectThresholdAdjustment                     :3          ; //Bits :[0:2], initial value: 0x4. A positive binary bit setting change results in a plus 1.5%                             incremental change in the threshold voltage level, while a negative binary bit setting change results in a minus 1.5% incremental change in the threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbDisconnectThresholdAdjustment, TRegUsbDisconnectThresholdAdjustment, *PTRegUsbDisconnectThresholdAdjustment;                                //0x17058

//This bus adjusts the voltage level for the VBUS0                         valid threshold. This register is directly
//connected to the identically named inputs on the USB3 PHY instantiation. See the Synopsys document 'SuperSpeed
// USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
//initial value: 0x4
typedef union __RegUsbVbusValidThresholdAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VbusValidThresholdAdjustment                      :3          ; //Bits :[0:2], initial value: 0x4. A positive binary bit setting change results in a plus 1.5%                             incremental change in the threshold voltage level, while a                             negative binary bit setting change results in a  minus 1.5%                             incremental change in the threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t VbusValidThresholdAdjustment                      :3          ; //Bits :[0:2], initial value: 0x4. A positive binary bit setting change results in a plus 1.5%                             incremental change in the threshold voltage level, while a                             negative binary bit setting change results in a  minus 1.5%                             incremental change in the threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t VbusValidThresholdAdjustment                      :3          ; //Bits :[0:2], initial value: 0x4. A positive binary bit setting change results in a plus 1.5%                             incremental change in the threshold voltage level, while a                             negative binary bit setting change results in a  minus 1.5%                             incremental change in the threshold voltage level. See the Synopsys document 'SuperSpeed USB 3.0 PHY for TSMC LP 1V 2.5V  Databook' for the description of the functionality of these inputs
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbVbusValidThresholdAdjustment, TRegUsbVbusValidThresholdAdjustment, *PTRegUsbVbusValidThresholdAdjustment;                                //0x1705C

//This register holds the data to written to one the 127 internal control registers in the USB3 PHY. Reading and
// writing these internal registers (which are NOT on the DS4 APB CRS bus)requires multiple access on the DS4 APB
//CRS bus. For a write to one of the internal PHY control register, the data to be written to the internal PHY register
//is first written to this APB CSR register, then the address of the internal PHY register is written to the APB
// CSR 'USB3 PHY Control Register Address' register, and a write to the APB CSR 'USB3 PHY Control Register Write
// Command' register is done. When the 'USB3 PHY Control Register Write Command' address is written by the LCP, a
//state machine in the usb_top module completes the asynchronous write to the PHY with the data. The LCP must always
//check that the USB3 PHY Control Register Busy CSR is 0 before writing to this register.
//initial value: 0x0
typedef union __RegUsbUsb3PhyControlRegisterWriteData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3PhyControlRegisterWrData                      :16         ; //Bits :[0:15], initial value: 0x0. Write Data for the internal registers in the USB3 Phy.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t Usb3PhyControlRegisterWrData                      :16         ; //Bits :[0:15], initial value: 0x0. Write Data for the internal registers in the USB3 Phy.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t Usb3PhyControlRegisterWrData                      :16         ; //Bits :[0:15], initial value: 0x0. Write Data for the internal registers in the USB3 Phy.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbUsb3PhyControlRegisterWriteData, TRegUsbUsb3PhyControlRegisterWriteData, *PTRegUsbUsb3PhyControlRegisterWriteData;                                //0x17060

//This register holds the Data read from the 127 internal control registers in the USB3 PHY. Reading and writing
// these internal registers (which are NOT on the DS4 APB CRS bus)requires multiple access on the DS4 APB CRS bus.
//For a read fromone of the internal PHY control register, the address of the internal PHY register is written to
//the APB CSR 'USB3 PHY Control Register Address' register, and a write to the APB CSR 'USB3 PHY Control Register
//Read Command' register is done. When the 'USB3 PHY Control Register Read Command' address is written by the LCP,
//a state machine in the usb_top module completes the asynchronous read from the PHY, and the data can be read from
//this register when the read is complete. The LCP must check that the USB3 PHY Control Register Busy CSR is 0 before
//reading this register, otherwise the data may not have been read from the PHY yet..
//initial value: 0x0
typedef union __RegUsbUsb3PhyControlRegisterReadData{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3PhyControlRegisterData                        :16         ; //Bits :[0:15], initial value: 0x0. Read Data from one of the internal registers in the USB3 Phy.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t Usb3PhyControlRegisterData                        :16         ; //Bits :[0:15], initial value: 0x0. Read Data from one of the internal registers in the USB3 Phy.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbUsb3PhyControlRegisterReadData, TRegUsbUsb3PhyControlRegisterReadData, *PTRegUsbUsb3PhyControlRegisterReadData;                                //0x17084

//Holds the address of one of the 127 internal registers in the USB3 PHY. To read or write from one of these internal
//registers it is necessary to first write the address of the internal register this register. The LCP must always
//check that the USB3 PHY Control Register Busy CSR is 0 before writing to this register.
//initial value: 0x0
typedef union __RegUsbUsb3PhyControlRegisterAddress{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3PhyControlRegisterAddress                     :16         ; //Bits :[0:15], initial value: 0x0. Address of the internal register in the USB3 PHY that is beign written to or read from
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t Usb3PhyControlRegisterAddress                     :16         ; //Bits :[0:15], initial value: 0x0. Address of the internal register in the USB3 PHY that is beign written to or read from
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t Usb3PhyControlRegisterAddress                     :16         ; //Bits :[0:15], initial value: 0x0. Address of the internal register in the USB3 PHY that is beign written to or read from
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbUsb3PhyControlRegisterAddress, TRegUsbUsb3PhyControlRegisterAddress, *PTRegUsbUsb3PhyControlRegisterAddress;                                //0x17064

//When this register is written, the state machine in the usb_top will attempt to write the data in the 'USB3 PHY
//Control Register Data' to internal PHY control register at the address in the 'USB3 PHY Control Register Address'
//in the USB3 PHY. This register is not a real register, the value written does not matter, and a read always returns
//zeros.The LCP must always check that the USB3 PHY Control Register Busy CSR is 0 before writing to this register.
//initial value: 0x0
typedef union __RegUsbUsb3PhyControlRegisterWriteCommand{ //register type:WO shadowed:NO
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3PhyControlRegisterWriteCommand                :32         ; //Bits :[0:31], initial value: 0x0. Write data is ignored, reads always return zeros.
     } fields_write;
    struct {
        uint32_t Usb3PhyControlRegisterWriteCommand                :32         ; //Bits :[0:31], initial value: 0x0. Write data is ignored, reads always return zeros.
     } fields_rmw; //for non-shadowed register
} RegUsbUsb3PhyControlRegisterWriteCommand, TRegUsbUsb3PhyControlRegisterWriteCommand, *PTRegUsbUsb3PhyControlRegisterWriteCommand;                                //0x17068

//When any value is written to this register, the state machine in the usb_top will attempt to read the internal
// register of the USB3 PHY at the address in the 'USB3 PHY Control Register Address' and will return the data to
//the 'USB3 PHY Control Register Data'. The LCP must always check that the USB3 PHY Control Register Busy CSR is
// 0 before writing to this register.
//initial value: 0x0
typedef union __RegUsbUsb3PhyControlRegisterReadCommand{ //register type:WO shadowed:NO
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3PhyControlRegisterReadCommand                 :32         ; //Bits :[0:31], initial value: 0x0. Write data is ignored, but will initiate a read of a USB3 PHY internal control register. Reads always return zeros.
     } fields_write;
    struct {
        uint32_t Usb3PhyControlRegisterReadCommand                 :32         ; //Bits :[0:31], initial value: 0x0. Write data is ignored, but will initiate a read of a USB3 PHY internal control register. Reads always return zeros.
     } fields_rmw; //for non-shadowed register
} RegUsbUsb3PhyControlRegisterReadCommand, TRegUsbUsb3PhyControlRegisterReadCommand, *PTRegUsbUsb3PhyControlRegisterReadCommand;                                //0x1706C

//When any value is written to this register, the USB3 PHY Internal Register Read-Write State machine in the usb_top
//will be reset to its initial idle state. This feature is intended to provide a means for the LCP to re-establish
//communication with the control registers in the USB3 PHY should there be a problem.
//initial value: 0x0
typedef union __RegUsbUsb3PhyControlRegisterResetCommand{ //register type:WO shadowed:NO
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3PhyControlRegisterResetCommand                :32         ; //Bits :[0:31], initial value: 0x0. Write data is ignored, reads always return zeros.
     } fields_write;
    struct {
        uint32_t Usb3PhyControlRegisterResetCommand                :32         ; //Bits :[0:31], initial value: 0x0. Write data is ignored, reads always return zeros.
     } fields_rmw; //for non-shadowed register
} RegUsbUsb3PhyControlRegisterResetCommand, TRegUsbUsb3PhyControlRegisterResetCommand, *PTRegUsbUsb3PhyControlRegisterResetCommand;                                //0x17070

//This register provides an indication to the LCP of the state of a command given to the USB3 PHY internal register
//read-write state machine. The LCP must always check that this register is 0 before writing to any of the other
// registers for USB3 PHY Internal Register Read-Write control. When the LCP commands a read or a write of an internal
//register in the SNPS PHY (with the USB3 PHY Control Register Write Command Register or the USB3 PHY Control Register
//Read Command Register) this register will be set to 1, and will remain 1 until the read or write command is completed.
//When the command is completed, this register returns to 0, indicating that the state machine is ready to accept
//another command or new data or the address for another command, or that the data is ready to be read from the USB3_PHY_Control_Register_Read_Data
//CSR. This register is reset to 0 by the USB3 PHY Control Register Reset Command. If any of the other registers
// are written while this register is 1, the results will be unpredictable.
//initial value: 0x0
typedef union __RegUsbUsb3PhyControlRegisterBusy{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3PhyControlRegisterBusy                        :1          ; //Bits :[0:0], initial value: 0x0. 1 = Indicates that the state machine that manages the reads and writes to the USB3 Phy is busy with a command. 0 = not busy.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t Usb3PhyControlRegisterBusy                        :1          ; //Bits :[0:0], initial value: 0x0. 1 = Indicates that the state machine that manages the reads and writes to the USB3 Phy is busy with a command. 0 = not busy.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbUsb3PhyControlRegisterBusy, TRegUsbUsb3PhyControlRegisterBusy, *PTRegUsbUsb3PhyControlRegisterBusy;                                //0x17074

//Disables the internal bus filters in the USB3 controller on four input signals from the PHY. This CSR drives a
// port on the USB Controller IP, DWC_usb3.
//initial value: 0x0
typedef union __RegUsbBusFilterBypass{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3BusFilterBypass                               :4          ; //Bits :[0:3], initial value: 0x0. This register should be remain 0000 for normal operation. See the USB Core data book for details.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t Usb3BusFilterBypass                               :4          ; //Bits :[0:3], initial value: 0x0. This register should be remain 0000 for normal operation. See the USB Core data book for details.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t Usb3BusFilterBypass                               :4          ; //Bits :[0:3], initial value: 0x0. This register should be remain 0000 for normal operation. See the USB Core data book for details.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbBusFilterBypass, TRegUsbBusFilterBypass, *PTRegUsbBusFilterBypass;                                //0x17078

//Selects the reference frequency for the SS and HS modes.  See the USB Core data book for details.
//initial value: 0x3A210AA
typedef union __RegUsbFrequencySelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FselUsbCoreInput                                  :6          ; //Bits :[0:5], initial value: 0x2A. This register should be left at the default value, which selects a 24MHz reference clock. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t RefclkselUsbCoreInput                             :2          ; //Bits :[6:7], initial value: 0x2. This register should be left at the default value, which selects the external reference clock for both the HS and SS functions. The DS5 has 24MHz signal appliesd the the external reference clock input. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the external reference clock input on the USB core.
        uint32_t RefClkdiv2UsbCoreInput                            :1          ; //Bits :[8:8], initial value: 0x0. This register should be left at the default value, which specifies that the reference clock is not divided, as required for the 24MHz reference clock used in the DS5. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t SscRefClkSelUsbCoreInput                          :9          ; //Bits :[9:17], initial value: 0x108. This register should be left at the default value, which is the Spread Spectrum Reference Clock Shifting value for a 24MHz reference clock. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t MpllMultiplierUsbCoreInput                        :7          ; //Bits :[18:24], initial value: 0x68. This register should be left at the default value, which the PLL multiplier needs for a 24MHz reference clock input. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t Vdatreftune0UsbCoreInput                          :2          ; //Bits :[25:26], initial value: 0x1. This register should be left at the default value, See the Synopsys data book for details.
        uint32_t Reserved                                          :5          ; //Bits :[27:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t FselUsbCoreInput                                  :6          ; //Bits :[0:5], initial value: 0x2A. This register should be left at the default value, which selects a 24MHz reference clock. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t RefclkselUsbCoreInput                             :2          ; //Bits :[6:7], initial value: 0x2. This register should be left at the default value, which selects the external reference clock for both the HS and SS functions. The DS5 has 24MHz signal appliesd the the external reference clock input. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the external reference clock input on the USB core.
        uint32_t RefClkdiv2UsbCoreInput                            :1          ; //Bits :[8:8], initial value: 0x0. This register should be left at the default value, which specifies that the reference clock is not divided, as required for the 24MHz reference clock used in the DS5. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t SscRefClkSelUsbCoreInput                          :9          ; //Bits :[9:17], initial value: 0x108. This register should be left at the default value, which is the Spread Spectrum Reference Clock Shifting value for a 24MHz reference clock. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t MpllMultiplierUsbCoreInput                        :7          ; //Bits :[18:24], initial value: 0x68. This register should be left at the default value, which the PLL multiplier needs for a 24MHz reference clock input. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t Vdatreftune0UsbCoreInput                          :2          ; //Bits :[25:26], initial value: 0x1. This register should be left at the default value, See the Synopsys data book for details.
        uint32_t Reserved                                          :5          ; //Bits :[27:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t FselUsbCoreInput                                  :6          ; //Bits :[0:5], initial value: 0x2A. This register should be left at the default value, which selects a 24MHz reference clock. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t RefclkselUsbCoreInput                             :2          ; //Bits :[6:7], initial value: 0x2. This register should be left at the default value, which selects the external reference clock for both the HS and SS functions. The DS5 has 24MHz signal appliesd the the external reference clock input. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the external reference clock input on the USB core.
        uint32_t RefClkdiv2UsbCoreInput                            :1          ; //Bits :[8:8], initial value: 0x0. This register should be left at the default value, which specifies that the reference clock is not divided, as required for the 24MHz reference clock used in the DS5. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t SscRefClkSelUsbCoreInput                          :9          ; //Bits :[9:17], initial value: 0x108. This register should be left at the default value, which is the Spread Spectrum Reference Clock Shifting value for a 24MHz reference clock. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t MpllMultiplierUsbCoreInput                        :7          ; //Bits :[18:24], initial value: 0x68. This register should be left at the default value, which the PLL multiplier needs for a 24MHz reference clock input. This register is intended to be used if there ia a problem in supplying the 24MHz clock to the reference clock input on the USB core.
        uint32_t Vdatreftune0UsbCoreInput                          :2          ; //Bits :[25:26], initial value: 0x1. This register should be left at the default value, See the Synopsys data book for details.
        uint32_t Reserved                                          :5          ; //Bits :[27:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbFrequencySelect, TRegUsbFrequencySelect, *PTRegUsbFrequencySelect;                                //0x1707C

//Adjusts the frame length for Isochronous mode. Not normally used for the DS5. Leave at 0.  See the USB Controller
//data book for details.
//initial value: 0x0
typedef union __RegUsbFrameLengthAdjustment{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t FrameLengthAdjustment                             :6          ; //Bits :[0:5], initial value: 0x0. Leave at zero. Provided for debug only.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t FrameLengthAdjustment                             :6          ; //Bits :[0:5], initial value: 0x0. Leave at zero. Provided for debug only.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t FrameLengthAdjustment                             :6          ; //Bits :[0:5], initial value: 0x0. Leave at zero. Provided for debug only.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbFrameLengthAdjustment, TRegUsbFrameLengthAdjustment, *PTRegUsbFrameLengthAdjustment;                                //0x17080

//Reserved Register for the USB 3.0 PHY. Not normally used for the DS5. Leave at the default value.  See the USB
// PHY data book for details or consult your Synopsys Application Engineer.
//initial value: 0x0
typedef union __RegUsbLane0TxTermOffset{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Lane0TxTermOffset                                 :5          ; //Bits :[0:4], initial value: 0x0. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t Lane0TxTermOffset                                 :5          ; //Bits :[0:4], initial value: 0x0. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t Lane0TxTermOffset                                 :5          ; //Bits :[0:4], initial value: 0x0. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbLane0TxTermOffset, TRegUsbLane0TxTermOffset, *PTRegUsbLane0TxTermOffset;                                //0x17088

//Reserved Register for the USB 3.0 PHY. Not normally used for the DS5. Leave at the default value.  See the USB
// PHY data book for details or consult your Synopsys Application Engineer.
//initial value: 0x9
typedef union __RegUsbLosLevel{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LosLevelForPhy                                    :5          ; //Bits :[0:4], initial value: 0x9. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t LosLevelForPhy                                    :5          ; //Bits :[0:4], initial value: 0x9. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t LosLevelForPhy                                    :5          ; //Bits :[0:4], initial value: 0x9. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbLosLevel, TRegUsbLosLevel, *PTRegUsbLosLevel;                                //0x1708C

//Reserved Register for the USB 3.0 PHY. Not normally used for the DS5. Leave at the default value.  See the USB
// PHY data book for details or consult your Synopsys Application Engineer.
//initial value: 0x0
typedef union __RegUsbMpllRefsscClkEn{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MpllReferenceSpreadSpectrumClockEnable            :1          ; //Bits :[0:0], initial value: 0x0. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t MpllReferenceSpreadSpectrumClockEnable            :1          ; //Bits :[0:0], initial value: 0x0. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t MpllReferenceSpreadSpectrumClockEnable            :1          ; //Bits :[0:0], initial value: 0x0. Leave at default value. Provided for PHY debug and test only.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbMpllRefsscClkEn, TRegUsbMpllRefsscClkEn, *PTRegUsbMpllRefsscClkEn;                                //0x17090

//Ref clock source select. If set to 1, refclk should be driven from external pad. Normal function should keep this
//bit to 0
//initial value: 0x0
typedef union __RegUsbUsbRefclkSel{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RefclkSel                                         :1          ; //Bits :[0:0], initial value: 0x0. Leave at default value. Provided for PHY debug only.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_read;
    struct {
        uint32_t RefclkSel                                         :1          ; //Bits :[0:0], initial value: 0x0. Leave at default value. Provided for PHY debug only.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_write;
    struct {
        uint32_t RefclkSel                                         :1          ; //Bits :[0:0], initial value: 0x0. Leave at default value. Provided for PHY debug only.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's:
     } fields_rmw; //for non-shadowed register
} RegUsbUsbRefclkSel, TRegUsbUsbRefclkSel, *PTRegUsbUsbRefclkSel;                                //0x17094

//##############################################################
//                      vdf_registers area
//##############################################################
//Enables for the three video endpoints. Each of the three video endpoints has an individual enable in this control
//register.  De-asserting an endpoint enable bit has the same effect on that endpoint as the hardware or software
//reset. When an endpoint enable bit is de-asserted, the buffer and internal controls associated with that endpoint
//are held static and the read and write pointers are cleared, effectively dumping the data in the buffer. When an
//endpoint is enabled by asserting the endpoint enable bit, if valid data is present the FIFO will begin to fill
// after the first SOF is detected. The hardware and software resets must also be de-asserted for the buffer to fill.
//                        On hardware or software reset, the endpoints are disabled and must be enabled by the LCP
//before data can be accessed from an endpoint.
//initial value: 0x0
typedef union __RegVdfVideoEndpointDataEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthDataEnable                                   :1          ; //Bits :[0:0], initial value: 0x0. 1= Depth Endpoint enabled, 0 = disabled and held in reset
        uint32_t LyryDataEnable                                    :1          ; //Bits :[1:1], initial value: 0x0. 1= LYRY Endpoint enabled, 0 = disabled and held in reset
        uint32_t WebcamDataEnable                                  :1          ; //Bits :[2:2], initial value: 0x0. 1= WebCam Endpoint enabled, 0 = disabled and held in reset
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthDataEnable                                   :1          ; //Bits :[0:0], initial value: 0x0. 1= Depth Endpoint enabled, 0 = disabled and held in reset
        uint32_t LyryDataEnable                                    :1          ; //Bits :[1:1], initial value: 0x0. 1= LYRY Endpoint enabled, 0 = disabled and held in reset
        uint32_t WebcamDataEnable                                  :1          ; //Bits :[2:2], initial value: 0x0. 1= WebCam Endpoint enabled, 0 = disabled and held in reset
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthDataEnable                                   :1          ; //Bits :[0:0], initial value: 0x0. 1= Depth Endpoint enabled, 0 = disabled and held in reset
        uint32_t LyryDataEnable                                    :1          ; //Bits :[1:1], initial value: 0x0. 1= LYRY Endpoint enabled, 0 = disabled and held in reset
        uint32_t WebcamDataEnable                                  :1          ; //Bits :[2:2], initial value: 0x0. 1= WebCam Endpoint enabled, 0 = disabled and held in reset
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVideoEndpointDataEnable, TRegVdfVideoEndpointDataEnable, *PTRegVdfVideoEndpointDataEnable;                                //0x16000

//The left and right 'y' data can be either 10 or 12 bits entering the VDF module. When 10-bit data is received,
// it is in bits 11:2 on the 12-bit input bus. When this register bit is de-asserted (zero) the data packers receive
//10-bit y-data, with the upper 10 bits of the data sent to the packers, right shifted two bits, and the two upper
//bits padded to zeros. When the bit is asserted ('1'), the 12 bits of y data is sent to the packers as received
// in the VDF. Currently there are no imagers that provide 12 bit data so this should be left '0' in normal operation.
// This register should only be changed if the endpoint is disabled. The 'twelve bit mode' operation only affects
//the data when one of the four 12-bit packing modes for the Y data (left_y12_2_1, right_y12_2_1,  ry12_ly12_1_1,
//ry12_ly12_4_3)  is selected in the 'LYRY Data Packing Mode' CSR. The three 8-bit packing modes for the Y data (left_y8_4_1,
//right_y8_4_1 and ry8_ly8_2_1) always use the most significant 8-bits regardless of whether 10-bit or 12-bit Y data
//is being received.
//initial value: 0x0
typedef union __RegVdfTwelveBitMode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TwelveBitModeEnable                               :1          ; //Bits :[0:0], initial value: 0x0. 1 = 12-bit imager data to VDF module, 0 = 10-bit imager data to VDF.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t TwelveBitModeEnable                               :1          ; //Bits :[0:0], initial value: 0x0. 1 = 12-bit imager data to VDF module, 0 = 10-bit imager data to VDF.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t TwelveBitModeEnable                               :1          ; //Bits :[0:0], initial value: 0x0. 1 = 12-bit imager data to VDF module, 0 = 10-bit imager data to VDF.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfTwelveBitMode, TRegVdfTwelveBitMode, *PTRegVdfTwelveBitMode;                                //0x16004

//Selects one of the two data packing modes for the Depth AKA 'Z' data.  The packing function takes 16-bit z data
//from the SCP and packs it into 32-bit words for transmission to the USB module. The packing mode and the frame
// size determine the format of a frame. This register should only be changed if the endpoint is disabled.
//initial value: 0x0
typedef union __RegVdfDepthDataPackingMode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthDataPackingModeSelect                        :2          ; //Bits :[0:1], initial value: 0x0. '0' = z16_2_1 packing mode selected (two 16-bit z-pixels per 32-bit word), '1' = Compressed Z (Depth) data selected, '2' = Test Data from the LCP
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthDataPackingModeSelect                        :2          ; //Bits :[0:1], initial value: 0x0. '0' = z16_2_1 packing mode selected (two 16-bit z-pixels per 32-bit word), '1' = Compressed Z (Depth) data selected, '2' = Test Data from the LCP
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthDataPackingModeSelect                        :2          ; //Bits :[0:1], initial value: 0x0. '0' = z16_2_1 packing mode selected (two 16-bit z-pixels per 32-bit word), '1' = Compressed Z (Depth) data selected, '2' = Test Data from the LCP
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthDataPackingMode, TRegVdfDepthDataPackingMode, *PTRegVdfDepthDataPackingMode;                                //0x16008

//Selects one of the 18 data sources and data packing modes for the data to be transmitted from the VDF REC buffer.
// The packing function selects the REC color, or the REC luminance data, or one of the two CSI data streams from
//the CAM module and packs it into 32-bit words for transmission to the USB module or the MIPI transmit module. This
//register should only be changed if the endpoint is disabled.
//initial value: 0x00
typedef union __RegVdfLyryDataPackingMode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryDataPackingModeSelect                         :5          ; //Bits :[0:4], initial value: 0x0. :0  (00000b) left_rgb888_4_3 Left 8-bit RGB from the REC (rec_vdf_L_red, rec_vdf_L_grn, rec_vdf_L_blu) packed four 24-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                               :1  (00001b) right_rgb888_4_3  Right 8-bit RGB from the REC (rec_vdf_R_red, rec_vdf_R_grn, rec_vdf_R_blu) packed four 24-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                               :2  (00010b) left_yuv422_2_1   Left 8-bit RGB from the REC (rec_vdf_L_red, rec_vdf_L_grn, rec_vdf_L_blu) packed two 16-bit YUV pixels to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                              :3  (00011b) right_yuv422_2_1  Right 8-bit RGB from the REC (rec_vdf_R_red, rec_vdf_R_grn, rec_vdf_R_blu) packed two 16-bit YUV pixels to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                               :4  (00100b) lr_rgb888_2_3    Left and right 8-bit RGB from the REC packed 2 48-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                                :5  (00101b) lr_yuv422_1_1    Left and right 8-bit RGB from the REC packed one 32-bit YUV pixel (16 bits each, left and right) to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                                       :6  (00110b) left_y8_4_1      Left Y (Luminance) data from the REC (rec_scp_L_y), packed 4 8-bit pixels to a 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                               :7  (00111b) right_y8_4_1 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 8-bit pixels to a 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                               :8  (01000b) left_y12_2_1   Left Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                  :9  (01001b) right_y12_2_1  Right Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                    :10 (01010b) ry12_ly12_1_1  Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                   :11 (01011b) ry12_ly12_4_3  Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 12-bit pixels (2 left, 2 right) to 3 32-bit words. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                   :12 (01100b) ry8_ly8_2_1    Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 8-bit pixels (2 left, 2 right) to one 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                                  :13 (01101b) cam_csi_data_a         csi_a data (cam_vdf_csidata_a) from the CAM. No dinghy, no frame padding, no embedded (AKA 'stowed') frame number.                          :14 (01110b) cam_csi_data_a_padded  csi_a data (cam_vdf_csidata_a) from the CAM. With dinghy and frame padding, no embedded (AKA 'stowed') frame number.                           :15 (01111b) cam_csi_data_a_stowed  csi_a data (cam_vdf_csidata_a) from the CAM. No dinghy, no frame padding, with embedded (AKA 'stowed') frame number.                          :16 (10000b) cam_csi_data_b         csi_b data (cam_vdf_csidata_b) from the CAM. No dinghy, no frame padding, no embedded (AKA 'stowed') frame number.                            :17 (10001b) cam_csi_data_b_padded  csi_b data (cam_vdf_csidata_b) from the CAM. With dinghy and frame padding, no embedded (AKA 'stowed') frame number.                          :18 (10010b) cam_csi_data_b_stowed  csi_b data (cam_vdf_csidata_b) from the CAM. No dinghy, no frame padding, with embedded (AKA 'stowed') frame number.                          :19 (10011b) The CSR Test Registers are used to emulate a pixel stream. See the desciption for the Test Data and Test Framing CSR's                        :20 (10011b) ry12_8_3 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 8 12-bit pixels in to three dwords,                         :21 (10011b) ly12_8_3 Left Y (Luminance) data from the REC (rec_scp_L_y), packed 8 12-bit pixels in to three dwords,                        :22 (10011b) ly10_16_5 Left Y (Luminance) data from the REC (rec_scp_L_y), packed 16 10-bit pixels in to five dwords.                        :23 (10011b) ry10_16_5 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 16 10-bit pixels in to five dwords.                        :24 (10011b) ly10_ry10_8_5 Left and Right Y (Luminance) data from the REC (rec_scp_R_y, rec_scp_L_y), packed 16 (8 left, 8 right) 10-bit pixels in to five dwords.                        :25-31 (11001) - 11111) - Do not use - indeterminate results.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryDataPackingModeSelect                         :5          ; //Bits :[0:4], initial value: 0x0. :0  (00000b) left_rgb888_4_3 Left 8-bit RGB from the REC (rec_vdf_L_red, rec_vdf_L_grn, rec_vdf_L_blu) packed four 24-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                               :1  (00001b) right_rgb888_4_3  Right 8-bit RGB from the REC (rec_vdf_R_red, rec_vdf_R_grn, rec_vdf_R_blu) packed four 24-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                               :2  (00010b) left_yuv422_2_1   Left 8-bit RGB from the REC (rec_vdf_L_red, rec_vdf_L_grn, rec_vdf_L_blu) packed two 16-bit YUV pixels to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                              :3  (00011b) right_yuv422_2_1  Right 8-bit RGB from the REC (rec_vdf_R_red, rec_vdf_R_grn, rec_vdf_R_blu) packed two 16-bit YUV pixels to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                               :4  (00100b) lr_rgb888_2_3    Left and right 8-bit RGB from the REC packed 2 48-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                                :5  (00101b) lr_yuv422_1_1    Left and right 8-bit RGB from the REC packed one 32-bit YUV pixel (16 bits each, left and right) to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                                       :6  (00110b) left_y8_4_1      Left Y (Luminance) data from the REC (rec_scp_L_y), packed 4 8-bit pixels to a 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                               :7  (00111b) right_y8_4_1 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 8-bit pixels to a 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                               :8  (01000b) left_y12_2_1   Left Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                  :9  (01001b) right_y12_2_1  Right Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                    :10 (01010b) ry12_ly12_1_1  Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                   :11 (01011b) ry12_ly12_4_3  Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 12-bit pixels (2 left, 2 right) to 3 32-bit words. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                   :12 (01100b) ry8_ly8_2_1    Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 8-bit pixels (2 left, 2 right) to one 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                                  :13 (01101b) cam_csi_data_a         csi_a data (cam_vdf_csidata_a) from the CAM. No dinghy, no frame padding, no embedded (AKA 'stowed') frame number.                          :14 (01110b) cam_csi_data_a_padded  csi_a data (cam_vdf_csidata_a) from the CAM. With dinghy and frame padding, no embedded (AKA 'stowed') frame number.                           :15 (01111b) cam_csi_data_a_stowed  csi_a data (cam_vdf_csidata_a) from the CAM. No dinghy, no frame padding, with embedded (AKA 'stowed') frame number.                          :16 (10000b) cam_csi_data_b         csi_b data (cam_vdf_csidata_b) from the CAM. No dinghy, no frame padding, no embedded (AKA 'stowed') frame number.                            :17 (10001b) cam_csi_data_b_padded  csi_b data (cam_vdf_csidata_b) from the CAM. With dinghy and frame padding, no embedded (AKA 'stowed') frame number.                          :18 (10010b) cam_csi_data_b_stowed  csi_b data (cam_vdf_csidata_b) from the CAM. No dinghy, no frame padding, with embedded (AKA 'stowed') frame number.                          :19 (10011b) The CSR Test Registers are used to emulate a pixel stream. See the desciption for the Test Data and Test Framing CSR's                        :20 (10011b) ry12_8_3 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 8 12-bit pixels in to three dwords,                         :21 (10011b) ly12_8_3 Left Y (Luminance) data from the REC (rec_scp_L_y), packed 8 12-bit pixels in to three dwords,                        :22 (10011b) ly10_16_5 Left Y (Luminance) data from the REC (rec_scp_L_y), packed 16 10-bit pixels in to five dwords.                        :23 (10011b) ry10_16_5 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 16 10-bit pixels in to five dwords.                        :24 (10011b) ly10_ry10_8_5 Left and Right Y (Luminance) data from the REC (rec_scp_R_y, rec_scp_L_y), packed 16 (8 left, 8 right) 10-bit pixels in to five dwords.                        :25-31 (11001) - 11111) - Do not use - indeterminate results.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryDataPackingModeSelect                         :5          ; //Bits :[0:4], initial value: 0x0. :0  (00000b) left_rgb888_4_3 Left 8-bit RGB from the REC (rec_vdf_L_red, rec_vdf_L_grn, rec_vdf_L_blu) packed four 24-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                               :1  (00001b) right_rgb888_4_3  Right 8-bit RGB from the REC (rec_vdf_R_red, rec_vdf_R_grn, rec_vdf_R_blu) packed four 24-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                               :2  (00010b) left_yuv422_2_1   Left 8-bit RGB from the REC (rec_vdf_L_red, rec_vdf_L_grn, rec_vdf_L_blu) packed two 16-bit YUV pixels to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                              :3  (00011b) right_yuv422_2_1  Right 8-bit RGB from the REC (rec_vdf_R_red, rec_vdf_R_grn, rec_vdf_R_blu) packed two 16-bit YUV pixels to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                               :4  (00100b) lr_rgb888_2_3    Left and right 8-bit RGB from the REC packed 2 48-bit pixels into three 32-bit words. Note the REC must be configured for RGB output to use this mode.                                :5  (00101b) lr_yuv422_1_1    Left and right 8-bit RGB from the REC packed one 32-bit YUV pixel (16 bits each, left and right) to one 32-bit dword. Note the REC must be configured for YUV output to use this mode.                                       :6  (00110b) left_y8_4_1      Left Y (Luminance) data from the REC (rec_scp_L_y), packed 4 8-bit pixels to a 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                               :7  (00111b) right_y8_4_1 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 8-bit pixels to a 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                               :8  (01000b) left_y12_2_1   Left Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                  :9  (01001b) right_y12_2_1  Right Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                    :10 (01010b) ry12_ly12_1_1  Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 2 12-bit pixels to a 32-bit word, padded with zeros. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                   :11 (01011b) ry12_ly12_4_3  Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 12-bit pixels (2 left, 2 right) to 3 32-bit words. The TWELVE_BIT_MODE CSR will affect how the 12 input bits in the Y data are packed.                                   :12 (01100b) ry8_ly8_2_1    Left and Right Y (Luminance) data from the REC (rec_scp_R_y), packed 4 8-bit pixels (2 left, 2 right) to one 32-bit word. The most significant 8-bits of the 12-bit Y input is packed, regardless of whether 10-bit or 12-bit Y data is being received, or the state of the TWELVE_BIT_MODE CSR.                                  :13 (01101b) cam_csi_data_a         csi_a data (cam_vdf_csidata_a) from the CAM. No dinghy, no frame padding, no embedded (AKA 'stowed') frame number.                          :14 (01110b) cam_csi_data_a_padded  csi_a data (cam_vdf_csidata_a) from the CAM. With dinghy and frame padding, no embedded (AKA 'stowed') frame number.                           :15 (01111b) cam_csi_data_a_stowed  csi_a data (cam_vdf_csidata_a) from the CAM. No dinghy, no frame padding, with embedded (AKA 'stowed') frame number.                          :16 (10000b) cam_csi_data_b         csi_b data (cam_vdf_csidata_b) from the CAM. No dinghy, no frame padding, no embedded (AKA 'stowed') frame number.                            :17 (10001b) cam_csi_data_b_padded  csi_b data (cam_vdf_csidata_b) from the CAM. With dinghy and frame padding, no embedded (AKA 'stowed') frame number.                          :18 (10010b) cam_csi_data_b_stowed  csi_b data (cam_vdf_csidata_b) from the CAM. No dinghy, no frame padding, with embedded (AKA 'stowed') frame number.                          :19 (10011b) The CSR Test Registers are used to emulate a pixel stream. See the desciption for the Test Data and Test Framing CSR's                        :20 (10011b) ry12_8_3 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 8 12-bit pixels in to three dwords,                         :21 (10011b) ly12_8_3 Left Y (Luminance) data from the REC (rec_scp_L_y), packed 8 12-bit pixels in to three dwords,                        :22 (10011b) ly10_16_5 Left Y (Luminance) data from the REC (rec_scp_L_y), packed 16 10-bit pixels in to five dwords.                        :23 (10011b) ry10_16_5 Right Y (Luminance) data from the REC (rec_scp_R_y), packed 16 10-bit pixels in to five dwords.                        :24 (10011b) ly10_ry10_8_5 Left and Right Y (Luminance) data from the REC (rec_scp_R_y, rec_scp_L_y), packed 16 (8 left, 8 right) 10-bit pixels in to five dwords.                        :25-31 (11001) - 11111) - Do not use - indeterminate results.
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryDataPackingMode, TRegVdfLyryDataPackingMode, *PTRegVdfLyryDataPackingMode;                                //0x1600C

//The 16-bit depth data from the SCP is packed into 32-bit word in the VDF. The packed 32-bit word can be big-endian
//or little-endian. The normal usage is little-endian.  The endianess refers to the 16-bit word in the dword, not
//the bytes within the word . For example, if two successive 16-bit words are received by the VDF from the SCP,
// e.g. 0x1234 followed by 0x6789, and z16_2_1 packing mode is selected, then the little-endian 32-bit word is 0x6789_1234,
//the big-endian 32-bit word is 0x1234_6789. This feature should not be used when compressed depth data is being
// sent. This register should only be changed if the endpoint is disabled.
//initial value: 0x0
typedef union __RegVdfDepthDataEndianSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthDataEndianSelect                             :1          ; //Bits :[0:0], initial value: 0x0. Bit 0 = 0, Little Endian Mode (Normal), Bit 0 = 1, Big Endian Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthDataEndianSelect                             :1          ; //Bits :[0:0], initial value: 0x0. Bit 0 = 0, Little Endian Mode (Normal), Bit 0 = 1, Big Endian Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthDataEndianSelect                             :1          ; //Bits :[0:0], initial value: 0x0. Bit 0 = 0, Little Endian Mode (Normal), Bit 0 = 1, Big Endian Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthDataEndianSelect, TRegVdfDepthDataEndianSelect, *PTRegVdfDepthDataEndianSelect;                                //0x16010

//The 16-bit LYRY data from the SCP is packed into 32-bit word in the VDF. The packed 32-bit word can be big-endian
//or little-endian. The normal usage is little-endian.  The endianess refers to the 16-bit word in the dword, not
//the bytes within the word . For example, if two successive 16-bit LYRY words are received by the VDF from the SCP,
// e.g. 0x1234 followed by 0x6789, and z16_2_1 packing mode is selected, then the little-endian 32-bit word is 0x6789_1234,
//the big-endian 32-bit word is 0x1234_6789. This register should only be changed if the endpoint is disabled.
//initial value: 0x0
typedef union __RegVdfLyryDataEndianSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryDataEndianSelect                              :1          ; //Bits :[0:0], initial value: 0x0. Bit 0 = 0, Little Endian Mode (Normal), Bit 0 = 1, Big Endian Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryDataEndianSelect                              :1          ; //Bits :[0:0], initial value: 0x0. Bit 0 = 0, Little Endian Mode (Normal), Bit 0 = 1, Big Endian Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryDataEndianSelect                              :1          ; //Bits :[0:0], initial value: 0x0. Bit 0 = 0, Little Endian Mode (Normal), Bit 0 = 1, Big Endian Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryDataEndianSelect, TRegVdfLyryDataEndianSelect, *PTRegVdfLyryDataEndianSelect;                                //0x16014

//This read-only register returns the current value of the z-data dword write pointer.  The pointer references a
// 32-bit dword. This pointer, along with the address of the most recently acknowledged TD (USB Transfer Descriptor)
//allows the amount of data in the buffer to be calculated, to decide whether to allow the USB core to begin processing
//another TD. After a hardware or a software reset, or the de-assertion of the endpoint enable bit, the pointer will
//reset to zero, effectively flushing the buffer.
//initial value: 0x0000
typedef union __RegVdfDepthDataBufferWriteAddress{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthDataBufferWritePointer                       :14         ; //Bits :[0:13], initial value: 0x0. Address of the next 32-bit dword to be written into the Depth Data Buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthDataBufferWritePointer                       :14         ; //Bits :[0:13], initial value: 0x0. Address of the next 32-bit dword to be written into the Depth Data Buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthDataBufferWriteAddress, TRegVdfDepthDataBufferWriteAddress, *PTRegVdfDepthDataBufferWriteAddress;                                //0x16018

//This read-only register returns the current value of the y-data dword write pointer.  The pointer references a
// 32-bit dword in the 64KB buffer for the LYRY Data in the VDF module. This pointer, along with the address of the
//most recently acknowledged TD (USB Transfer Descriptor) allows the amount of data in the buffer to be calculated,
//to decide whether to allow the USB core to begin processing another TD. After a hardware or a software reset, or
//the de-assertion of the endpoint enable bit, the pointer will reset to zero, effectively flushing the buffer.
//initial value: 0x0000
typedef union __RegVdfLyryDataBufferWriteAddress{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryDataBufferWritePointer                        :14         ; //Bits :[0:13], initial value: 0x0.  14-bit address of the next 32-bit dword to be written into the LYRY Data Buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryDataBufferWritePointer                        :14         ; //Bits :[0:13], initial value: 0x0.  14-bit address of the next 32-bit dword to be written into the LYRY Data Buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryDataBufferWriteAddress, TRegVdfLyryDataBufferWriteAddress, *PTRegVdfLyryDataBufferWriteAddress;                                //0x1601C

//This read-only register returns the current value of the c-data dword write pointer.  The pointer references a
// 32-bit dword in the 64KB buffer for the WebCam Data in the VDF module. This pointer, along with the address of
//the most recently acknowledged TD (USB Transfer Descriptor) allows the amount of data in the buffer to be calculated,
//to decide whether to allow the USB core to begin processing another TD. After a hardware or a software reset, or
//the de-assertion of the endpoint enable bit, the pointer will reset to zero, effectively flushing the buffer.
//initial value: 0x0000
typedef union __RegVdfWebcamDataBufferWriteAddress{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamDataBufferWritePointer                      :14         ; //Bits :[0:13], initial value: 0x0. Address of the next 32-bit dword to be written into the WebCam Data Buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamDataBufferWritePointer                      :14         ; //Bits :[0:13], initial value: 0x0. Address of the next 32-bit dword to be written into the WebCam Data Buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamDataBufferWriteAddress, TRegVdfWebcamDataBufferWriteAddress, *PTRegVdfWebcamDataBufferWriteAddress;                                //0x16020

//This is the number of 32-bit words that must be added to the depth frame to pad the added video line containing
//the dinghy out to the length of the line used for the video data. The LCP calculates this number based on the packing
//mode selected (which determines the bytes per pixel) and the pixel width of the frame in the selected format, and
//the length of the dinghy. This register must be written before the depth endpoint is enabled. The calculation required
//is ((bytes per pixel)*(pixel width))/4 - dinghy length. The width of a line in the DS4 is restricted to be a multiple
//of 4 bytes regardless of the data type selected. . The frame padding should not exceed the number of dwords in
// a line of pixels in the current packing mode. This register must be setup in both MIPI and USB 3.0 mode. In MIPI
//mode, the padded zeros are added to the MIPI packet containing the dinghy. This register should only be changed
//if the endpoint is disabled.
//initial value: 0x0
typedef union __RegVdfDepthFramePadLength{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthFramePadLength                               :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the depth frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthFramePadLength                               :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the depth frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthFramePadLength                               :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the depth frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthFramePadLength, TRegVdfDepthFramePadLength, *PTRegVdfDepthFramePadLength;                                //0x16024

//This is the number of 32-bit words that must be added to the lyry frame to pad the added video line contain the
//dinghy. The LCP calculates this number based on the packing mode selected (which determines the bytes per pixel)
//and the pixel width of the frame in the selected format, and the length of the dinghy. This register must be written
//before the lyry endpoint is enabled. The calculation required is ((bytes per pixel)*(pixel width))/4 - dinghy length.
//The width of a line in the DS4 is restricted to be a multiple of 4 bytes regardless of the data type selected.
// The frame padding should not exceed the number of dwords in a line of pixels in the current packing mode. This
//register should only be changed if the endpoint is disabled.
//initial value: 0x0
typedef union __RegVdfLyryFramePadLength{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryFramePadLength                                :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the LYRY frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryFramePadLength                                :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the LYRY frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryFramePadLength                                :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the LYRY frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryFramePadLength, TRegVdfLyryFramePadLength, *PTRegVdfLyryFramePadLength;                                //0x16028

//This is the number of 32-bit words that must be added to the webcam frame to pad the added video line contain the
//dinghy. The LCP calculates this number based on the packing mode selected (which determines the bytes per pixel)
//and the pixel width of the frame in the selected format, and the length of the dinghy. This register must be written
//before the webcam endpoint is enabled. The calculation required is ((bytes per pixel)*(pixel width))/4 - dinghy
//length. . The frame padding should not exceed the number of dwords in a line of pixels in the current packing mode.
//The width of a line in the DS4 is restricted to be a multiple of 4 bytes regardless of the data type selected.
// This register should only be changed if the endpoint is disabled.
//initial value: 0x0
typedef union __RegVdfWebcamFramePadLength{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamFramePadLength                              :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the webcam frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamFramePadLength                              :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the webcam frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamFramePadLength                              :13         ; //Bits :[0:12], initial value: 0x0. Contains a 13-bit binary number representing the number of 32-bit words needed to pad the extra line in the webcam frame line containing the dinghy.
        uint32_t Reserved                                          :19         ; //Bits :[13:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamFramePadLength, TRegVdfWebcamFramePadLength, *PTRegVdfWebcamFramePadLength;                                //0x1602C

//The bmheaderinfo feild in the UVC header for the Depth buffer is set by this register. See the USB UVC specification
//for the definition of the bits in this field. The upper 7 bits are sent in the UVC header but the lsb in this register
//is ignored and replaced by the H/W generated Frame ID bit in the VDF when sent in the header. Thisis done so the
//bit indexes in the field match the bit indexes in the specification. The default value is the same as used in the
//DS5-A0.
//initial value: 0x8C
typedef union __RegVdfDepthEp2UvcHeaderBmheaderinfo{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferUvcHeaderBmheaderinfo                  :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the Depth EP2 buffer.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferUvcHeaderBmheaderinfo                  :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the Depth EP2 buffer.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferUvcHeaderBmheaderinfo                  :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the Depth EP2 buffer.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthEp2UvcHeaderBmheaderinfo, TRegVdfDepthEp2UvcHeaderBmheaderinfo, *PTRegVdfDepthEp2UvcHeaderBmheaderinfo;                                //0x16030

//The bmheaderinfo feild in the UVC header for the LYRY buffer is set by this register. See the USB UVC specification
//for the definition of the bits in this field. The upper 7 bits are sent in the UVC header but the lsb in this register
//is ignored and replaced by the H/W generated Frame ID bit in the VDF when sent in the header. Thisis done so the
//bit indexes in the field match the bit indexes in the specification. The default value is the same as used in the
//DS5-A0.
//initial value: 0x8C
typedef union __RegVdfLyryEp3UvcHeaderBmheaderinfo{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryDataUvcHeaderBmheaderinfo                     :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the LYRY EP3 buffer.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryDataUvcHeaderBmheaderinfo                     :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the LYRY EP3 buffer.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryDataUvcHeaderBmheaderinfo                     :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the LYRY EP3 buffer.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryEp3UvcHeaderBmheaderinfo, TRegVdfLyryEp3UvcHeaderBmheaderinfo, *PTRegVdfLyryEp3UvcHeaderBmheaderinfo;                                //0x16034

//The bmheaderinfo feild in the UVC header for the WebCam buffer is set by this register. See the USB UVC specification
//for the definition of the bits in this field. The upper 7 bits are sent in the UVC header but the lsb in this register
//is ignored and replaced by the H/W generated Frame ID bit in the VDF when sent in the header. Thisis done so the
//bit indexes in the field match the bit indexes in the specification. The default value is the same as used in the
//DS5-A0.
//initial value: 0x8C
typedef union __RegVdfWebcamEp4UvcHeaderBmheaderinfo{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamDataUvcHeaderBmheaderinfo                   :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the Webcam EP4 buffer
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamDataUvcHeaderBmheaderinfo                   :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the Webcam EP4 buffer
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamDataUvcHeaderBmheaderinfo                   :8          ; //Bits :[0:7], initial value: 0x8C. bmHeaderInfo field for the Webcam EP4 buffer
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamEp4UvcHeaderBmheaderinfo, TRegVdfWebcamEp4UvcHeaderBmheaderinfo, *PTRegVdfWebcamEp4UvcHeaderBmheaderinfo;                                //0x16038

//When the depth buffer write pointer reaches the value in this register, an interrupt to the LCP is asserted on
// the vdf_csr_zbuff_thresh_intr signal. The register references a 32-bit dword in the 64KB buffer. The initial value
//points to the top of the buffer, the last dword in the buffer. In USB 3.0 mode, this feature is used by the LCP
//to monitor the amount of data in the buffer.
//initial value: 0x3FFF
typedef union __RegVdfDepthBufferInterruptThreshold{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferInterruptThreshold                     :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit dword address in the Depth Buffer that will cause an interrupt to the LCP when the write pointer for the depth buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferInterruptThreshold                     :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit dword address in the Depth Buffer that will cause an interrupt to the LCP when the write pointer for the depth buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferInterruptThreshold                     :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit dword address in the Depth Buffer that will cause an interrupt to the LCP when the write pointer for the depth buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferInterruptThreshold, TRegVdfDepthBufferInterruptThreshold, *PTRegVdfDepthBufferInterruptThreshold;                                //0x1603C

//In USB 3.0 mode, when the depth buffer write pointer reaches the value in this register, an interrupt to the LCP
//is asserted on the vdf_csr_zbuff_dma_overflow_intr signal. The register references a 32-bit dword in the 64KB buffer.
//The initial value points to the top of the buffer, the last dword in the buffer. In USB 3.0 mode, this feature
// is used by the LCP to monitor an overflow of the depth buffer by writing the lowest dword address of the last
// block of data sent to the USB core in a TD that has not been acknowledged as being received by the host. When
// that block of data has been transmitted on the USB bus and has been acknowledged by the host, the LCP changes
// the address of this register to the next block of unacknowledged data. The LCP should set this to an appropriate
//value before enabling the endpoint. In MIPI mode, the value in this register is ignored and a different mechanism
//is used to generate the vdf_csr_zbuff_dma_overflow_intr signal.
//initial value: 0x3FFF
typedef union __RegVdfDepthBufferDmaPointer{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferDmaPointer                             :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the Depth Buffer will cause a 'halt' to the SCP when reached by the Depth Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferDmaPointer                             :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the Depth Buffer will cause a 'halt' to the SCP when reached by the Depth Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferDmaPointer                             :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the Depth Buffer will cause a 'halt' to the SCP when reached by the Depth Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferDmaPointer, TRegVdfDepthBufferDmaPointer, *PTRegVdfDepthBufferDmaPointer;                                //0x16040

//When the VDF's LYRY buffer write pointer reaches the value in this register, an interrupt to the LCP is asserted
//on the vdf_csr_ybuff_thresh_intr signal. The register references a 32-bit dword in the 64KB buffer. The initial
//value points to the top of the buffer, the last dword in the buffer. In USB 3.0 mode, this feature is used by the
//LCP to monitor the amount of data in the LYRY buffer.
//initial value: 0x3FFF
typedef union __RegVdfLyryBufferInterruptThreshold{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferInterruptThreshold                      :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the LYRY Buffer that will cause an interrupt to the LCP when the write pointer for the LYRY buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferInterruptThreshold                      :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the LYRY Buffer that will cause an interrupt to the LCP when the write pointer for the LYRY buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferInterruptThreshold                      :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the LYRY Buffer that will cause an interrupt to the LCP when the write pointer for the LYRY buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryBufferInterruptThreshold, TRegVdfLyryBufferInterruptThreshold, *PTRegVdfLyryBufferInterruptThreshold;                                //0x16044

//In USB 3.0 mode, when the LYRY buffer write pointer reaches the value in this register, an interrupt to the LCP
//is asserted on the vdf_csr_ybuff_dma_overflow_intr signal. The register references a 32-bit dword in the 64KB buffer.
//The initial value points to the top of the buffer, the last dword in the buffer. In USB 3.0 mode, this feature
// is used by the LCP to monitor an overflow of the LYRY buffer by writing the lowest dword address of the last block
//of data sent to the USB core in a TD that has not been acknowledged as being received by the host. When that block
//of data has been transmitted on the USB bus and has been acknowledged by the host, the LCP changes the address
// of this register to the next block of unacknowledged data. The LCP should set this to an appropriate value before
//enabling the endpoint. In MIPI mode, the value in this register is ignored and a different mechanism is used to
//generate the vdf_csr_ybuff_dma_overflow_intr signal.
//initial value: 0x3FFF
typedef union __RegVdfLyryBufferDmaPointer{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferDmaPointer                              :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the LYRY Buffer will cause a 'halt' to the SCP when reached by the LYRY Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferDmaPointer                              :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the LYRY Buffer will cause a 'halt' to the SCP when reached by the LYRY Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferDmaPointer                              :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the LYRY Buffer will cause a 'halt' to the SCP when reached by the LYRY Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryBufferDmaPointer, TRegVdfLyryBufferDmaPointer, *PTRegVdfLyryBufferDmaPointer;                                //0x16048

//When the VDF's CAM buffer write pointer reaches the value in this register, an interrupt to the LCP is asserted
//on the vdf_csr_cbuff_thresh_intr signal. The register references a 32-bit dword in the 64KB buffer. The initial
//value points to the top of the buffer, the last dword in the buffer. In USB 3.0 mode, this feature is used by the
//LCP to monitor the amount of data in the CAM buffer.
//initial value: 0x3FFF
typedef union __RegVdfWebcamBufferInterruptThreshold{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferInterruptThreshold                    :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the WebCam Buffer that will cause an interrupt to the LCP when the write pointer for the WebCam buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamBufferInterruptThreshold                    :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the WebCam Buffer that will cause an interrupt to the LCP when the write pointer for the WebCam buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamBufferInterruptThreshold                    :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the WebCam Buffer that will cause an interrupt to the LCP when the write pointer for the WebCam buffer reaches it
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamBufferInterruptThreshold, TRegVdfWebcamBufferInterruptThreshold, *PTRegVdfWebcamBufferInterruptThreshold;                                //0x1604C

//In USB 3.0 mode, when the CAM buffer write pointer reaches the value in this register, an interrupt to the LCP
// is asserted on the vdf_csr_cbuff_dma_overflow_intr signal. The register references a 32-bit dword in the 64KB
// buffer. The initial value points to the top of the buffer, the last dword in the buffer. In USB 3.0 mode, this
//feature is used by the LCP to monitor an overflow of the CAM buffer by writing the lowest dword address of the
// last block of data sent to the USB core in a TD that has not been acknowledged as being received by the host.
// When that block of data has been transmitted on the USB bus and has been acknowledged by the host, the LCP changes
//the address of this register to the next block of unacknowledged data. The LCP should set this to an appropriate
//value before enabling the endpoint. In MIPI mode, the value in this register is ignored and a different mechanism
//is used to generate the vdf_csr_cbuff_dma_overflow_intr signal.
//initial value: 0x3FFF
typedef union __RegVdfWebcamBufferDmaPointer{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferDmaPointer                            :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the CAM Buffer will cause a 'halt' to the SCP when reached by the CAM Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamBufferDmaPointer                            :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the CAM Buffer will cause a 'halt' to the SCP when reached by the CAM Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamBufferDmaPointer                            :14         ; //Bits :[0:13], initial value: 0x3FFF. 14-bit address in the CAM Buffer will cause a 'halt' to the SCP when reached by the CAM Buffer Write Pointer.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamBufferDmaPointer, TRegVdfWebcamBufferDmaPointer, *PTRegVdfWebcamBufferDmaPointer;                                //0x16050

//Selects one of the three nine for data transmitted from the webcam buffer. Either of the CSI data streams can passed
//through as received, or the dinghy can be appended with frame padding, or the dinghy can be left off, but with
// the frame number from the dinghy packed into the last 16 bit YUY2 pixels in YUY2. Also, the color data from the
//REC can be transmitted through the Webcam buffer. This enables left and right color data to be sent on different
//virtual channels in MIPI operation. This register should only be changed if the endpoint is disabled.
//initial value: 0x0
typedef union __RegVdfWebcamDataMode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebCamDataModeSelect                              :4          ; //Bits :[0:3], initial value: 0x0. '0000' (d0) = CSI Data a, Pass-Through mode: No padding, No Dinghy, No Frame Number Stowaway.           '0001' (d1) = CSI Data a, Calibration Mode: Padding and  Dinghy.            '0010' (d2) = CSI Data a, Stowaway Mode: Frame Number Stowaway, No Padding and Dinghy.                              '0011' (d3) = CSI Data b, Pass-Through mode: No padding, No Dinghy, No Frame Number Stowaway.                       '0100' (d4) = CSI Data b, Calibration Mode: Padding and  Dinghy.                                                    '0101' (d5) = CSI Data b, Stowaway Mode: Frame Number Stowaway, No Padding and Dinghy.                              '0110' (d6) = Left RGB888_4_3 Packing.                       '0111' (d7) = Right RGB888_4_3 Packing.                       '1000' (d8) = Left YUV422 Packing.                       '1001' (d9) = Right YUV422 Packing.                       '1010-1111' (d10-d15) - Do not use - indeterminate output will result.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebCamDataModeSelect                              :4          ; //Bits :[0:3], initial value: 0x0. '0000' (d0) = CSI Data a, Pass-Through mode: No padding, No Dinghy, No Frame Number Stowaway.           '0001' (d1) = CSI Data a, Calibration Mode: Padding and  Dinghy.            '0010' (d2) = CSI Data a, Stowaway Mode: Frame Number Stowaway, No Padding and Dinghy.                              '0011' (d3) = CSI Data b, Pass-Through mode: No padding, No Dinghy, No Frame Number Stowaway.                       '0100' (d4) = CSI Data b, Calibration Mode: Padding and  Dinghy.                                                    '0101' (d5) = CSI Data b, Stowaway Mode: Frame Number Stowaway, No Padding and Dinghy.                              '0110' (d6) = Left RGB888_4_3 Packing.                       '0111' (d7) = Right RGB888_4_3 Packing.                       '1000' (d8) = Left YUV422 Packing.                       '1001' (d9) = Right YUV422 Packing.                       '1010-1111' (d10-d15) - Do not use - indeterminate output will result.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebCamDataModeSelect                              :4          ; //Bits :[0:3], initial value: 0x0. '0000' (d0) = CSI Data a, Pass-Through mode: No padding, No Dinghy, No Frame Number Stowaway.           '0001' (d1) = CSI Data a, Calibration Mode: Padding and  Dinghy.            '0010' (d2) = CSI Data a, Stowaway Mode: Frame Number Stowaway, No Padding and Dinghy.                              '0011' (d3) = CSI Data b, Pass-Through mode: No padding, No Dinghy, No Frame Number Stowaway.                       '0100' (d4) = CSI Data b, Calibration Mode: Padding and  Dinghy.                                                    '0101' (d5) = CSI Data b, Stowaway Mode: Frame Number Stowaway, No Padding and Dinghy.                              '0110' (d6) = Left RGB888_4_3 Packing.                       '0111' (d7) = Right RGB888_4_3 Packing.                       '1000' (d8) = Left YUV422 Packing.                       '1001' (d9) = Right YUV422 Packing.                       '1010-1111' (d10-d15) - Do not use - indeterminate output will result.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamDataMode, TRegVdfWebcamDataMode, *PTRegVdfWebcamDataMode;                                //0x16054

//Controls the response of the AXI Slave and the APB Slave to Reads and Writes to unused areas of the address space
//assigned to the VDF Module in the AXI and APB ranges. On the AXI Slave, when the Slave Error is disabled, all reads
//to unused AXI addresses will return 00000000h, and will give OK_R (00) as a response to the AXI Master, and all
//writes will be accepted and ignored, and OK_W (01) will be given as the response to the AXI Master. When the Slave
//Error is enabled, any read to an unused AXI address will return 00000000h, and will give SLVERR_R (10) as a response
//to the AXI Master, and all AXI writes will be accepted and ignored, and SLVERR_W (11) will be given as the response
//to the AXI Master. On the APB Slave, when the Slave Error is disabled, all reads to unused APB addresses will return
//00000000h, and the VDF will give 0 on the o_vdf_xp2_pslverr_s output, and all APB writes to unused APB addresses
//will be accepted and ignored and the VDF will give 0 on the o_vdf_xp2_pslverr_s output. When the Slave Error is
//enabled, any read to an unused APB address will return 00000000h, and the VDF will give '1' on the o_vdf_xp2_pslverr_s
//output. All writes to unused APB addresses will be accepted, ignored and will give a '1' on the o_vdf_xp2_pslverr_s
//output.  Note: This is an unused and untested feature. No verification testing has been done on this feature. This
//register should not be used in normal operation. It should always be left at its default value of 1, with the slave
//error response disabled. Operation of the DS4 with this register  set to 0 (i.e. slave error enabled) is indeterminate.
//initial value: 0x1
typedef union __RegVdfAxiApbSlaveErrorDisable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AxiApbSlaveErrorDisable                           :1          ; //Bits :[0:0], initial value: 0x1. '0' = AXI-APB Slave Error Enabled.             '1' = AXI-APB Slave Error Disabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t AxiApbSlaveErrorDisable                           :1          ; //Bits :[0:0], initial value: 0x1. '0' = AXI-APB Slave Error Enabled.             '1' = AXI-APB Slave Error Disabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t AxiApbSlaveErrorDisable                           :1          ; //Bits :[0:0], initial value: 0x1. '0' = AXI-APB Slave Error Enabled.             '1' = AXI-APB Slave Error Disabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfAxiApbSlaveErrorDisable, TRegVdfAxiApbSlaveErrorDisable, *PTRegVdfAxiApbSlaveErrorDisable;                                //0x16058

//Enables the traffic generator on the depth (z) endpoint buffer. When the Depth Buffer Traffic Generator  is enabled,
//and the Depth Endpoint Data is disabled (bit 0 Video Endpoint Data Enable register = '0'), the traffic generator
//will respond reads from the depth buffer data address range and UVC Header address range with a value determined
//by the Depth Buffer Traffic Generator Pattern Select CSR. The Depth Buffer Traffic Generator Enable is ignored
// if the Depth Endpoint Data is enabled (bit 0 Video Endpoint Data Enable register = '1'.
//initial value: 0x0
typedef union __RegVdfDepthBufferTrafficGeneratorEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferTrafficGeneratorEnable                 :1          ; //Bits :[0:0], initial value: 0x0. '0' = Depth Buffer Traffic Generator Disabled.             '1' = Depth Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferTrafficGeneratorEnable                 :1          ; //Bits :[0:0], initial value: 0x0. '0' = Depth Buffer Traffic Generator Disabled.             '1' = Depth Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferTrafficGeneratorEnable                 :1          ; //Bits :[0:0], initial value: 0x0. '0' = Depth Buffer Traffic Generator Disabled.             '1' = Depth Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferTrafficGeneratorEnable, TRegVdfDepthBufferTrafficGeneratorEnable, *PTRegVdfDepthBufferTrafficGeneratorEnable;                                //0x1605C

//Selects one of three patterns for the traffic generator for the Depth Buffer, User Word, Ramp Counter or LFSR.
//                   This register should only be changed if the endpoint is disabled.
//initial value: 0x0
typedef union __RegVdfDepthBufferTrafficGeneratorPatternSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferTrafficGeneratorPatternSelect          :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the Depth Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferTrafficGeneratorPatternSelect          :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the Depth Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferTrafficGeneratorPatternSelect          :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the Depth Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferTrafficGeneratorPatternSelect, TRegVdfDepthBufferTrafficGeneratorPatternSelect, *PTRegVdfDepthBufferTrafficGeneratorPatternSelect;                                //0x16060

//This 32-bit word is transmitted when the Depth Buffer Traffic Generator is enabled, and the 'User Word' pattern
//is selected in the Depth Buffer Traffic Generator Pattern Select CSR.
//initial value: 0x0BADFEED
typedef union __RegVdfDepthBufferTrafficGeneratorUserWord{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferTrafficGeneratorUserWord               :32         ; //Bits :[0:31], initial value: 0xBADFEED. 32-bit word is transmitted when the Depth Buffer Traffic Generator is enabled, and the AXI bus is read in the Depth Buffer address range
     } fields_read;
    struct {
        uint32_t DepthBufferTrafficGeneratorUserWord               :32         ; //Bits :[0:31], initial value: 0xBADFEED. 32-bit word is transmitted when the Depth Buffer Traffic Generator is enabled, and the AXI bus is read in the Depth Buffer address range
     } fields_write;
    struct {
        uint32_t DepthBufferTrafficGeneratorUserWord               :32         ; //Bits :[0:31], initial value: 0xBADFEED. 32-bit word is transmitted when the Depth Buffer Traffic Generator is enabled, and the AXI bus is read in the Depth Buffer address range
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferTrafficGeneratorUserWord, TRegVdfDepthBufferTrafficGeneratorUserWord, *PTRegVdfDepthBufferTrafficGeneratorUserWord;                                //0x16064

//Resets the counters used in the Depth Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless
//of the state of the Depth Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR.
//initial value: 0x0
typedef union __RegVdfDepthBufferTrafficGeneratorCounterReset{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferTrafficGeneratorCounterReset           :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the Depth Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the Depth Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the 1 in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferTrafficGeneratorCounterReset           :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the Depth Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the Depth Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the 1 in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferTrafficGeneratorCounterReset           :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the Depth Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the Depth Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the 1 in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferTrafficGeneratorCounterReset, TRegVdfDepthBufferTrafficGeneratorCounterReset, *PTRegVdfDepthBufferTrafficGeneratorCounterReset;                                //0x16068

//Enables the traffic generator on the LYRY (y) endpoint buffer. When the LYRY Buffer Traffic Generator  is enabled,
//and the LYRY Endpoint Data is disabled (bit 1 Video Endpoint Data Enable register = '0'), the traffic generator
//will respond reads from the LYRY buffer data address range and UVC Header address range with a value determined
//by the LYRY Buffer Traffic Generator Pattern Select CSR. The LYRY Buffer Traffic Generator Enable is ignored if
//the LYRY Endpoint Data is enabled (bit 1 Video Endpoint Data Enable register = '1'.
//initial value: 0x0
typedef union __RegVdfLyryBufferTrafficGeneratorEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferTrafficGeneratorEnable                  :1          ; //Bits :[0:0], initial value: 0x0. '0' = LYRY Buffer Traffic Generator Disabled.             '1' = LYRY Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferTrafficGeneratorEnable                  :1          ; //Bits :[0:0], initial value: 0x0. '0' = LYRY Buffer Traffic Generator Disabled.             '1' = LYRY Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferTrafficGeneratorEnable                  :1          ; //Bits :[0:0], initial value: 0x0. '0' = LYRY Buffer Traffic Generator Disabled.             '1' = LYRY Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryBufferTrafficGeneratorEnable, TRegVdfLyryBufferTrafficGeneratorEnable, *PTRegVdfLyryBufferTrafficGeneratorEnable;                                //0x1606C

//Selects one of three patterns for the traffic generator for the LYRY Buffer, User Word, Ramp Counter or LFSR.
//initial value: 0x0
typedef union __RegVdfLyryBufferTrafficGeneratorPatternSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferTrafficGeneratorPatternSelect           :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the LYRY Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferTrafficGeneratorPatternSelect           :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the LYRY Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferTrafficGeneratorPatternSelect           :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the LYRY Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryBufferTrafficGeneratorPatternSelect, TRegVdfLyryBufferTrafficGeneratorPatternSelect, *PTRegVdfLyryBufferTrafficGeneratorPatternSelect;                                //0x16070

//This 32-bit word is transmitted when the LYRY Buffer Traffic Generator is enabled, and the 'User Word' pattern
// is selected in the LYRY Buffer Traffic Generator Pattern Select CSR.
//initial value: 0x1BADFEED
typedef union __RegVdfLyryBufferTrafficGeneratorUserWord{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferTrafficGeneratorUserWord                :32         ; //Bits :[0:31], initial value: 0x1BADFEED. 32-bit word is transmitted when the LYRY Buffer Traffic Generator is enabled, and the AXI bus is read in the LYRY Buffer address range
     } fields_read;
    struct {
        uint32_t LyryBufferTrafficGeneratorUserWord                :32         ; //Bits :[0:31], initial value: 0x1BADFEED. 32-bit word is transmitted when the LYRY Buffer Traffic Generator is enabled, and the AXI bus is read in the LYRY Buffer address range
     } fields_write;
    struct {
        uint32_t LyryBufferTrafficGeneratorUserWord                :32         ; //Bits :[0:31], initial value: 0x1BADFEED. 32-bit word is transmitted when the LYRY Buffer Traffic Generator is enabled, and the AXI bus is read in the LYRY Buffer address range
     } fields_rmw; //for non-shadowed register
} RegVdfLyryBufferTrafficGeneratorUserWord, TRegVdfLyryBufferTrafficGeneratorUserWord, *PTRegVdfLyryBufferTrafficGeneratorUserWord;                                //0x16074

//Resets the counters used in the LYRY Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless
//of the state of the LYRY Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR.
//initial value: 0x0
typedef union __RegVdfLyryBufferTrafficGeneratorCounterReset{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferTrafficGeneratorCounterReset            :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the LYRY Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the LYRY Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the '1' in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferTrafficGeneratorCounterReset            :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the LYRY Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the LYRY Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the '1' in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferTrafficGeneratorCounterReset            :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the LYRY Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the LYRY Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the '1' in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryBufferTrafficGeneratorCounterReset, TRegVdfLyryBufferTrafficGeneratorCounterReset, *PTRegVdfLyryBufferTrafficGeneratorCounterReset;                                //0x16078

//Enables the traffic generator on the WebCam (c) endpoint buffer. When the WebCam Buffer Traffic Generator  is enabled,
//and the WebCam Endpoint Data is disabled (bit 2 Video Endpoint Data Enable register = '0'), the traffic generator
//will respond reads from the WebCam buffer data address range and UVC Header address range with a value determined
//by the WebCam Buffer Traffic Generator Pattern Select CSR. The WebCam Buffer Traffic Generator Enable is ignored
//if the WebCam Endpoint Data is enabled (bit 2 Video Endpoint Data Enable register = '1'.
//initial value: 0x0
typedef union __RegVdfWebcamBufferTrafficGeneratorEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferTrafficGeneratorEnable                :1          ; //Bits :[0:0], initial value: 0x0. '0' = WebCam Buffer Traffic Generator Disabled.             '1' = WebCam Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamBufferTrafficGeneratorEnable                :1          ; //Bits :[0:0], initial value: 0x0. '0' = WebCam Buffer Traffic Generator Disabled.             '1' = WebCam Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamBufferTrafficGeneratorEnable                :1          ; //Bits :[0:0], initial value: 0x0. '0' = WebCam Buffer Traffic Generator Disabled.             '1' = WebCam Buffer Traffic Generator Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamBufferTrafficGeneratorEnable, TRegVdfWebcamBufferTrafficGeneratorEnable, *PTRegVdfWebcamBufferTrafficGeneratorEnable;                                //0x1607C

//Selects one of three patterns for the traffic generator for the WebCam Buffer, User Word, Ramp Counter or LFSR.
//
//initial value: 0x0
typedef union __RegVdfWebcamBufferTrafficGeneratorPatternSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferTrafficGeneratorPatternSelect         :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the WebCam Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamBufferTrafficGeneratorPatternSelect         :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the WebCam Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamBufferTrafficGeneratorPatternSelect         :2          ; //Bits :[0:1], initial value: 0x0.   00 = User word. Transmits the 32-bit value in the WebCam Buffer Traffic Generator User Word CSR each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read.  01 = 32-bit Ramp Counter. Starts at 32'h0000_0000, increments by 1 each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The counter rolls over at 32'hFFFF_FFFF.  10 = LFSR Counter. Starts at 32'h0000_0000, increments each time the buffer is read while the pattern is selected, regardless of the address in the buffer that is read. The polynomial used for the linear feedback shift is Xe32 + Xe22 + Xe2 + Xe1 + 1. The counter rolls over at 32'hFFFF_FFFF.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamBufferTrafficGeneratorPatternSelect, TRegVdfWebcamBufferTrafficGeneratorPatternSelect, *PTRegVdfWebcamBufferTrafficGeneratorPatternSelect;                                //0x16080

//This 32-bit word is transmitted when the WebCam Buffer Traffic Generator is enabled, and the 'User Word' pattern
//is selected in the WebCam Buffer Traffic Generator Pattern Select CSR.
//initial value: 0x2BADFEED
typedef union __RegVdfWebcamBufferTrafficGeneratorUserWord{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferTrafficGeneratorUserWord              :32         ; //Bits :[0:31], initial value: 0x2BADFEED. 32-bit word is transmitted when the WebCam Buffer Traffic Generator is enabled, and the AXI bus is read in the WebCam Buffer address range
     } fields_read;
    struct {
        uint32_t WebcamBufferTrafficGeneratorUserWord              :32         ; //Bits :[0:31], initial value: 0x2BADFEED. 32-bit word is transmitted when the WebCam Buffer Traffic Generator is enabled, and the AXI bus is read in the WebCam Buffer address range
     } fields_write;
    struct {
        uint32_t WebcamBufferTrafficGeneratorUserWord              :32         ; //Bits :[0:31], initial value: 0x2BADFEED. 32-bit word is transmitted when the WebCam Buffer Traffic Generator is enabled, and the AXI bus is read in the WebCam Buffer address range
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamBufferTrafficGeneratorUserWord, TRegVdfWebcamBufferTrafficGeneratorUserWord, *PTRegVdfWebcamBufferTrafficGeneratorUserWord;                                //0x16084

//Resets the counters used in the WebCam Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless
//of the state of the WebCam Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR.
//initial value: 0x0
typedef union __RegVdfWebcamBufferTrafficGeneratorCounterReset{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferTrafficGeneratorCounterReset          :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the WebCam Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the WebCam Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the '1' in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamBufferTrafficGeneratorCounterReset          :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the WebCam Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the WebCam Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the '1' in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamBufferTrafficGeneratorCounterReset          :1          ; //Bits :[0:0], initial value: 0x0. Resets the counters used in the WebCam Buffer Traffic Generator to 32'h0000_0000. The counters are reset regardless of the state of the WebCam Buffer Traffic Generator Enable CSR or the Video Endpoint Data Enable CSR. When a '1' is written to this register, the counters are all reset to zero, and held at zero as long as the '1' in the register remains. When a '0' is written, the counters will begin to count if enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamBufferTrafficGeneratorCounterReset, TRegVdfWebcamBufferTrafficGeneratorCounterReset, *PTRegVdfWebcamBufferTrafficGeneratorCounterReset;                                //0x16088

//Selects whether the VDF (and the DS5) transmits data via the USB 3.0 or the MIPI. This register should only be
// changed when all endpoints are disabled.
//initial value: 0x0
typedef union __RegVdfUsb3ModeSelect{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Usb3ModeSelect                                    :1          ; //Bits :[0:0], initial value: 0x0.  1 = USB 3.0 Mode, 0 = MIPI Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t Usb3ModeSelect                                    :1          ; //Bits :[0:0], initial value: 0x0.  1 = USB 3.0 Mode, 0 = MIPI Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t Usb3ModeSelect                                    :1          ; //Bits :[0:0], initial value: 0x0.  1 = USB 3.0 Mode, 0 = MIPI Mode.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfUsb3ModeSelect, TRegVdfUsb3ModeSelect, *PTRegVdfUsb3ModeSelect;                                //0x1608C

//Depth Buffer MIPI Data Type for Pixel Data. Data from the Depth buffer will be transmitted with this MIPI DT in
//the MIPI packet headers for the packets with pixel data. Although any 6-bit value can be configured and used as
//the packet type, in normal usage the values of 0x30-0x37 should be used, these are the MIPI CSI2 types for 'user-defined
//byte data', since the depth data (compressed or not) does not match any of the MIPI specified data types. Do not
//confuse MIPI term 'Data types' (from the CSi-2 specification with the DS5 data types. No effect on USB 3.0 mode.
//This register should only be changed if the endpoint is disabled.
//initial value: 0x30
typedef union __RegVdfDepthPixelMipiPacketType{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferMipiPacketTypeForPixelData             :6          ; //Bits :[0:5], initial value: 0x30. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the Depth buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferMipiPacketTypeForPixelData             :6          ; //Bits :[0:5], initial value: 0x30. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the Depth buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferMipiPacketTypeForPixelData             :6          ; //Bits :[0:5], initial value: 0x30. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the Depth buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthPixelMipiPacketType, TRegVdfDepthPixelMipiPacketType, *PTRegVdfDepthPixelMipiPacketType;                                //0x16090

//LYRY Buffer MIPI Data Type for Pixel Data. Data from the LYRY buffer will be transmitted with this MIPI DT in the
//MIPI packet headers for the packets with pixel data. Although any 6-bit value can be configured and used as the
//packet type, the LCP must select a valid MIPI type if the data being transmitted meets one of the MIPI CSI2 types,
//if not, then the values of 0x30-0x37 should be used for 'user-defined byte data'. Do not confuse MIPI term 'Data
//types' (from the CSi-2 specification with the DS5 data types. No effect on USB 3.0 mode. This register should only
//be changed if the endpoint is disabled.
//initial value: 0x31
typedef union __RegVdfLyryPixelMipiPacketType{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferMipiPacketTypeForPixelData              :6          ; //Bits :[0:5], initial value: 0x31. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the LYRY buffer.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferMipiPacketTypeForPixelData              :6          ; //Bits :[0:5], initial value: 0x31. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the LYRY buffer.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferMipiPacketTypeForPixelData              :6          ; //Bits :[0:5], initial value: 0x31. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the LYRY buffer.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryPixelMipiPacketType, TRegVdfLyryPixelMipiPacketType, *PTRegVdfLyryPixelMipiPacketType;                                //0x16094

//Webcam Buffer MIPI Data Type for Pixel Data. Data from the webcam buffer will be transmitted with this MIPI DT
// in the MIPI packet headers for the packets with pixel data. Although any 6-bit value can be configured and used
//as the packet type, the LCP must select a valid MIPI type if the data being transmitted meets one of the MIPI CSI2
//types, if not, then the values of 0x30-0x37 should be used for 'user-defined byte data'. Do not confuse MIPI term
//'Data types' (from the CSi-2 specification with the DS5 data types. No effect on USB 3.0 mode. This register should
//only be changed if the endpoint is disabled.
//initial value: 0x32
typedef union __RegVdfWebcamPixelMipiPacketType{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferMipiPacketTypeForPixelData            :6          ; //Bits :[0:5], initial value: 0x32. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the WebCam buffer.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamBufferMipiPacketTypeForPixelData            :6          ; //Bits :[0:5], initial value: 0x32. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the WebCam buffer.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamBufferMipiPacketTypeForPixelData            :6          ; //Bits :[0:5], initial value: 0x32. 6-bit value used as the MIPI CSI2 packet type when pixel data is transmitted out of the WebCam buffer.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamPixelMipiPacketType, TRegVdfWebcamPixelMipiPacketType, *PTRegVdfWebcamPixelMipiPacketType;                                //0x16098

//MIPI Virtual Channel for all MIPI packets transmitted from the Depth Buffer. Data and framing packets from the
// Depth buffer will be transmitted with this MIPI VC in the MIPI packet headers for all packets. Although any 2-bit
//value can be used as the virtual channel, the LCP must manage the VC's such that there are no conflicts with different
//data streams being given the same VC. No effect on USB 3.0 mode. This register should only be changed if the endpoint
//is disabled.
//initial value: 0x0
typedef union __RegVdfDepthVirtualChannel{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferMipiVirtualChannel                     :2          ; //Bits :[0:1], initial value: 0x0. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the Depth buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferMipiVirtualChannel                     :2          ; //Bits :[0:1], initial value: 0x0. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the Depth buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferMipiVirtualChannel                     :2          ; //Bits :[0:1], initial value: 0x0. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the Depth buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthVirtualChannel, TRegVdfDepthVirtualChannel, *PTRegVdfDepthVirtualChannel;                                //0x1609C

//MIPI Virtual Channel for all MIPI packets transmitted from the LYRY Buffer. Data and framing packets from the LYRY
//buffer will be transmitted with this MIPI VC in the MIPI packet headers for all packets. Although any 2-bit value
//can be used as the virtual channel, the LCP must manage the VC's such that there are no conflicts with different
//data streams being given the same VC. No effect on USB 3.0 mode. This register should only be changed if the endpoint
//is disabled.
//initial value: 0x1
typedef union __RegVdfLyryVirtualChannel{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferMipiVirtualChannel                      :2          ; //Bits :[0:1], initial value: 0x1. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the LYRY buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferMipiVirtualChannel                      :2          ; //Bits :[0:1], initial value: 0x1. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the LYRY buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferMipiVirtualChannel                      :2          ; //Bits :[0:1], initial value: 0x1. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the LYRY buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryVirtualChannel, TRegVdfLyryVirtualChannel, *PTRegVdfLyryVirtualChannel;                                //0x160A0

//MIPI Virtual Channel for all MIPI packets transmitted from the Webcam Buffer. Data and framing packets from the
//Webcam buffer will be transmitted with this MIPI VC in the MIPI packet headers for all packets. Although any 2-bit
//value can be used as the virtual channel, the LCP must manage the VC's such that there are no conflicts with different
//data streams being given the same VC. No effect on USB 3.0 mode. This register should only be changed if the endpoint
//is disabled.
//initial value: 0x2
typedef union __RegVdfWebcamVirtualChannel{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferMipiVirtualChannel                    :2          ; //Bits :[0:1], initial value: 0x2. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the Webcam buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamBufferMipiVirtualChannel                    :2          ; //Bits :[0:1], initial value: 0x2. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the Webcam buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamBufferMipiVirtualChannel                    :2          ; //Bits :[0:1], initial value: 0x2. 2-bit value used as the MIPI CSI2 virtual channel when MIPI packets are transmitted out of the Webcam buffer.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamVirtualChannel, TRegVdfWebcamVirtualChannel, *PTRegVdfWebcamVirtualChannel;                                //0x160A4

//Depth Buffer MIPI Data Type for Dinghy Data. The Dinghy Data from the Depth buffer will be transmitted with this
//MIPI DT in the MIPI packet headers for the packets with dinghy data. Although any 6-bit value can be configured
//and used as the packet type, in normal usage the values of 0x30-0x37 should be used, these are the MIPI CSI2 types
//for 'user-defined byte data', since the dinghy data does not match any of the MIPI specified data types. Do not
//confuse MIPI term 'Data types' (from the CSi-2 specification) with the DS5 data types. No effect on USB 3.0 mode.
//This register should only be changed if the endpoint is disabled.
//initial value: 0x33
typedef union __RegVdfDepthDinghyMipiPacketType{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferMipiPacketTypeForDinghyData            :6          ; //Bits :[0:5], initial value: 0x33. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the Depth buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferMipiPacketTypeForDinghyData            :6          ; //Bits :[0:5], initial value: 0x33. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the Depth buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferMipiPacketTypeForDinghyData            :6          ; //Bits :[0:5], initial value: 0x33. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the Depth buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthDinghyMipiPacketType, TRegVdfDepthDinghyMipiPacketType, *PTRegVdfDepthDinghyMipiPacketType;                                //0x160A8

//LYRY Buffer MIPI Data Type for Dinghy Data. The Dinghy Data from the LYRY buffer will be transmitted with this
// MIPI DT in the MIPI packet headers for the packets with dinghy data. Although any 6-bit value can be configured
//and used as the packet type, in normal usage the values of 0x30-0x37 should be used, these are the MIPI CSI2 types
//for 'user-defined byte data', since the dinghy data does not match any of the MIPI specified data types. Do not
//confuse MIPI term 'Data types' (from the CSi-2 specification) with the DS5 data types. No effect on USB 3.0 mode.
//This register should only be changed if the endpoint is disabled.
//initial value: 0x34
typedef union __RegVdfLyryDinghyMipiPacketType{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferMipiPacketTypeForDinghyData             :6          ; //Bits :[0:5], initial value: 0x34. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the LYRY buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferMipiPacketTypeForDinghyData             :6          ; //Bits :[0:5], initial value: 0x34. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the LYRY buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferMipiPacketTypeForDinghyData             :6          ; //Bits :[0:5], initial value: 0x34. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the LYRY buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryDinghyMipiPacketType, TRegVdfLyryDinghyMipiPacketType, *PTRegVdfLyryDinghyMipiPacketType;                                //0x160AC

//Webcam Buffer MIPI Data Type for Dinghy Data. The Dinghy Data from the Webcam buffer will be transmitted with this
//MIPI DT in the MIPI packet headers for the packets with dinghy data. Although any 6-bit value can be configured
//and used as the packet type, in normal usage the values of 0x30-0x37 should be used, these are the MIPI CSI2 types
//for 'user-defined byte data', since the dinghy data does not match any of the MIPI specified data types. Do not
//confuse MIPI term 'Data types' (from the CSi-2 specification) with the DS5 data types. No effect on USB 3.0 mode.
//This register should only be changed if the endpoint is disabled.
//initial value: 0x35
typedef union __RegVdfWebcamDinghyMipiPacketType{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t WebcamBufferMipiPacketTypeForDinghyData           :6          ; //Bits :[0:5], initial value: 0x35. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the Webcam buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t WebcamBufferMipiPacketTypeForDinghyData           :6          ; //Bits :[0:5], initial value: 0x35. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the Webcam buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t WebcamBufferMipiPacketTypeForDinghyData           :6          ; //Bits :[0:5], initial value: 0x35. 6-bit value used as the MIPI CSI2 packet type when dinghy data is transmitted out of the Webcam buffer..
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamDinghyMipiPacketType, TRegVdfWebcamDinghyMipiPacketType, *PTRegVdfWebcamDinghyMipiPacketType;                                //0x160B0

//The length of the MIPI packets, in 32-bit words, that is used when the Depth buffer is transmitting compressed
// data. MIPI packets with compressed depth data are transmitted in packets each containing the number of 32-bit
// words specified in this register. The minimum line length is 32, the maximum is 1280. Values outside this range
//should not be used, indeterminate output will result. If a frame of compressed data is not an integer number of
//the COMPRESSED_DEPTH_DATA_LINE_LENGTH value, then the last packet in the frame is padded with zeros out to the
// length of the line. If the VDF is operating in USB 3.0 mode, then this register has no effect, there is no padding
//added. This register should only be changed if the endpoint is disabled.
//initial value: 0x0000
typedef union __RegVdfCompressedDepthDataLineLength{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CompressedDataMipiLineLength                      :16         ; //Bits :[0:15], initial value: 0x0. Compressed Data MIPI Line length.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t CompressedDataMipiLineLength                      :16         ; //Bits :[0:15], initial value: 0x0. Compressed Data MIPI Line length.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t CompressedDataMipiLineLength                      :16         ; //Bits :[0:15], initial value: 0x0. Compressed Data MIPI Line length.
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfCompressedDepthDataLineLength, TRegVdfCompressedDepthDataLineLength, *PTRegVdfCompressedDepthDataLineLength;                                //0x160B4

//General Status, for LCP Debug and graceful shutdown of an active MIPI buffer. Two bits of status are given for
// each buffer. The 'MIPI Arbiter Enable' bit shows which of the three buffers currently has been granted access
// to the MTR interface. The 'MIPI Halt Acknowledge' bit is an indication that the buffer has detected that its 'MIPI
//Halt' bit has been set by the LCP, and that the buffer has completed any packets that were in process when the
// 'halt bit' was set, and that the buffer is now halted and can be disabled safely without causing a bad or incomplete
//packet to be transmitted.
//initial value: 0x00
typedef union __RegVdfVdfGeneralStatus1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ZBufferMipiArbiterEnable                          :1          ; //Bits :[0:0], initial value: 0x0. 1 = Z buffer granted access to the MTR interface. 0 = Z buffer not granted access to the MTR interface.
        uint32_t ZBufferMipiHaltAcknowledge                        :1          ; //Bits :[1:1], initial value: 0x0. 1 = MIPI TX from Z buffer is halted  0 = MIPI TX from Z buffer is not halted.
        uint32_t YBufferMipiArbiterEnable                          :1          ; //Bits :[2:2], initial value: 0x0. Y buffer granted access to the MTR interface. 0 = Y buffer not granted access to the MTR interface.
        uint32_t YBufferMipiHaltAcknowledge                        :1          ; //Bits :[3:3], initial value: 0x0. 1 = MIPI TX from Y buffer is halted  0 = MIPI TX from Y buffer is not halted.
        uint32_t CBufferMipiArbiterEnable                          :1          ; //Bits :[4:4], initial value: 0x0. C buffer granted access to the MTR interface. 0 = C buffer not granted access to the MTR interface.
        uint32_t CBufferMipiHaltAcknowledge                        :1          ; //Bits :[5:5], initial value: 0x0. 1 = MIPI TX from C buffer is halted, 0 = MIPI TX from C buffer is not halted.
        uint32_t NonStreamingBufferMipiArbiterEnable               :1          ; //Bits :[6:6], initial value: 0x0. Non-Streaming buffer granted access to the MTR interface. 0 = Non-Streaming buffer not granted access to the MTR interface.
        uint32_t NonStreamingBufferMipiHaltAcknowledge             :1          ; //Bits :[7:7], initial value: 0x0. 1 = MIPI TX from Non-Streaming buffer is halted, 0 =  MIPI TX from Non-Streaming buffer is not halted.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t ZBufferMipiArbiterEnable                          :1          ; //Bits :[0:0], initial value: 0x0. 1 = Z buffer granted access to the MTR interface. 0 = Z buffer not granted access to the MTR interface.
        uint32_t ZBufferMipiHaltAcknowledge                        :1          ; //Bits :[1:1], initial value: 0x0. 1 = MIPI TX from Z buffer is halted  0 = MIPI TX from Z buffer is not halted.
        uint32_t YBufferMipiArbiterEnable                          :1          ; //Bits :[2:2], initial value: 0x0. Y buffer granted access to the MTR interface. 0 = Y buffer not granted access to the MTR interface.
        uint32_t YBufferMipiHaltAcknowledge                        :1          ; //Bits :[3:3], initial value: 0x0. 1 = MIPI TX from Y buffer is halted  0 = MIPI TX from Y buffer is not halted.
        uint32_t CBufferMipiArbiterEnable                          :1          ; //Bits :[4:4], initial value: 0x0. C buffer granted access to the MTR interface. 0 = C buffer not granted access to the MTR interface.
        uint32_t CBufferMipiHaltAcknowledge                        :1          ; //Bits :[5:5], initial value: 0x0. 1 = MIPI TX from C buffer is halted, 0 = MIPI TX from C buffer is not halted.
        uint32_t NonStreamingBufferMipiArbiterEnable               :1          ; //Bits :[6:6], initial value: 0x0. Non-Streaming buffer granted access to the MTR interface. 0 = Non-Streaming buffer not granted access to the MTR interface.
        uint32_t NonStreamingBufferMipiHaltAcknowledge             :1          ; //Bits :[7:7], initial value: 0x0. 1 = MIPI TX from Non-Streaming buffer is halted, 0 =  MIPI TX from Non-Streaming buffer is not halted.
        uint32_t Reserved                                          :24         ; //Bits :[8:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfGeneralStatus1, TRegVdfVdfGeneralStatus1, *PTRegVdfVdfGeneralStatus1;                                //0x160B8

//General Status, for LCP Debug. TBD.
//initial value: 0x00000000
typedef union __RegVdfVdfGeneralStatus2{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t GeneralStatus2                                    :32         ; //Bits :[0:31], initial value: 0x0. Bit mapping is TBD.
     } fields_read;
    struct {
        uint32_t GeneralStatus2                                    :32         ; //Bits :[0:31], initial value: 0x0. Bit mapping is TBD.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfGeneralStatus2, TRegVdfVdfGeneralStatus2, *PTRegVdfVdfGeneralStatus2;                                //0x160BC

//Halts the MIPI transmit of data from the CAM buffer. If a CAM buffer MIPI packet transmit is in process, it is
// completed, along with any associated MIPI framing packets (FS, LS, LE, FE). The MIPI Halt differs from the 'endpoint
//enable control; the buffer and logic are not held in reset and the buffer continues to fill with data. If the MIPI
//Halt remains asserted and data continues to fill the buffer, an overflow interrupt can occur. This register should
//be used when disabling an active buffer. This register is ignored in USB 3.0 mode. The halt will be acknowledged
//in the general_status_1 register.
//initial value: 0x0
typedef union __RegVdfCamBufferMipiHalt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = CAM buffer MIPI packets are transmitted if ready. 1 = CAM buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t CamBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = CAM buffer MIPI packets are transmitted if ready. 1 = CAM buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t CamBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = CAM buffer MIPI packets are transmitted if ready. 1 = CAM buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfCamBufferMipiHalt, TRegVdfCamBufferMipiHalt, *PTRegVdfCamBufferMipiHalt;                                //0x160C0

//Halts the MIPI transmit of data from the VDF REC buffer. If a VDF REC buffer MIPI packet transmit is in process,
//it is completed, along with any associated MIPI framing packets (FS, LS, LE, FE). The MIPI Halt differs from the
//'endpoint enable control; the buffer and logic are not held in reset and the buffer continues to fill with data.
//If the MIPI Halt remains asserted and data continues to fill the buffer, an overflow interrupt can occur. This
// register should be used when disabling an active buffer. This register is ignored in USB 3.0 mode.  The halt will
//be acknowledged in the general_status_1 register.
//initial value: 0x0
typedef union __RegVdfRecBufferMipiHalt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RecBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = VDF REC buffer MIPI packets are transmitted if ready. 1 = VDF REC buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t RecBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = VDF REC buffer MIPI packets are transmitted if ready. 1 = VDF REC buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t RecBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = VDF REC buffer MIPI packets are transmitted if ready. 1 = VDF REC buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfRecBufferMipiHalt, TRegVdfRecBufferMipiHalt, *PTRegVdfRecBufferMipiHalt;                                //0x160C4

//Halts the MIPI transmit of data from the Depth buffer. If a Depth buffer MIPI packet transmit is in process, it
//is completed, along with any associated MIPI framing packets (FS, LS, LE, FE). The MIPI Halt differs from the 'endpoint
//enable control; the buffer and logic are not held in reset and the buffer continues to fill with data. If the MIPI
//Halt remains asserted and data continues to fill the buffer, an overflow interrupt can occur. This register should
//be used when disabling an active buffer. This register is ignored in USB 3.0 mode. The halt will be acknowledged
//in the general_status_1 register.
//initial value: 0x0
typedef union __RegVdfDepthBufferMipiHalt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferMipiHalt                               :1          ; //Bits :[0:0], initial value: 0x0. 0 = Depth buffer MIPI packets are transmitted if ready. 1 = Depth buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferMipiHalt                               :1          ; //Bits :[0:0], initial value: 0x0. 0 = Depth buffer MIPI packets are transmitted if ready. 1 = Depth buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferMipiHalt                               :1          ; //Bits :[0:0], initial value: 0x0. 0 = Depth buffer MIPI packets are transmitted if ready. 1 = Depth buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferMipiHalt, TRegVdfDepthBufferMipiHalt, *PTRegVdfDepthBufferMipiHalt;                                //0x160C8

//Halts the MIPI transmit of data from the nse buffer. If an NSE buffer MIPI packet transmit is in process, it is
//completed, along with any associated MIPI framing packets (FS, LS, LE, FE). This register should be used when disabling
//an active buffer. This register is ignored in USB 3.0 mode. The halt will be acknowledged in the general_status_1
//register.
//initial value: 0x0
typedef union __RegVdfNseBufferMipiHalt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NseBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = NSE buffer MIPI packets are transmitted if ready. 1 = NSE buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t NseBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = NSE buffer MIPI packets are transmitted if ready. 1 = NSE buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t NseBufferMipiHalt                                 :1          ; //Bits :[0:0], initial value: 0x0. 0 = NSE buffer MIPI packets are transmitted if ready. 1 = NSE buffer MIPI Packets are not transmitted.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfNseBufferMipiHalt, TRegVdfNseBufferMipiHalt, *PTRegVdfNseBufferMipiHalt;                                //0x161E8

//Sets the priority scheme used to arbitrate access to the MIPI MTR interface from the three buffers.
//initial value: 0x0
typedef union __RegVdfMipiArbiterPriority{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Tbd                                               :32         ; //Bits :[0:31], initial value: 0x0. TBD, currently there is a fixed round robin scheme.
     } fields_read;
    struct {
        uint32_t Tbd                                               :32         ; //Bits :[0:31], initial value: 0x0. TBD, currently there is a fixed round robin scheme.
     } fields_write;
    struct {
        uint32_t Tbd                                               :32         ; //Bits :[0:31], initial value: 0x0. TBD, currently there is a fixed round robin scheme.
     } fields_rmw; //for non-shadowed register
} RegVdfMipiArbiterPriority, TRegVdfMipiArbiterPriority, *PTRegVdfMipiArbiterPriority;                                //0x160CC

//This register controls which MIPI Data Type (DT) is given to the pixel data being sent from the CAM buffer when
//the cam buffer is transmitting CSI-data through the MIPI via the MTR interface. . Either the CSI-a or CSI-b data
//can be transmitted from the CAM buffer. Either the data type specified in the WEBCAM_PIXEL_MIPI_PACKET_TYPE CSR
//is given to the MIPI packets from the CAM buffer, or the data type that is received with the data from the CAM
// on the selected csi bus is given to the MIPI packets when they are transmitted from the VDF. This register selects
//which of those two methods are used for the DT on the packets exiting the VDF. This does not affect the data type
//used for the dinghy or the MIPI FS (Frame Start) or FE (Frame End) packets. When enabled, the DT of each line received
//by the VDF is given to that line as it exits (through the MTR interface on a line-by-line basis. The DT from the
//CAM is expected to remain stable beginning with SOL, through to the next SOL. This register has no effect if the
//VDF is operating in AXI mode, or if a data source other than csi-a or csi-b is selected for the Cam buffer. This
//register should only be changed if the endpoint is disabled. The MIPI Data Type received by the VDF from the CSI-2
//input must be a legal long packet type, 0x10 to 0x37.
//initial value: 0x0
typedef union __RegVdfCamBufferDataTypePassThroughEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamBufferDataTypePassThroughEnable                :1          ; //Bits :[0:0], initial value: 0x0. When 1: The MIPI Data Type received from the CAM module is used on the MIPI packets out of the VDF from the CAM buffer. When 0: The MIPI Data Type specified in the WEBCAM_PIXEL_MIPI_PACKET_TYPE CSR is given to  MIPI packets out of the VDF from the CAM buffer.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t CamBufferDataTypePassThroughEnable                :1          ; //Bits :[0:0], initial value: 0x0. When 1: The MIPI Data Type received from the CAM module is used on the MIPI packets out of the VDF from the CAM buffer. When 0: The MIPI Data Type specified in the WEBCAM_PIXEL_MIPI_PACKET_TYPE CSR is given to  MIPI packets out of the VDF from the CAM buffer.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t CamBufferDataTypePassThroughEnable                :1          ; //Bits :[0:0], initial value: 0x0. When 1: The MIPI Data Type received from the CAM module is used on the MIPI packets out of the VDF from the CAM buffer. When 0: The MIPI Data Type specified in the WEBCAM_PIXEL_MIPI_PACKET_TYPE CSR is given to  MIPI packets out of the VDF from the CAM buffer.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfCamBufferDataTypePassThroughEnable, TRegVdfCamBufferDataTypePassThroughEnable, *PTRegVdfCamBufferDataTypePassThroughEnable;                                //0x160D0

//This register controls which MIPI Data Type (DT) is given to the pixel data being sent from the VDF REC buffer
// when the VDF REC buffer is transmitting CSI-data through the MIPI via the MTR interface. Either the CSI-a or CSI-b
//data can be transmitted from the VDF REC buffer. Either the MIPI Data Type specified in the LYRY_PIXEL_MIPI_PACKET_TYPE
//CSR is given to the MIPI packets, or the DT that is received with the data from the CAM on the selected csi bus
//is given to the MIPI packets when they are transmitted from the VDF. This register selects which of those two methods
//are used for the DT on the packets exiting the VDF. This does not affect the data type used for the dinghy or the
//MIPI FS (Frame Start) or FE (Frame End) packets. When enabled, the DT of each line received by the VDF is given
//to that line as it exits (through the MTR interface on a line-by-line basis. The DT from the CAM is expected to
//remain stable beginning with SOL, through the next SOL. This register has no effect if the VDF is operating in
// AXI mode, or if a data source other than csi is selected for the VDF REC buffer. This register should only be
// changed if the endpoint is disabled. The MIPI Data Type received by the VDF from the CSI-2 input must be a legal
//long packet type, 0x10 to 0x37.
//initial value: 0x0
typedef union __RegVdfRecBufferDataTypePassThroughEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfRecBufferDataTypePassThroughEnable             :1          ; //Bits :[0:0], initial value: 0x0. When 1: The MIPI Data Type received from the CAM module is used on the MIPI packets out of the VDF from the VDF REC buffer. When 0: The MIPI Data Type specified in the WEBCAM_PIXEL_MIPI_PACKET_TYPE CSR is given to  MIPI packets out of the VDF from the VDF REC buffer.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t VdfRecBufferDataTypePassThroughEnable             :1          ; //Bits :[0:0], initial value: 0x0. When 1: The MIPI Data Type received from the CAM module is used on the MIPI packets out of the VDF from the VDF REC buffer. When 0: The MIPI Data Type specified in the WEBCAM_PIXEL_MIPI_PACKET_TYPE CSR is given to  MIPI packets out of the VDF from the VDF REC buffer.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t VdfRecBufferDataTypePassThroughEnable             :1          ; //Bits :[0:0], initial value: 0x0. When 1: The MIPI Data Type received from the CAM module is used on the MIPI packets out of the VDF from the VDF REC buffer. When 0: The MIPI Data Type specified in the WEBCAM_PIXEL_MIPI_PACKET_TYPE CSR is given to  MIPI packets out of the VDF from the VDF REC buffer.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfRecBufferDataTypePassThroughEnable, TRegVdfRecBufferDataTypePassThroughEnable, *PTRegVdfRecBufferDataTypePassThroughEnable;                                //0x160D4

//This register holds the depth buffer address of the last dword in a frame written into the depth buffer. This address
//is updated every frame when the last pixel of the zero padding (if any) following the last dinghy dword is written
//to the buffer. An interrupt (the 'vdf_csr_zbuff_eod_intr' output from the VDF)is given to the LCP when the register
//is updated with a new address. This address is needed by the LCP because when compressed depth data is being sent
//in to the host in USB 3.0 mode, the LCP needs to know when the frame is over, and where the end of the frame is
//located in the main VDF depth buffer memory. The LCP needs this information because the frame size in the compressed
//mode differ frame-to-frame, due to the compression algorithm. The LCP needs to send complete frames of video data
//to the host, and to do so with the compressed data, it needs to know where in memory the frames start and end.
// The first frame after a reset will begin at address 0 in the buffer, and will end at the value in this register.
//Subsequent frames of compressed data will begin at the next-higher dword address. Since the compressed data is
// always sent with the dinghy appended, the address in this register points to the last pixel of 'frame padding'
//appended to the frame after the last dinghy pixel, rather than the video data pixel that was associated with the
//EOF. This register is expected to be used only when compressed data is being sent in USB 3.0 mode, but it also
// functions when normal depth data is being transmitted in USB 3.0 mode. The interrupt is asserted and the register
//is updated on the clock after the data is written to the depth buffer.
//initial value: 0x0
typedef union __RegVdfDepthBufferEodAddr{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferEodAddress                             :14         ; //Bits :[0:13], initial value: 0x0. Dword Address in the Depth Buffer of the last dword in the dinghy and frame padding appended to a frame of compressed data.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferEodAddress                             :14         ; //Bits :[0:13], initial value: 0x0. Dword Address in the Depth Buffer of the last dword in the dinghy and frame padding appended to a frame of compressed data.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferEodAddr, TRegVdfDepthBufferEodAddr, *PTRegVdfDepthBufferEodAddr;                                //0x160D8

//This register controls whether MIPI long packets are bracketed with LS and LE packets when sent to the MTR module.
//Each buffer can be individually enabled. When MIPI LS and LE are enabled for buffer, each long packet of pixel
// (and dinghy) data from that buffer is preceded by a MIPI LS packet, and followed by a MIPI LE packet. If multiple
//buffers are transmitting at the same time, one or two MIPI packets from the other buffers may be transmitted between
//the LS and LE packets and the long packet. The LS and LE packets do not carry any timing information with respect
//to the video time and are intended to be used only in debug and for interfacing to non-compliant MIPI receivers
//that may require them. The MIPI packet carrying the dinghy data and option dinghy line padding gets LS and LE packets
//when enabled. The data received from the csi-a and csi-b input streams will get LS and LE when it is enable regardless
//of the data type of the received data and the state of the “Data Type Pass-Through Enable CSR for that buffer.
//initial value: 0x0
typedef union __RegVdfMipiLsLeEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferLsLeEnable                             :1          ; //Bits :[0:0], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the Depth Buffer.
        uint32_t RecBufferLsLeEnable                               :1          ; //Bits :[1:1], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the REC Buffer.
        uint32_t CamBufferLsLeEnable                               :1          ; //Bits :[2:2], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the CAM Buffer.
        uint32_t NonStreamingBufferLsLeEnable                      :1          ; //Bits :[3:3], initial value: 0x0. 1 = Enable MIPI LS and LE packet for embedded data packets from the Non-Streaming buffer. Only applies when the embedded packet is being sent in it's own VC with it's own framing packets. When the embedded data packets from the Non-Streaming buffer are sent with one of the frames of pixel data fromt the streaming buffer, the paket will use the LS LE enable for that VC.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferLsLeEnable                             :1          ; //Bits :[0:0], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the Depth Buffer.
        uint32_t RecBufferLsLeEnable                               :1          ; //Bits :[1:1], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the REC Buffer.
        uint32_t CamBufferLsLeEnable                               :1          ; //Bits :[2:2], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the CAM Buffer.
        uint32_t NonStreamingBufferLsLeEnable                      :1          ; //Bits :[3:3], initial value: 0x0. 1 = Enable MIPI LS and LE packet for embedded data packets from the Non-Streaming buffer. Only applies when the embedded packet is being sent in it's own VC with it's own framing packets. When the embedded data packets from the Non-Streaming buffer are sent with one of the frames of pixel data fromt the streaming buffer, the paket will use the LS LE enable for that VC.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferLsLeEnable                             :1          ; //Bits :[0:0], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the Depth Buffer.
        uint32_t RecBufferLsLeEnable                               :1          ; //Bits :[1:1], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the REC Buffer.
        uint32_t CamBufferLsLeEnable                               :1          ; //Bits :[2:2], initial value: 0x0. 1 = Enable MIPI LS and LE packet for pixel data from the CAM Buffer.
        uint32_t NonStreamingBufferLsLeEnable                      :1          ; //Bits :[3:3], initial value: 0x0. 1 = Enable MIPI LS and LE packet for embedded data packets from the Non-Streaming buffer. Only applies when the embedded packet is being sent in it's own VC with it's own framing packets. When the embedded data packets from the Non-Streaming buffer are sent with one of the frames of pixel data fromt the streaming buffer, the paket will use the LS LE enable for that VC.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfMipiLsLeEnable, TRegVdfMipiLsLeEnable, *PTRegVdfMipiLsLeEnable;                                //0x160DC

//This register, along with the Depth Buffer Test Framing CSR, provides a backdoor which allows the LCP to directly
//write frames of video data directly into the VDF Depth buffer. When this register is written by the APB bus, the
//32-bit value written to this register is sent to the VDF Depth buffer with the 'valid signal asserted along with
//whatever framing signal has been written to the Depth Buffer Test Framing CSR. This is a test feature only and
// is not used in normal operation.
//initial value: 0x00000000
typedef union __RegVdfDepthBufferTestData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferTestData                               :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the Depth buffer.
     } fields_read;
    struct {
        uint32_t DepthBufferTestData                               :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the Depth buffer.
     } fields_write;
    struct {
        uint32_t DepthBufferTestData                               :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the Depth buffer.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferTestData, TRegVdfDepthBufferTestData, *PTRegVdfDepthBufferTestData;                                //0x160E0

//This register, along with the Depth Buffer Test Data CSR, provides a backdoor which allows the LCP to directly
// write frames of video data into the VDF buffers. When the  Depth Buffer Test Data CSR is written by the APB bus,
//the 32-bit value written to that register is sent to the VDF buffer with the 'valid signal asserted along with
// whatever framing signal has been written to this register. This is a test feature only and is not used in normal
//operation.
//initial value: 0x0
typedef union __RegVdfDepthBufferTestFraming{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferTestDataFrameSignalSelect              :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferTestDataFrameSignalSelect              :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferTestDataFrameSignalSelect              :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferTestFraming, TRegVdfDepthBufferTestFraming, *PTRegVdfDepthBufferTestFraming;                                //0x160E4

//This register, along with the REC Buffer Test Framing CSR, provides a backdoor which allows the LCP to directly
//write frames of video data directly into the VDF REC buffer. When this register is written by the APB bus, the
// 32-bit value written to this register is sent to the VDF REC buffer with the 'valid signal asserted along with
//whatever framing signal has been written to the REC Buffer Test Framing CSR. This is a test feature only and is
//not used in normal operation.
//initial value: 0x00000000
typedef union __RegVdfRecBufferTestData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RecBufferTestData                                 :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the REC buffer.
     } fields_read;
    struct {
        uint32_t RecBufferTestData                                 :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the REC buffer.
     } fields_write;
    struct {
        uint32_t RecBufferTestData                                 :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the REC buffer.
     } fields_rmw; //for non-shadowed register
} RegVdfRecBufferTestData, TRegVdfRecBufferTestData, *PTRegVdfRecBufferTestData;                                //0x160E8

//This register, along with the REC Buffer Test Data CSR, provides a backdoor which allows the LCP to directly write
//frames of video data into the VDF buffers. When the  REC Buffer Test Data CSR is written by the APB bus, the 32-bit
//value written to that register is sent to the VDF buffer with the valid signal asserted along with whatever framing
//signal has been written to this register. This is a test feature only and is not used in normal operation.
//initial value: 0x0
typedef union __RegVdfRecBufferTestFraming{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RecBufferTestDataFrameSignalSelect                :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t RecBufferTestDataFrameSignalSelect                :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t RecBufferTestDataFrameSignalSelect                :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfRecBufferTestFraming, TRegVdfRecBufferTestFraming, *PTRegVdfRecBufferTestFraming;                                //0x160EC

//This register, along with the CAM Buffer Test Framing CSR, provides a backdoor which allows the LCP to directly
//write frames of video data directly into the VDF CAM buffer. When this register is written by the APB bus, the
// 32-bit value written to this register is sent to the VDF CAM buffer with the valid signal asserted along with
// whatever framing signal has been written to the CAM Buffer Test Framing CSR. This is a test feature only and is
//not used in normal operation.
//initial value: 0x00000000
typedef union __RegVdfCamBufferTestData{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamBufferTestData                                 :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the CAM buffer.
     } fields_read;
    struct {
        uint32_t CamBufferTestData                                 :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the CAM buffer.
     } fields_write;
    struct {
        uint32_t CamBufferTestData                                 :32         ; //Bits :[0:31], initial value: 0x0. 32-bit Packed Data to be written into the CAM buffer.
     } fields_rmw; //for non-shadowed register
} RegVdfCamBufferTestData, TRegVdfCamBufferTestData, *PTRegVdfCamBufferTestData;                                //0x160F0

//This register, along with the CAM Buffer Test Data CSR, provides a backdoor which allows the LCP to directly write
//frames of video data into the VDF buffers. When the  CAM Buffer Test Data CSR is written by the APB bus, the 32-bit
//value written to that register is sent to the VDF buffer with the valid signal asserted along with whatever framing
//signal has been written to this register. This is a test feature only and is not used in normal operation.
//initial value: 0x0
typedef union __RegVdfCamBufferTestFraming{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamBufferTestDataFrameSignalSelect                :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t CamBufferTestDataFrameSignalSelect                :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t CamBufferTestDataFrameSignalSelect                :3          ; //Bits :[0:2], initial value: 0x0. 0: None                       1:SOF/SOL                       2:SOL                       3:EOL                       4:EOL/EOF                       5:SOD                       6:EOD                       7:None
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfCamBufferTestFraming, TRegVdfCamBufferTestFraming, *PTRegVdfCamBufferTestFraming;                                //0x160F4

//This register allows the address map of the VDF buffers to change between the normal map (i.e. like the DS4) to
//the double mode, where each buffer occupies twice as much address space. The buffer access is duplicated in contiguous
//address space. This allows a single DMA descriptor to be used to describe a memory block that wraps around a VDF
//buffer. The actual address maps are described fully in the DS5 HIS.
//initial value: 0x0
typedef union __RegVdfAxiBufferAddressMapMode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t AxiBufferAddressMapModeSelect                     :1          ; //Bits :[0:0], initial value: 0x0. 0: Use Normal addressing, each buffer occupies 64K of AXI address space.                       1: Use Doubled addressing, each buffer occupies 128K of AXI address space, same 64K duplicated.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t AxiBufferAddressMapModeSelect                     :1          ; //Bits :[0:0], initial value: 0x0. 0: Use Normal addressing, each buffer occupies 64K of AXI address space.                       1: Use Doubled addressing, each buffer occupies 128K of AXI address space, same 64K duplicated.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t AxiBufferAddressMapModeSelect                     :1          ; //Bits :[0:0], initial value: 0x0. 0: Use Normal addressing, each buffer occupies 64K of AXI address space.                       1: Use Doubled addressing, each buffer occupies 128K of AXI address space, same 64K duplicated.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfAxiBufferAddressMapMode, TRegVdfAxiBufferAddressMapMode, *PTRegVdfAxiBufferAddressMapMode;                                //0x160F8

//This is a 14-bit scratch register for use by the LCP in address calculations, the register needs be only 14 bits
//so the values roll over for the calculations which target the other address regisers which are also 14 bits long.
//The register can be written and read, but affects nothing in the rest of the module.
//initial value: 0x0
typedef union __RegVdfVdfScratch0{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfScratch0                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t VdfScratch0                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t VdfScratch0                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfScratch0, TRegVdfVdfScratch0, *PTRegVdfVdfScratch0;                                //0x160FC

//This is a 14-bit scratch register for use by the LCP in address calculations, the register needs be only 14 bits
//so the values roll over for the calculations which target the other address regisers which are also 14 bits long.
//The register can be written and read, but affects nothing in the rest of the module.
//initial value: 0x0
typedef union __RegVdfVdfScratch1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfScratch1                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t VdfScratch1                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t VdfScratch1                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfScratch1, TRegVdfVdfScratch1, *PTRegVdfVdfScratch1;                                //0x16100

//This is a 14-bit scratch register for use by the LCP in address calculations, the register needs be only 14 bits
//so the values roll over for the calculations which target the other address regisers which are also 14 bits long.
//The register can be written and read, but affects nothing in the rest of the module.
//initial value: 0x0
typedef union __RegVdfVdfScratch2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfScratch2                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t VdfScratch2                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t VdfScratch2                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfScratch2, TRegVdfVdfScratch2, *PTRegVdfVdfScratch2;                                //0x16104

//This is a 14-bit scratch register for use by the LCP in address calculations, the register needs be only 14 bits
//so the values roll over for the calculations which target the other address regisers which are also 14 bits long.
//The register can be written and read, but affects nothing in the rest of the module.
//initial value: 0x0
typedef union __RegVdfVdfScratch3{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfScratch3                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t VdfScratch3                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t VdfScratch3                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfScratch3, TRegVdfVdfScratch3, *PTRegVdfVdfScratch3;                                //0x16108

//This is a 14-bit scratch register for use by the LCP in address calculations, the register needs be only 14 bits
//so the values roll over for the calculations which target the other address regisers which are also 14 bits long.
//The register can be written and read, but affects nothing in the rest of the module.
//initial value: 0x0
typedef union __RegVdfVdfScratch4{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfScratch4                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t VdfScratch4                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t VdfScratch4                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfScratch4, TRegVdfVdfScratch4, *PTRegVdfVdfScratch4;                                //0x1610C

//This is a 14-bit scratch register for use by the LCP in address calculations, the register needs be only 14 bits
//so the values roll over for the calculations which target the other address regisers which are also 14 bits long.
//The register can be written and read, but affects nothing in the rest of the module.
//initial value: 0x0
typedef union __RegVdfVdfScratch5{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t VdfScratch5                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t VdfScratch5                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t VdfScratch5                                       :14         ; //Bits :[0:13], initial value: 0x0.  Read/Write Scratch pad register. No effect on VDF operation.
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfScratch5, TRegVdfVdfScratch5, *PTRegVdfVdfScratch5;                                //0x16110

//This register provides a means for the LCP to disable the automatic shutdown of the VDF buffer memories which occurs
//when a buffer is disabled. In normal operation, if a buffer is not being used (i.e. the bit for that buffer in
// VDF_ENDPOINT_ENABLE is set to 0), the 64K memory in the buffer is shutdown by asserting the 'sd' input the the
//memory. This puts the memory in a low power state, and requires about 80ns to recover. However, this register can
//be used to overide that feature. When the correresponding bit in this register is written with a 1 by the LCP,
// the memory remains in the active state even while the buffer is disabled. This is primarily a debug feature and
//in normal operation this register can be left at zero.
//initial value: 0x0
typedef union __RegVdfVdfBufferMemorySdDisable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t ZBufferMemorySdDisable                            :1          ; //Bits :[0:0], initial value: 0x0. 1= Z buffer memory is not shutdown when the buffer is disabled, 0 = Z buffer memory is shutdown when the buffer is disabled
        uint32_t YBufferMemorySdDisable                            :1          ; //Bits :[1:1], initial value: 0x0. 1= Y buffer memory is not shutdown when the buffer is disabled, 0 = Y buffer memory is shutdown when the buffer is disabled
        uint32_t CBufferMemorySdDisable                            :1          ; //Bits :[2:2], initial value: 0x0. 1= C buffer memory is not shutdown when the buffer is disabled, 0 = C buffer memory is shutdown when the buffer is disabled
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t ZBufferMemorySdDisable                            :1          ; //Bits :[0:0], initial value: 0x0. 1= Z buffer memory is not shutdown when the buffer is disabled, 0 = Z buffer memory is shutdown when the buffer is disabled
        uint32_t YBufferMemorySdDisable                            :1          ; //Bits :[1:1], initial value: 0x0. 1= Y buffer memory is not shutdown when the buffer is disabled, 0 = Y buffer memory is shutdown when the buffer is disabled
        uint32_t CBufferMemorySdDisable                            :1          ; //Bits :[2:2], initial value: 0x0. 1= C buffer memory is not shutdown when the buffer is disabled, 0 = C buffer memory is shutdown when the buffer is disabled
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t ZBufferMemorySdDisable                            :1          ; //Bits :[0:0], initial value: 0x0. 1= Z buffer memory is not shutdown when the buffer is disabled, 0 = Z buffer memory is shutdown when the buffer is disabled
        uint32_t YBufferMemorySdDisable                            :1          ; //Bits :[1:1], initial value: 0x0. 1= Y buffer memory is not shutdown when the buffer is disabled, 0 = Y buffer memory is shutdown when the buffer is disabled
        uint32_t CBufferMemorySdDisable                            :1          ; //Bits :[2:2], initial value: 0x0. 1= C buffer memory is not shutdown when the buffer is disabled, 0 = C buffer memory is shutdown when the buffer is disabled
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfBufferMemorySdDisable, TRegVdfVdfBufferMemorySdDisable, *PTRegVdfVdfBufferMemorySdDisable;                                //0x16114

//This register control  how the bytes are rearranged in the 32-bit dwords received from the CAM module on the csi_a
//pixel bus. The bytes can be rearranged in two ways, either swapping the upper and lower 16-bits, or reversing the
//order of the bytes. This feature is similar to 'big/little endian' select for the other two buffers but since the
//VDF has no way to tell whether the data coming in is big or little endian, assigning a label to either mode is
// would not be accurate. This is not a general purpose big/litte endian select. Any other MIPI data format other
//than an 8-bit or a 16-bit aligned type will be corrupted by enabling this feature. Two other bits change how the
//stowaway frame number is inserted into the last 32 pixels of a frame of CSI data. See the VDF HIS for a bettter
//illustration of how the frame number is inserted. Change this register only when the endpoint being used to transmit
//the data is disabled.
//initial value: 0x0
typedef union __RegVdfWebcamCsiASwap{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CsiAWordSwap                                      :2          ; //Bits :[0:1], initial value: 0x0. 00 = CSI Data a swapping disabled.                        01 = CSI Data a word swap enabled - in ABCD, out CDAB.                       10 = CSI Data a byte swap enabled - in ABCD, out DCBA.                       11 = CSI Data a byte swap enabled - in ABCD, out DCBA. (same as 10)
        uint32_t CsiAStowawayBitSwap                               :2          ; //Bits :[2:3], initial value: 0x0. 00 =  Stowaway bits start in pixel n-30, Bit 16  in the Pixel n-30,n-31 dword. (As in DS4).                        01 =  Stowaway bits start in pixel n-31, Bit  0  in the Pixel n-30,n-31 dword.                        10 =  Stowaway bits start in pixel n-30, Bit 24  in the Pixel n-30,n-31 dword.                        11 =  Stowaway bits start in pixel n-30, Bit  8  in the Pixel n-30,n-31 dword.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t CsiAWordSwap                                      :2          ; //Bits :[0:1], initial value: 0x0. 00 = CSI Data a swapping disabled.                        01 = CSI Data a word swap enabled - in ABCD, out CDAB.                       10 = CSI Data a byte swap enabled - in ABCD, out DCBA.                       11 = CSI Data a byte swap enabled - in ABCD, out DCBA. (same as 10)
        uint32_t CsiAStowawayBitSwap                               :2          ; //Bits :[2:3], initial value: 0x0. 00 =  Stowaway bits start in pixel n-30, Bit 16  in the Pixel n-30,n-31 dword. (As in DS4).                        01 =  Stowaway bits start in pixel n-31, Bit  0  in the Pixel n-30,n-31 dword.                        10 =  Stowaway bits start in pixel n-30, Bit 24  in the Pixel n-30,n-31 dword.                        11 =  Stowaway bits start in pixel n-30, Bit  8  in the Pixel n-30,n-31 dword.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t CsiAWordSwap                                      :2          ; //Bits :[0:1], initial value: 0x0. 00 = CSI Data a swapping disabled.                        01 = CSI Data a word swap enabled - in ABCD, out CDAB.                       10 = CSI Data a byte swap enabled - in ABCD, out DCBA.                       11 = CSI Data a byte swap enabled - in ABCD, out DCBA. (same as 10)
        uint32_t CsiAStowawayBitSwap                               :2          ; //Bits :[2:3], initial value: 0x0. 00 =  Stowaway bits start in pixel n-30, Bit 16  in the Pixel n-30,n-31 dword. (As in DS4).                        01 =  Stowaway bits start in pixel n-31, Bit  0  in the Pixel n-30,n-31 dword.                        10 =  Stowaway bits start in pixel n-30, Bit 24  in the Pixel n-30,n-31 dword.                        11 =  Stowaway bits start in pixel n-30, Bit  8  in the Pixel n-30,n-31 dword.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamCsiASwap, TRegVdfWebcamCsiASwap, *PTRegVdfWebcamCsiASwap;                                //0x16118

//Two bits in this register control  how the bytes are rearranged in the 32-bit dwords received from the CAM module
//on the csi_ab pixel bus. The bytes can be rearranged in two ways, either swapping the upper and lower 16-bits (word-invarient
//, or reversing the order of the bytes. This feature is similar to 'big/little endian' select for the other two
// buffers but since the VDF has no way to tell whether the data coming in is big or little endian, assigning a label
//to either mode is would not be accurate. This is not a general purpose big/litte endian select. Any other MIPI
// data format other than an 8-bit or a 16-bit aligned type will be corrupted by enabling this feature.  Two other
//bits change how the stowaway frame number is inserted into the last 32 pixels of a frame of CSI data. See the VDF
//HIS for a bettter illustration of how the frame number is inserted. Change this register only when the endpoint
//being used to transmit the data is disabled.
//initial value: 0x0
typedef union __RegVdfWebcamCsiBSwap{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CsiBWordSwap                                      :2          ; //Bits :[0:1], initial value: 0x0. 00 = CSI Data b swapping disabled.                        01 = CSI Data b word swap enabled - in ABCD, out CDAB.                       10 = CSI Data b byte swap enabled - in ABCD, out DCBA.                       11 = Reserverd (Should be the same ame as 10 above)
        uint32_t CsiBStowawayBitSwap                               :2          ; //Bits :[2:3], initial value: 0x0. 00 =  Stowaway bits start in pixel n-30, Bit 16  in the Pixel n-30,n-31 dword. (As in DS4).                        01 =  Stowaway bits start in pixel n-31, Bit  0  in the Pixel n-30,n-31 dword.                        10 =  Stowaway bits start in pixel n-30, Bit 24  in the Pixel n-30,n-31 dword.                        11 =  Stowaway bits start in pixel n-30, Bit  8  in the Pixel n-30,n-31 dword.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t CsiBWordSwap                                      :2          ; //Bits :[0:1], initial value: 0x0. 00 = CSI Data b swapping disabled.                        01 = CSI Data b word swap enabled - in ABCD, out CDAB.                       10 = CSI Data b byte swap enabled - in ABCD, out DCBA.                       11 = Reserverd (Should be the same ame as 10 above)
        uint32_t CsiBStowawayBitSwap                               :2          ; //Bits :[2:3], initial value: 0x0. 00 =  Stowaway bits start in pixel n-30, Bit 16  in the Pixel n-30,n-31 dword. (As in DS4).                        01 =  Stowaway bits start in pixel n-31, Bit  0  in the Pixel n-30,n-31 dword.                        10 =  Stowaway bits start in pixel n-30, Bit 24  in the Pixel n-30,n-31 dword.                        11 =  Stowaway bits start in pixel n-30, Bit  8  in the Pixel n-30,n-31 dword.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t CsiBWordSwap                                      :2          ; //Bits :[0:1], initial value: 0x0. 00 = CSI Data b swapping disabled.                        01 = CSI Data b word swap enabled - in ABCD, out CDAB.                       10 = CSI Data b byte swap enabled - in ABCD, out DCBA.                       11 = Reserverd (Should be the same ame as 10 above)
        uint32_t CsiBStowawayBitSwap                               :2          ; //Bits :[2:3], initial value: 0x0. 00 =  Stowaway bits start in pixel n-30, Bit 16  in the Pixel n-30,n-31 dword. (As in DS4).                        01 =  Stowaway bits start in pixel n-31, Bit  0  in the Pixel n-30,n-31 dword.                        10 =  Stowaway bits start in pixel n-30, Bit 24  in the Pixel n-30,n-31 dword.                        11 =  Stowaway bits start in pixel n-30, Bit  8  in the Pixel n-30,n-31 dword.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfWebcamCsiBSwap, TRegVdfWebcamCsiBSwap, *PTRegVdfWebcamCsiBSwap;                                //0x1611C

//This register is the address of the first byte of a packet of data in the NSE Memory. When the VDF is configured
//to send MIPI packets from the NSE buffer memory, this register points to the first byte to be sent in the MIPI
// long packet. Although the register is 32 bits, only the least significant 14 bits are retained and used for fetching
//the data. The LCP must write the data into the NSE buffer. The address of the first byte in the packet must be
// a dword address - bits 0 and 1 are ignored.
//initial value: 0x0
typedef union __RegVdfNseMipiDataPacketStartAddress{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NseBufferMipiDataPacketStartAddress               :14         ; //Bits :[0:13], initial value: 0x0. Start Address of the MIPI packet data in the NSE buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t NseBufferMipiDataPacketStartAddress               :14         ; //Bits :[0:13], initial value: 0x0. Start Address of the MIPI packet data in the NSE buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t NseBufferMipiDataPacketStartAddress               :14         ; //Bits :[0:13], initial value: 0x0. Start Address of the MIPI packet data in the NSE buffer
        uint32_t Reserved                                          :18         ; //Bits :[14:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfNseMipiDataPacketStartAddress, TRegVdfNseMipiDataPacketStartAddress, *PTRegVdfNseMipiDataPacketStartAddress;                                //0x16120

//The number of bytes in the MIPI Packet that the LCP sets up in the NSE buffer. The maximum number of bytes that
//can be sent in a MIPI packet is 1024. If a number larger than 1024 (0x400) is written, anomalous behavior may result.
//The packets size can be any number of bytes up to the maximun, it is not required to be an integer number of dwords
//or words
//initial value: 0x0
typedef union __RegVdfNseMipiDataPacketSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NseMipiDataPacketSize                             :11         ; //Bits :[0:10], initial value: 0x0. Size of the MIPI packet data in the NSE buffer
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t NseMipiDataPacketSize                             :11         ; //Bits :[0:10], initial value: 0x0. Size of the MIPI packet data in the NSE buffer
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t NseMipiDataPacketSize                             :11         ; //Bits :[0:10], initial value: 0x0. Size of the MIPI packet data in the NSE buffer
        uint32_t Reserved                                          :21         ; //Bits :[11:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfNseMipiDataPacketSize, TRegVdfNseMipiDataPacketSize, *PTRegVdfNseMipiDataPacketSize;                                //0x16124

//This register specifies the MIPI Data type that will be sent in the header of the data packet sent from the NSE
//buffer memory. The normal value is 0x12 as per the MIPI.
//initial value: 0x12
typedef union __RegVdfNseMipiPacketDt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NseMipiPacketDataType                             :6          ; //Bits :[0:5], initial value: 0x12.  NSE MIPI Packet Data Type
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t NseMipiPacketDataType                             :6          ; //Bits :[0:5], initial value: 0x12.  NSE MIPI Packet Data Type
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t NseMipiPacketDataType                             :6          ; //Bits :[0:5], initial value: 0x12.  NSE MIPI Packet Data Type
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfNseMipiPacketDt, TRegVdfNseMipiPacketDt, *PTRegVdfNseMipiPacketDt;                                //0x16128

//This register specifies the MIPI Virtual Channel that will be sent in the header of the data packet sent from the
//NSE buffer memory. It should be normally be set to the same VC as the video data it is being sent with
//initial value: 0x0
typedef union __RegVdfNseMipiPacketVc{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NseMipiPacketVirtualChannel                       :2          ; //Bits :[0:1], initial value: 0x0.  NSE MIPI Packet Virtual Channel
        uint32_t Reserved2                                         :1          ; //Bits :[2:2], initial value: 0x0 Reserved.
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t NseMipiPacketVirtualChannel                       :2          ; //Bits :[0:1], initial value: 0x0.  NSE MIPI Packet Virtual Channel
        uint32_t Reserved2                                         :1          ; //Bits :[2:2], initial value: 0x0 Reserved.
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t NseMipiPacketVirtualChannel                       :2          ; //Bits :[0:1], initial value: 0x0.  NSE MIPI Packet Virtual Channel
        uint32_t Reserved2                                         :1          ; //Bits :[2:2], initial value: 0x0 Reserved.
        uint32_t Reserved                                          :29         ; //Bits :[3:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfNseMipiPacketVc, TRegVdfNseMipiPacketVc, *PTRegVdfNseMipiPacketVc;                                //0x1612C

//Writing a 1 to this register will initiate the ttransmission of a MIPI Frame consisting of one packet of embedded
//data read from the non-streaming buffer. The data packet is preceded by a FS packet, and followed by FE packet.
//Note that an interrupt (vdf_csr_nse_mipi_tx_done_intr) is asserted whn the transmission of the FE packet for the
//embedded dats. After the LCP writes the register with a 1 to initiate a transmission, the bit says 1 until the
// FE is transmitted (sent tot he MTR).
//initial value: 0x0
typedef union __RegVdfNseMipiPacketStart{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NseMipiPacketStartAndTransmissionStatus           :1          ; //Bits :[0:0], initial value: 0x0.  This register can be written with a 1 to initiate a packet transmission. The H/W clears the register when the packet transmission is complete.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t NseMipiPacketStartAndTransmissionStatus           :1          ; //Bits :[0:0], initial value: 0x0.  This register can be written with a 1 to initiate a packet transmission. The H/W clears the register when the packet transmission is complete.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t NseMipiPacketStartAndTransmissionStatus           :1          ; //Bits :[0:0], initial value: 0x0.  This register can be written with a 1 to initiate a packet transmission. The H/W clears the register when the packet transmission is complete.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfNseMipiPacketStart, TRegVdfNseMipiPacketStart, *PTRegVdfNseMipiPacketStart;                                //0x16130

//This register determines the number of sclks in a single tick of the Source Time Clock, which is used in the UVC
//Header. Each tick advances the STC by 1. Changing this register will change the rate at which the STC counter increments.
//Setting this register to 1 or 0 will disbale the STC. The default value targets a STC frequency of 1MHz, assuming
//an sclk frequency of 333MHz
//initial value: 0x20000
typedef union __RegVdfStcFrequencyCount{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t StcFrequencyCount                                 :20         ; //Bits :[0:19], initial value: 0x20000. Numeber of SCLKs in one tick of the STC counter
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t StcFrequencyCount                                 :20         ; //Bits :[0:19], initial value: 0x20000. Numeber of SCLKs in one tick of the STC counter
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t StcFrequencyCount                                 :20         ; //Bits :[0:19], initial value: 0x20000. Numeber of SCLKs in one tick of the STC counter
        uint32_t Reserved                                          :12         ; //Bits :[20:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfStcFrequencyCount, TRegVdfStcFrequencyCount, *PTRegVdfStcFrequencyCount;                                //0x16134

//This register  provides the LCP with the capability to set  the 32-bit STC to an arbitrary value. When the register
//is written, the current value of the STC is replaced with the contents of this register. This register remains
// static - it does not increment with the STC counter
//initial value: 0x0
typedef union __RegVdfStcStartCount{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t StcStartCount                                     :32         ; //Bits :[0:31], initial value: 0x0. New STC Counter Value
     } fields_read;
    struct {
        uint32_t StcStartCount                                     :32         ; //Bits :[0:31], initial value: 0x0. New STC Counter Value
     } fields_write;
    struct {
        uint32_t StcStartCount                                     :32         ; //Bits :[0:31], initial value: 0x0. New STC Counter Value
     } fields_rmw; //for non-shadowed register
} RegVdfStcStartCount, TRegVdfStcStartCount, *PTRegVdfStcStartCount;                                //0x16138

//The current value of the STC Counter.
//initial value: 0x0
typedef union __RegVdfStcCount{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t StcCount                                          :32         ; //Bits :[0:31], initial value: 0x0. Current value of the free-running 32-bit STC counter
     } fields_read;
    struct {
        uint32_t StcCount                                          :32         ; //Bits :[0:31], initial value: 0x0. Current value of the free-running 32-bit STC counter
     } fields_rmw; //for non-shadowed register
} RegVdfStcCount, TRegVdfStcCount, *PTRegVdfStcCount;                                //0x1613C

//Provides a means of adjusting the tick for the Source Time Clock to more closely match a desired frequency. When
//this register set to a non-zero value, the period of the tick for the STC is increased by one after the number
// of ticks defined in this register is sent. For example, if the STC Frequency Count is set to 33 and this register
//(STC Correction Count) is set to 2, the length of the ticks (in sclk periods) will 33,33,34,33,33,34,33 etc. The
//defualt value assumes a target frequency of 1MHz and an sclk frequency of 333MHz.
//initial value: 0x2
typedef union __RegVdfStcCorrectionCount{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t StcCorrectionCount                                :16         ; //Bits :[0:15], initial value: 0x2. STC
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t StcCorrectionCount                                :16         ; //Bits :[0:15], initial value: 0x2. STC
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t StcCorrectionCount                                :16         ; //Bits :[0:15], initial value: 0x2. STC
        uint32_t Reserved                                          :16         ; //Bits :[16:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfStcCorrectionCount, TRegVdfStcCorrectionCount, *PTRegVdfStcCorrectionCount;                                //0x16140

//This is a debug register. When the USB Core completes a TRB, it writes back the two 32-bit dwords. This register
//shows the latest low dowrd written back by the USB Core. See the Synosys data book for details.
//initial value: 0x0
typedef union __RegVdfUsbCoreTrbWriteBack0{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TrbWriteBack0                                     :32         ; //Bits :[0:31], initial value: 0x0. Last Low Dword written back by the Synopsys USB core to any TRB address
     } fields_read;
    struct {
        uint32_t TrbWriteBack0                                     :32         ; //Bits :[0:31], initial value: 0x0. Last Low Dword written back by the Synopsys USB core to any TRB address
     } fields_rmw; //for non-shadowed register
} RegVdfUsbCoreTrbWriteBack0, TRegVdfUsbCoreTrbWriteBack0, *PTRegVdfUsbCoreTrbWriteBack0;                                //0x16144

//This is a debug register. When the USB Core completes a TRB, it writes back the two 32-bit dwords. This register
//shows the latest high dowrd written back by the USB Core. See the Synosys data book for details.
//initial value: 0x0
typedef union __RegVdfUsbCoreTrbWriteBack1{ //register type:RO shadowed:NO
    uint32_t value_read;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t TrbWriteBack1                                     :32         ; //Bits :[0:31], initial value: 0x0. Last High Dword written back by the Synopsys USB core to any TRB address
     } fields_read;
    struct {
        uint32_t TrbWriteBack1                                     :32         ; //Bits :[0:31], initial value: 0x0. Last High Dword written back by the Synopsys USB core to any TRB address
     } fields_rmw; //for non-shadowed register
} RegVdfUsbCoreTrbWriteBack1, TRegVdfUsbCoreTrbWriteBack1, *PTRegVdfUsbCoreTrbWriteBack1;                                //0x16148

//Enables combining the data from the depth buffer and the data from the Rec buffer into a single MIPI Frame, and
//allows both to be sent in the same virtual channel.  The firmware is responsible for managing the MIPI VCs, MIPI
//DTs, and frame coherency of the two buffer that are combined. There are numerous restrictions on the legitimate
//configurations of the VDF and DS5 and imagers for these modes of operation, see the documentation for details.
//initial value: 0x0
typedef union __RegVdfMipiCombinedDataMode{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t MipiTwoBufferCombinationMode                      :1          ; //Bits :[0:0], initial value: 0x0. 0 Disable MIPI Two Buffer Combination Mode.                       1 Combine Depth Buffer Data plus REC Buffer Data in the same MIPI frame.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t MipiTwoBufferCombinationMode                      :1          ; //Bits :[0:0], initial value: 0x0. 0 Disable MIPI Two Buffer Combination Mode.                       1 Combine Depth Buffer Data plus REC Buffer Data in the same MIPI frame.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t MipiTwoBufferCombinationMode                      :1          ; //Bits :[0:0], initial value: 0x0. 0 Disable MIPI Two Buffer Combination Mode.                       1 Combine Depth Buffer Data plus REC Buffer Data in the same MIPI frame.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfMipiCombinedDataMode, TRegVdfMipiCombinedDataMode, *PTRegVdfMipiCombinedDataMode;                                //0x1614C

//In MIPI Mode, this register defines the number of bytes in the MIPI embedded data packet sent for the UVC header.
//The first 68 bytes of the Depth extended UVC header are contained in the VDF mocule and can be sent as an embedded
//data packet, transmitted immediately after the MIPI FS is transmitted. If the Depth buffer streaming data is being
//combined with the Rec buffer streaming data it is reccomneded not to enable the Depth buffer MIPI UVC embedded
// data packet since it will be sent when the Depth data begins, not immediately following the FS for the combination
//MIPI frame. The size defined in this register is in bytes. The maximum allowed value is 68 bytes in MIPI mode.
// In USB mode this register can be a maximum of 256 bytes. In USB Mode the additional 188 bytes are read from the
//the NSE memory, not the VDF. In both USB and MIPI Mode, The value of this register appears in byte 0 of the UVC
//header, in the bHeaderLength field.
//initial value: 0x0c
typedef union __RegVdfDepthBufferMipiUvcSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferUvcEmbeddedDataPacketSizeInBytes       :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Depth (Z) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t DepthBufferUvcEmbeddedDataPacketSizeInBytes       :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Depth (Z) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t DepthBufferUvcEmbeddedDataPacketSizeInBytes       :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Depth (Z) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferMipiUvcSize, TRegVdfDepthBufferMipiUvcSize, *PTRegVdfDepthBufferMipiUvcSize;                                //0x16150

//The MIPI data type (DT) that will be sent on the Depth Buffer Extended UVC Header Embedded MIPI packet. This data
//type is also used for the embedded data packet which is read from the CAM module.
//initial value: 0x12
typedef union __RegVdfDepthBufferMipiUvcDt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferExtendedUvcHeaderEmbeddedMipiPacketDt  :6          ; //Bits :[0:5], initial value: 0x12. Depth Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t DepthBufferExtendedUvcHeaderEmbeddedMipiPacketDt  :6          ; //Bits :[0:5], initial value: 0x12. Depth Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t DepthBufferExtendedUvcHeaderEmbeddedMipiPacketDt  :6          ; //Bits :[0:5], initial value: 0x12. Depth Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferMipiUvcDt, TRegVdfDepthBufferMipiUvcDt, *PTRegVdfDepthBufferMipiUvcDt;                                //0x16154

//Three different MIPI Embedded Data Packets can be enabled to be sent immediately following the MIPI FS packet.
// The first 68 bytes of the extended UVC header can be sent, Data which received from the CAM module from one of
//the input MIPI steams can be sent, and a packet from the Non-streaming endpoint buffer can be sent. Only the first
//two are expected to be used, the last is for debug only. This register enables these three embedded data packets.
//The UVC packet is sent first, followed by the Data from the Cam module, followed by the data from the nonstreaming
//buffer. The DT specified in the DEPTH_BUFFER_MIPI_UVC_DT CSR is used for both the UVC data packet and data packet
//from the CAM. The DT for the packet sent from the non-streaming buffer is specified NSE_MIPI_PACKET_DT. All three
//embedded data packets will have the VC defined in the DEPTH_VIRTUAL_CHANNEL register
//initial value: 0x0
typedef union __RegVdfDepthBufferMipiEmbeddedDataPacketEn{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t DepthBufferCamDataEmbeddedMipiPacketEnable        :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t DepthBufferCamDataEmbeddedMipiPacketMode          :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t DepthBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t DepthBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t DepthBufferCamDataEmbeddedMipiPacketEnable        :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t DepthBufferCamDataEmbeddedMipiPacketMode          :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t DepthBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t DepthBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t DepthBufferCamDataEmbeddedMipiPacketEnable        :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t DepthBufferCamDataEmbeddedMipiPacketMode          :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t DepthBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfDepthBufferMipiEmbeddedDataPacketEn, TRegVdfDepthBufferMipiEmbeddedDataPacketEn, *PTRegVdfDepthBufferMipiEmbeddedDataPacketEn;                                //0x16158

//In MIPI Mode, this register defines the number of bytes in the MIPI embedded data packet sent for the UVC header.
//The first 68 bytes of the Rec buffer extended UVC header are contained in the VDF mocule and can be sent as an
// embedded data packet, transmitted immediately after the MIPI FS is transmitted. If the REC buffer streaming data
//is being combined with the Depth buffer streaming data it is reccomneded not to enable the Depth buffer MIPI UVC
//embedded data packet since the Depth packet will be sent when the Depth data begins, not immediately following
// the FS for the combination MIPI frame. The size defined in this register is in bytes. The maximum allowed value
//is 68 bytes in MIPI mode. In USB mode this register can be a maximum of 256 bytes. In USB Mode the additional 188
//bytes are read from the the NSE memory, not the VDF. In both USB and MIPI Mode, The value of this register appears
//in byte 0 of the UVC header, in the bHeaderLength field.
//initial value: 0x0c
typedef union __RegVdfRecBufferMipiUvcSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RecBufferUvcEmbeddedDataPacketSizeInBytes         :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Rec (Y) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t RecBufferUvcEmbeddedDataPacketSizeInBytes         :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Rec (Y) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t RecBufferUvcEmbeddedDataPacketSizeInBytes         :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Rec (Y) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfRecBufferMipiUvcSize, TRegVdfRecBufferMipiUvcSize, *PTRegVdfRecBufferMipiUvcSize;                                //0x1615C

//The MIPI data type (DT) that will be sent on the Rec Buffer Extended UVC Header Embedded MIPI packet. This data
//type is also used for the embedded data packet which is read from the CAM module.
//initial value: 0x12
typedef union __RegVdfRecBufferMipiUvcDt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RecBufferExtendedUvcHeaderEmbeddedMipiPacketDt    :6          ; //Bits :[0:5], initial value: 0x12. Rec Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t RecBufferExtendedUvcHeaderEmbeddedMipiPacketDt    :6          ; //Bits :[0:5], initial value: 0x12. Rec Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t RecBufferExtendedUvcHeaderEmbeddedMipiPacketDt    :6          ; //Bits :[0:5], initial value: 0x12. Rec Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfRecBufferMipiUvcDt, TRegVdfRecBufferMipiUvcDt, *PTRegVdfRecBufferMipiUvcDt;                                //0x16160

//Three different MIPI Embedded Data Packets can be enabled to be sent immediately following the MIPI FS packet.
// The first 68 bytes of the extended UVC header can be sent, Data which received from the CAM module from one of
//the input MIPI steams can be sent, and a packet from the Non-streaming endpoint buffer can be sent. Only the first
//two are expected to be used, the last is for debug only. This register enables these three embedded data packets.
//The UVC packet is sent first, followed by the Data from the Cam module, followed by the data from the nonstreaming
//buffer. The DT specified in the REC_BUFFER_MIPI_UVC_DT CSR is used for both the UVC data packet and data packet
//from the CAM. The DT for the packet sent from the non-streaming buffer is specified NSE_MIPI_PACKET_DT. All three
//embedded data packets will have the VC defined in the REC_VIRTUAL_CHANNEL register
//initial value: 0x0
typedef union __RegVdfRecBufferMipiEmbeddedDataPacketEn{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t RecBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t RecBufferCamDataEmbeddedMipiPacketEnable          :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t RecBufferCamDataEmbeddedMipiPacketMode            :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t RecBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t RecBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t RecBufferCamDataEmbeddedMipiPacketEnable          :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t RecBufferCamDataEmbeddedMipiPacketMode            :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t RecBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t RecBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t RecBufferCamDataEmbeddedMipiPacketEnable          :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t RecBufferCamDataEmbeddedMipiPacketMode            :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t RecBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfRecBufferMipiEmbeddedDataPacketEn, TRegVdfRecBufferMipiEmbeddedDataPacketEn, *PTRegVdfRecBufferMipiEmbeddedDataPacketEn;                                //0x16164

//In MIPI Mode, this register defines the number of bytes in the MIPI embedded data packet sent for the UVC header.
//The first 68 bytes of the Depth extended UVC header are contained in the VDF mocule and can be sent as an embedded
//data packet, transmitted immediately after the MIPI FS is transmitted. The size defined in this register is in
// bytes. The maximum allowed value is 68 bytes in MIPI mode. In USB mode this register can be a maximum of 256 bytes.
//In USB Mode the additional 188 bytes are read from the the NSE memory, not the VDF. In both USB and MIPI Mode,
// The value of this register appears in byte 0 of the UVC header, in the bHeaderLength field.
//initial value: 0x0c
typedef union __RegVdfCamBufferMipiUvcSize{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamBufferUvcEmbeddedDataPacketSizeInBytes         :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Cam (C) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t CamBufferUvcEmbeddedDataPacketSizeInBytes         :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Cam (C) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t CamBufferUvcEmbeddedDataPacketSizeInBytes         :9          ; //Bits :[0:8], initial value: 0xC. 1 = Number of bytes that will be sent in the MIPI stream from the Cam (C) buffer in the UVC Embedded data packet, and in the  bHeaderLength field.
        uint32_t Reserved                                          :23         ; //Bits :[9:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfCamBufferMipiUvcSize, TRegVdfCamBufferMipiUvcSize, *PTRegVdfCamBufferMipiUvcSize;                                //0x16168

//The MIPI data type (DT) that will be sent on the Cam Buffer Extended UVC Header Embedded MIPI packet. This data
//type is also used for the embedded data packet which is read from the CAM module.
//initial value: 0x12
typedef union __RegVdfCamBufferMipiUvcDt{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamBufferExtendedUvcHeaderEmbeddedMipiPacketDt    :6          ; //Bits :[0:5], initial value: 0x12. Cam Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t CamBufferExtendedUvcHeaderEmbeddedMipiPacketDt    :6          ; //Bits :[0:5], initial value: 0x12. Cam Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t CamBufferExtendedUvcHeaderEmbeddedMipiPacketDt    :6          ; //Bits :[0:5], initial value: 0x12. Cam Buffer Extended UVC Header Embedded MIPI packet DT
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfCamBufferMipiUvcDt, TRegVdfCamBufferMipiUvcDt, *PTRegVdfCamBufferMipiUvcDt;                                //0x1616C

//Three different MIPI Embedded Data Packets can be enabled to be sent immediately following the MIPI FS packet.
// The first 68 bytes of the extended UVC header can be sent, Data which received from the CAM module from one of
//the input MIPI steams can be sent, and a packet from the Non-streaming endpoint buffer can be sent. Only the first
//two are expected to be used, the last is for debug only. This register enables these three embedded data packets.
//The UVC packet is sent first, followed by the Data from the Cam module, followed by the data from the nonstreaming
//buffer. The DT specified in the CAM_BUFFER_MIPI_UVC_DT CSR is used for both the UVC data packet and data packet
//from the CAM. The DT for the packet sent from the non-streaming buffer is specified NSE_MIPI_PACKET_DT. All three
//embedded data packets will have the VC defined in the CAM_VIRTUAL_CHANNEL register
//initial value: 0x0
typedef union __RegVdfCamBufferMipiEmbeddedDataPacketEn{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t CamBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t CamBufferCamDataEmbeddedMipiPacketEnable          :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t CamBufferCamDataEmbeddedMipiPacketMode            :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t CamBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t CamBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t CamBufferCamDataEmbeddedMipiPacketEnable          :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t CamBufferCamDataEmbeddedMipiPacketMode            :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t CamBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t CamBufferExtendedUvcHeaderEmbeddedMipiPacketEnable:1          ; //Bits :[0:0], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t CamBufferCamDataEmbeddedMipiPacketEnable          :1          ; //Bits :[1:1], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable
        uint32_t CamBufferCamDataEmbeddedMipiPacketMode            :1          ; //Bits :[2:2], initial value: 0x0. 1 = Send Packet only when new data is received. 0 = Send most recent data with every frame, even if already sent
        uint32_t CamBufferNonStreamingBufferDataEmbeddedMipiPacketEnable:1          ; //Bits :[3:3], initial value: 0x0. 1 = Packet Enabled. 0 = Packet Disable. Don't use this mode except for hardware chip debug. Not for software debug. Don't use.
        uint32_t Reserved                                          :28         ; //Bits :[4:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfCamBufferMipiEmbeddedDataPacketEn, TRegVdfCamBufferMipiEmbeddedDataPacketEn, *PTRegVdfCamBufferMipiEmbeddedDataPacketEn;                                //0x16170

//UVC Extended Header dword 4. There are 13 CSRs for the extended header for the depth buffer, 04 - 16. This data
//can be sent out as an extended UVC header in USB3 mode appended to the lower 4 dwords (dwords 0 - 3) of the header
//which are generated by HW. In MIPI mode, the UVC header data can be transmitted as an embedded MIPI data packet.
//There are CSRs for the Z (Depth, EP2) buffer and the C (CAM, EP4) buffer, but none for the Y (Rec, EP3) buffer.
//All of the Extended Header CSR's hav shadow registers. When hardware control of the USB interface is controlled
//by the TPROC module, the shadow register, which sit between the APB registers and the rest of the logic, are updated
//only on a signal from the TPROC, or when the appropriate bit in the UVC_HDR_SHADOW_UPDATE CSR is written to. When
//hardware conrol is disabled, the shadow registers are transparent.
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ04{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword4                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 4
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword4                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 4
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword4                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 4
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ04, TRegVdfUvcExtHdrZ04, *PTRegVdfUvcExtHdrZ04;                                //0x16174

//UVC Extended Header dword 5
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ05{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword5                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 5
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword5                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 5
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword5                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 5
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ05, TRegVdfUvcExtHdrZ05, *PTRegVdfUvcExtHdrZ05;                                //0x16178

//UVC Extended Header dword 6
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ06{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword6                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 6
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword6                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 6
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword6                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 6
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ06, TRegVdfUvcExtHdrZ06, *PTRegVdfUvcExtHdrZ06;                                //0x1617C

//UVC Extended Header dword 7
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ07{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword7                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 7
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword7                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 7
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword7                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 7
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ07, TRegVdfUvcExtHdrZ07, *PTRegVdfUvcExtHdrZ07;                                //0x16180

//UVC Extended Header dword 8
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ08{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword8                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 8
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword8                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 8
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword8                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 8
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ08, TRegVdfUvcExtHdrZ08, *PTRegVdfUvcExtHdrZ08;                                //0x16184

//UVC Extended Header dword 9
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ09{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword9                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 9
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword9                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 9
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword9                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 9
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ09, TRegVdfUvcExtHdrZ09, *PTRegVdfUvcExtHdrZ09;                                //0x16188

//UVC Extended Header dword 10
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ10{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword10                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 10
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword10                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 10
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword10                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 10
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ10, TRegVdfUvcExtHdrZ10, *PTRegVdfUvcExtHdrZ10;                                //0x1618C

//UVC Extended Header dword 11
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ11{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword11                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 11
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword11                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 11
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword11                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 11
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ11, TRegVdfUvcExtHdrZ11, *PTRegVdfUvcExtHdrZ11;                                //0x16190

//UVC Extended Header dword 12
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ12{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword12                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 12
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword12                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 12
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword12                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 12
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ12, TRegVdfUvcExtHdrZ12, *PTRegVdfUvcExtHdrZ12;                                //0x16194

//UVC Extended Header dword 13
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ13{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword13                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 13
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword13                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 13
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword13                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 13
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ13, TRegVdfUvcExtHdrZ13, *PTRegVdfUvcExtHdrZ13;                                //0x16198

//UVC Extended Header dword 14
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ14{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword14                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 14
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword14                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 14
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword14                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 14
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ14, TRegVdfUvcExtHdrZ14, *PTRegVdfUvcExtHdrZ14;                                //0x1619C

//UVC Extended Header dword 15
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ15{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword15                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 15
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword15                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 15
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword15                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 15
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ15, TRegVdfUvcExtHdrZ15, *PTRegVdfUvcExtHdrZ15;                                //0x161A0

//UVC Extended Header dword 16
//initial value: 0x0
typedef union __RegVdfUvcExtHdrZ16{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword16                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 16
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword16                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 16
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword16                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 16
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrZ16, TRegVdfUvcExtHdrZ16, *PTRegVdfUvcExtHdrZ16;                                //0x161A4

//UVC Extended Header dword 4
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC04{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword4                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 4
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword4                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 4
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword4                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 4
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC04, TRegVdfUvcExtHdrC04, *PTRegVdfUvcExtHdrC04;                                //0x161A8

//UVC Extended Header dword 5
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC05{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword5                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 5
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword5                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 5
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword5                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 5
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC05, TRegVdfUvcExtHdrC05, *PTRegVdfUvcExtHdrC05;                                //0x161AC

//UVC Extended Header dword 6
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC06{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword6                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 6
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword6                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 6
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword6                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 6
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC06, TRegVdfUvcExtHdrC06, *PTRegVdfUvcExtHdrC06;                                //0x161B0

//UVC Extended Header dword 7
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC07{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword7                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 7
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword7                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 7
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword7                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 7
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC07, TRegVdfUvcExtHdrC07, *PTRegVdfUvcExtHdrC07;                                //0x161B4

//UVC Extended Header dword 8
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC08{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword8                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 8
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword8                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 8
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword8                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 8
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC08, TRegVdfUvcExtHdrC08, *PTRegVdfUvcExtHdrC08;                                //0x161B8

//UVC Extended Header dword 9
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC09{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword9                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 9
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword9                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 9
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword9                           :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 9
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC09, TRegVdfUvcExtHdrC09, *PTRegVdfUvcExtHdrC09;                                //0x161BC

//UVC Extended Header dword 10
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC10{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword10                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 10
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword10                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 10
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword10                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 10
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC10, TRegVdfUvcExtHdrC10, *PTRegVdfUvcExtHdrC10;                                //0x161C0

//UVC Extended Header dword 11
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC11{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword11                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 11
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword11                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 11
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword11                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 11
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC11, TRegVdfUvcExtHdrC11, *PTRegVdfUvcExtHdrC11;                                //0x161C4

//UVC Extended Header dword 12
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC12{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword12                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 12
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword12                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 12
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword12                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 12
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC12, TRegVdfUvcExtHdrC12, *PTRegVdfUvcExtHdrC12;                                //0x161C8

//UVC Extended Header dword 13
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC13{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword13                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 13
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword13                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 13
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword13                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 13
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC13, TRegVdfUvcExtHdrC13, *PTRegVdfUvcExtHdrC13;                                //0x161CC

//UVC Extended Header dword 14
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC14{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword14                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 14
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword14                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 14
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword14                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 14
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC14, TRegVdfUvcExtHdrC14, *PTRegVdfUvcExtHdrC14;                                //0x161D0

//UVC Extended Header dword 15
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC15{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword15                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 15
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword15                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 15
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword15                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 15
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC15, TRegVdfUvcExtHdrC15, *PTRegVdfUvcExtHdrC15;                                //0x161D4

//UVC Extended Header dword 16
//initial value: 0x0
typedef union __RegVdfUvcExtHdrC16{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t UvcExtendedHeaderDword16                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 16
     } fields_read;
    struct {
        uint32_t UvcExtendedHeaderDword16                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 16
     } fields_write;
    struct {
        uint32_t UvcExtendedHeaderDword16                          :32         ; //Bits :[0:31], initial value: 0x0. UVC Extended Header dword 16
     } fields_rmw; //for non-shadowed register
} RegVdfUvcExtHdrC16, TRegVdfUvcExtHdrC16, *PTRegVdfUvcExtHdrC16;                                //0x161D8

//Enables the LCP to send MIPI packets from the Non-Streaming buffer in the VDF module. This register must be written
//with a one to allow the LCP to send MIPI packets from the Non-Streaming Buffer. When this register is set to 1,
//then the USB core loses it's access to the the non-streaming buffer.
//initial value: 0x0
typedef union __RegVdfNseBufferMipiEn{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t NseBufferMipiEnable                               :1          ; //Bits :[0:0], initial value: 0x0. 0 = NSE buffer MIPI TX disabled. 1 = NSE buffer MIPI Packets enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t NseBufferMipiEnable                               :1          ; //Bits :[0:0], initial value: 0x0. 0 = NSE buffer MIPI TX disabled. 1 = NSE buffer MIPI Packets enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t NseBufferMipiEnable                               :1          ; //Bits :[0:0], initial value: 0x0. 0 = NSE buffer MIPI TX disabled. 1 = NSE buffer MIPI Packets enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfNseBufferMipiEn, TRegVdfNseBufferMipiEn, *PTRegVdfNseBufferMipiEn;                                //0x161DC

//Enables the halt signals for the Depth buffer (AKA Z buffer, EP2) and the Rec buffer (AKA Y, EP3 buffer) from the
//VDF module to the REC module. The VDF can halt the REC if one of the buffers is close to oveflowing and the REC
//can attempt to give some relief by filling its input buffer while not send anymore data to the VDF.
//initial value: 0x0
typedef union __RegVdfVdfRecScpHaltEn{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferHaltEnable                             :1          ; //Bits :[0:0], initial value: 0x0. 0 = Depth Buffer Halt Disabled. 1 = Depth Buffer Halt Enabled.
        uint32_t RecBufferHaltEnable                               :1          ; //Bits :[1:1], initial value: 0x0. 0 = REC Buffer Halt Disabled. 1 = REC Buffer Halt Enabled.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferHaltEnable                             :1          ; //Bits :[0:0], initial value: 0x0. 0 = Depth Buffer Halt Disabled. 1 = Depth Buffer Halt Enabled.
        uint32_t RecBufferHaltEnable                               :1          ; //Bits :[1:1], initial value: 0x0. 0 = REC Buffer Halt Disabled. 1 = REC Buffer Halt Enabled.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferHaltEnable                             :1          ; //Bits :[0:0], initial value: 0x0. 0 = Depth Buffer Halt Disabled. 1 = Depth Buffer Halt Enabled.
        uint32_t RecBufferHaltEnable                               :1          ; //Bits :[1:1], initial value: 0x0. 0 = REC Buffer Halt Disabled. 1 = REC Buffer Halt Enabled.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfVdfRecScpHaltEn, TRegVdfVdfRecScpHaltEn, *PTRegVdfVdfRecScpHaltEn;                                //0x161E0

//Enable the dinghy on the stream from the Depth buffer. When this register is set to 1, the dinghy is sent after
//the pixel data in a frame. If this bit is 0, then the dinghy is not sent. This applies to both MIPI and USB mode.
//The dinghy data is not written to the buffer when this bit is disabled. It is not sent as part of the UVC video
//frame, in MIPI mode the FE packet will be sent as soon as the EOF appears in the VDF. The default is to enable
// the dinghy for compatibility with DS5-A0.
//initial value: 0x1
typedef union __RegVdfDepthDinghyEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t DepthBufferDinghyEnable                           :1          ; //Bits :[0:0], initial value: 0x1. 0 = Depth Buffer Dinghy Disabled. 1 = Depth Buffer Dinghy Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t DepthBufferDinghyEnable                           :1          ; //Bits :[0:0], initial value: 0x1. 0 = Depth Buffer Dinghy Disabled. 1 = Depth Buffer Dinghy Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t DepthBufferDinghyEnable                           :1          ; //Bits :[0:0], initial value: 0x1. 0 = Depth Buffer Dinghy Disabled. 1 = Depth Buffer Dinghy Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfDepthDinghyEnable, TRegVdfDepthDinghyEnable, *PTRegVdfDepthDinghyEnable;                                //0x161E4

//Enable the dinghy on the stream from the Lyry buffer. When this register is set to 1, the dinghy is sent after
// the pixel data in a frame. If this bit is 0, then the dinghy is not sent. This applies to both MIPI and USB mode.
//The dinghy data is not written to the buffer when this bit is disabled. It is not sent as part of the UVC video
//frame, in MIPI mode the FE packet will be sent as soon as the EOF appears in the VDF. The default is to enable
// the dinghy for compatibility with DS5-A0.
//initial value: 0x1
typedef union __RegVdfLyryDinghyEnable{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LyryBufferDinghyEnable                            :1          ; //Bits :[0:0], initial value: 0x1. 0 = Lyry Buffer Dinghy Disabled. 1 = Lyry Buffer Dinghy Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LyryBufferDinghyEnable                            :1          ; //Bits :[0:0], initial value: 0x1. 0 = Lyry Buffer Dinghy Disabled. 1 = Lyry Buffer Dinghy Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LyryBufferDinghyEnable                            :1          ; //Bits :[0:0], initial value: 0x1. 0 = Lyry Buffer Dinghy Disabled. 1 = Lyry Buffer Dinghy Enabled.
        uint32_t Reserved                                          :31         ; //Bits :[1:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfLyryDinghyEnable, TRegVdfLyryDinghyEnable, *PTRegVdfLyryDinghyEnable;                                //0x161EC

//Control of the power-down input on the Non-Streaming Endpoint Buffer. There are two 4K memories, each can be controlled
//individually. Note: During a PMU wake event, PMU will force these memories out of power-down state.  This allows
//capturing and storing event related information from USB-Controller.  PMU will hold these memories active till
// wake event is cleared by SW.  Therefore, SW is expected to program this register appropriately before clearing
//PMU event
//initial value: 0x0
typedef union __RegVdfNseMemoryPwrControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t LsLow                                             :1          ; //Bits :[0:0], initial value: 0x0. LS input on the low 4K memeory.
        uint32_t DsLow                                             :1          ; //Bits :[1:1], initial value: 0x0. DS input on the low 4K memeory.
        uint32_t SdLow                                             :1          ; //Bits :[2:2], initial value: 0x0. SD input on the low 4K memeory.
        uint32_t LsHigh                                            :1          ; //Bits :[3:3], initial value: 0x0. LS input on the high 4K memeory.
        uint32_t DsHigh                                            :1          ; //Bits :[4:4], initial value: 0x0. DS input on the high 4K memeory.
        uint32_t SdHigh                                            :1          ; //Bits :[5:5], initial value: 0x0. SD input on the high 4K memeory.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t LsLow                                             :1          ; //Bits :[0:0], initial value: 0x0. LS input on the low 4K memeory.
        uint32_t DsLow                                             :1          ; //Bits :[1:1], initial value: 0x0. DS input on the low 4K memeory.
        uint32_t SdLow                                             :1          ; //Bits :[2:2], initial value: 0x0. SD input on the low 4K memeory.
        uint32_t LsHigh                                            :1          ; //Bits :[3:3], initial value: 0x0. LS input on the high 4K memeory.
        uint32_t DsHigh                                            :1          ; //Bits :[4:4], initial value: 0x0. DS input on the high 4K memeory.
        uint32_t SdHigh                                            :1          ; //Bits :[5:5], initial value: 0x0. SD input on the high 4K memeory.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t LsLow                                             :1          ; //Bits :[0:0], initial value: 0x0. LS input on the low 4K memeory.
        uint32_t DsLow                                             :1          ; //Bits :[1:1], initial value: 0x0. DS input on the low 4K memeory.
        uint32_t SdLow                                             :1          ; //Bits :[2:2], initial value: 0x0. SD input on the low 4K memeory.
        uint32_t LsHigh                                            :1          ; //Bits :[3:3], initial value: 0x0. LS input on the high 4K memeory.
        uint32_t DsHigh                                            :1          ; //Bits :[4:4], initial value: 0x0. DS input on the high 4K memeory.
        uint32_t SdHigh                                            :1          ; //Bits :[5:5], initial value: 0x0. SD input on the high 4K memeory.
        uint32_t Reserved                                          :26         ; //Bits :[6:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfNseMemoryPwrControl, TRegVdfNseMemoryPwrControl, *PTRegVdfNseMemoryPwrControl;                                //0x161F0

//This register can be used to tune which buffers MIPI FE and FS packets are sent when the DS5-B0 is operating in
// Combined MIPI Mode ( MIPI_COMBINED_DATA_MODE CSR = 1). Normally this register is left at the default of zero.
// In combined mode, the VDF module logic determines which buffer’s FS and FE packets are actually transmitted to
//frame the data from the two buffers into a single MIPI frame. If bit 0 is left at the default 0, then the VDF logic
//will determine the framing, if bit 0 is set to 1, then the upper four bits in the CSR will determine which of the
//FS and FE packets are send or suppressed. This register provides a fallback method of forcing a selection via the
//firmware, also known as chicken bits.  The only useful combination is using the REC buffer with the Depth buffer
//FE (csr = 01101) or using the REC buffer for both FS and FE (csr 00111), however any of the 16 combinations are
//available for debug. Verification should be limited to the two useful cases.
//initial value: 0x0
typedef union __RegVdfCombModeFsFeControl{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t EnableCombinationModeFsFeControl                  :1          ; //Bits :[0:0], initial value: 0x0.  0 = VDF logic determine which FS and FE are sent. 1 = the upper four bits determin which FS adn FE are sent.
        uint32_t SupressDepthBufferFe                              :1          ; //Bits :[1:1], initial value: 0x0. 0 = Depth buffer FE is sent. 1 = Depth Buffer FE is not sent
        uint32_t SupressDepthBufferFs                              :1          ; //Bits :[2:2], initial value: 0x0. 0 = Depth buffer FS is sent. 1 = Depth Buffer FS is not sent
        uint32_t SupressRecBufferFe                                :1          ; //Bits :[3:3], initial value: 0x0. 0 = Rec buffer FE is sent. 1 = Rec Buffer FE is not sent
        uint32_t SupressRecBufferFs                                :1          ; //Bits :[4:4], initial value: 0x0. 0 = Rec buffer FS is sent. 1 = Rec Buffer FS is not sent
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_read;
    struct {
        uint32_t EnableCombinationModeFsFeControl                  :1          ; //Bits :[0:0], initial value: 0x0.  0 = VDF logic determine which FS and FE are sent. 1 = the upper four bits determin which FS adn FE are sent.
        uint32_t SupressDepthBufferFe                              :1          ; //Bits :[1:1], initial value: 0x0. 0 = Depth buffer FE is sent. 1 = Depth Buffer FE is not sent
        uint32_t SupressDepthBufferFs                              :1          ; //Bits :[2:2], initial value: 0x0. 0 = Depth buffer FS is sent. 1 = Depth Buffer FS is not sent
        uint32_t SupressRecBufferFe                                :1          ; //Bits :[3:3], initial value: 0x0. 0 = Rec buffer FE is sent. 1 = Rec Buffer FE is not sent
        uint32_t SupressRecBufferFs                                :1          ; //Bits :[4:4], initial value: 0x0. 0 = Rec buffer FS is sent. 1 = Rec Buffer FS is not sent
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_write;
    struct {
        uint32_t EnableCombinationModeFsFeControl                  :1          ; //Bits :[0:0], initial value: 0x0.  0 = VDF logic determine which FS and FE are sent. 1 = the upper four bits determin which FS adn FE are sent.
        uint32_t SupressDepthBufferFe                              :1          ; //Bits :[1:1], initial value: 0x0. 0 = Depth buffer FE is sent. 1 = Depth Buffer FE is not sent
        uint32_t SupressDepthBufferFs                              :1          ; //Bits :[2:2], initial value: 0x0. 0 = Depth buffer FS is sent. 1 = Depth Buffer FS is not sent
        uint32_t SupressRecBufferFe                                :1          ; //Bits :[3:3], initial value: 0x0. 0 = Rec buffer FE is sent. 1 = Rec Buffer FE is not sent
        uint32_t SupressRecBufferFs                                :1          ; //Bits :[4:4], initial value: 0x0. 0 = Rec buffer FS is sent. 1 = Rec Buffer FS is not sent
        uint32_t Reserved                                          :27         ; //Bits :[5:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's.
     } fields_rmw; //for non-shadowed register
} RegVdfCombModeFsFeControl, TRegVdfCombModeFsFeControl, *PTRegVdfCombModeFsFeControl;                                //0x161F4

//Spare read-write register
//initial value: 0x0
typedef union __RegVdfVdfSpareRw1{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SpareVdfRegister1                                 :32         ; //Bits :[0:31], initial value: 0x0. Spare VDF register 1
     } fields_read;
    struct {
        uint32_t SpareVdfRegister1                                 :32         ; //Bits :[0:31], initial value: 0x0. Spare VDF register 1
     } fields_write;
    struct {
        uint32_t SpareVdfRegister1                                 :32         ; //Bits :[0:31], initial value: 0x0. Spare VDF register 1
     } fields_rmw; //for non-shadowed register
} RegVdfVdfSpareRw1, TRegVdfVdfSpareRw1, *PTRegVdfVdfSpareRw1;                                //0x161F8

//Spare read-write register
//initial value: 0x0
typedef union __RegVdfVdfSpareRw2{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t SpareVdfRegister2                                 :32         ; //Bits :[0:31], initial value: 0x0. Spare VDF register 2
     } fields_read;
    struct {
        uint32_t SpareVdfRegister2                                 :32         ; //Bits :[0:31], initial value: 0x0. Spare VDF register 2
     } fields_write;
    struct {
        uint32_t SpareVdfRegister2                                 :32         ; //Bits :[0:31], initial value: 0x0. Spare VDF register 2
     } fields_rmw; //for non-shadowed register
} RegVdfVdfSpareRw2, TRegVdfVdfSpareRw2, *PTRegVdfVdfSpareRw2;                                //0x161FC

//Writing to this register will force an update of the UVC Extended Header Shadow registers. THis is a self-clearing
//registers, writes of 1 will effect the update, writes of 0 will have no effect. Reads will always return zeros.
//initial value: 0x0
typedef union __RegVdfUvcHdrShadowUpdate{ //register type:RW shadowed:NO
    uint32_t value_read;
    uint32_t value_write;
    uint32_t value_rmw; //for non-shadowed register
    struct {
        uint32_t Ep2DepthShadowUpdate                              :1          ; //Bits :[0:0], initial value: 0x0. Writing a 1 will force an updata of the EP2 (Depth) UVC Extended Header Shadow registers. Writing a zero has no effect.
        uint32_t Ep4DepthShadowUpdate                              :1          ; //Bits :[1:1], initial value: 0x0. Writing a 1 will force an updata of the EP4 (WebCam) UVC Extended Header Shadow registers. Writing a zero has no effect.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_read;
    struct {
        uint32_t Ep2DepthShadowUpdate                              :1          ; //Bits :[0:0], initial value: 0x0. Writing a 1 will force an updata of the EP2 (Depth) UVC Extended Header Shadow registers. Writing a zero has no effect.
        uint32_t Ep4DepthShadowUpdate                              :1          ; //Bits :[1:1], initial value: 0x0. Writing a 1 will force an updata of the EP4 (WebCam) UVC Extended Header Shadow registers. Writing a zero has no effect.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_write;
    struct {
        uint32_t Ep2DepthShadowUpdate                              :1          ; //Bits :[0:0], initial value: 0x0. Writing a 1 will force an updata of the EP2 (Depth) UVC Extended Header Shadow registers. Writing a zero has no effect.
        uint32_t Ep4DepthShadowUpdate                              :1          ; //Bits :[1:1], initial value: 0x0. Writing a 1 will force an updata of the EP4 (WebCam) UVC Extended Header Shadow registers. Writing a zero has no effect.
        uint32_t Reserved                                          :30         ; //Bits :[2:31], initial value: 0x0. Reserved. Writes have no effect. Read always returns 0's
     } fields_rmw; //for non-shadowed register
} RegVdfUvcHdrShadowUpdate, TRegVdfUvcHdrShadowUpdate, *PTRegVdfUvcHdrShadowUpdate;                                //0x16200

#endif
