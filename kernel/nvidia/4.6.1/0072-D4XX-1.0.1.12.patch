From 9e43619cba7683b82038dd2762cb8c41713123cc Mon Sep 17 00:00:00 2001
From: Dmitry Perchanov <dmitry.perchanov@intel.com>
Date: Wed, 17 Aug 2022 11:52:51 +0300
Subject: [PATCH] D4XX-1.0.1.12-cleanup

Signed-off-by: Dmitry Perchanov <dmitry.perchanov@intel.com>
---
 drivers/media/i2c/d4xx.c | 624 ++++++++++++++++++++++-----------------
 1 file changed, 351 insertions(+), 273 deletions(-)

diff --git a/drivers/media/i2c/d4xx.c b/drivers/media/i2c/d4xx.c
index 0d422e3..e8c1805 100644
--- a/drivers/media/i2c/d4xx.c
+++ b/drivers/media/i2c/d4xx.c
@@ -174,17 +174,17 @@ enum ds5_mux_pad {
 	if (ds5_raw_write(state, addr, buf, size)) 	\
 		return -EINVAL;}
 enum dfu_fw_state {
-    appIDLE                = 0x0000,
-    appDETACH              = 0x0001,
-    dfuIDLE                = 0x0002,
-    dfuDNLOAD_SYNC         = 0x0003,
-    dfuDNBUSY              = 0x0004,
-    dfuDNLOAD_IDLE         = 0x0005,
-    dfuMANIFEST_SYNC       = 0x0006,
-    dfuMANIFEST            = 0x0007,
-    dfuMANIFEST_WAIT_RESET = 0x0008,
-    dfuUPLOAD_IDLE         = 0x0009,
-    dfuERROR               = 0x000a
+	appIDLE                = 0x0000,
+	appDETACH              = 0x0001,
+	dfuIDLE                = 0x0002,
+	dfuDNLOAD_SYNC         = 0x0003,
+	dfuDNBUSY              = 0x0004,
+	dfuDNLOAD_IDLE         = 0x0005,
+	dfuMANIFEST_SYNC       = 0x0006,
+	dfuMANIFEST            = 0x0007,
+	dfuMANIFEST_WAIT_RESET = 0x0008,
+	dfuUPLOAD_IDLE         = 0x0009,
+	dfuERROR               = 0x000a
 };
 
 enum dfu_state {
@@ -436,31 +436,36 @@ static int ds5_write(struct ds5 *state, u16 reg, u16 val)
 	value[1] = val >> 8;
 	value[0] = val & 0x00FF;
 
-	dev_info(&state->client->dev, "%s(): writing to register: 0x%04x, value1: 0x%x, value2:0x%x\n",
-				 __func__, reg, value[1], value[0]);
+	dev_dbg(&state->client->dev,
+			"%s(): writing to register: 0x%04x, value1: 0x%x, value2:0x%x\n",
+			__func__, reg, value[1], value[0]);
 
 	ret = regmap_raw_write(state->regmap, reg, value, sizeof(value));
 	if (ret < 0)
-		dev_err(&state->client->dev, "%s(): i2c write failed %d, 0x%04x = 0x%x\n",
-			__func__, ret, reg, val);
+		dev_err(&state->client->dev,
+				"%s(): i2c write failed %d, 0x%04x = 0x%x\n",
+				__func__, ret, reg, val);
 	else
 		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
-			dev_info(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
+			dev_dbg(&state->client->dev, "%s(): i2c write 0x%04x: 0x%x\n",
 				 __func__, reg, val);
 
 	return ret;
 }
 
-static int ds5_raw_write(struct ds5 *state, u16 reg, const void *val, size_t val_len)
+static int ds5_raw_write(struct ds5 *state, u16 reg,
+		const void *val, size_t val_len)
 {
 	int ret = regmap_raw_write(state->regmap, reg, val, val_len);
 	if (ret < 0)
-		dev_err(&state->client->dev, "%s(): i2c raw write failed %d, %04x size(%d) bytes\n",
-			__func__, ret, reg, (int)val_len);
+		dev_err(&state->client->dev,
+				"%s(): i2c raw write failed %d, %04x size(%d) bytes\n",
+				__func__, ret, reg, (int)val_len);
 	else
 		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
-			dev_info(&state->client->dev, "%s(): i2c raw write 0x%04x: %d bytes\n",
-				 __func__, reg, (int)val_len);
+			dev_dbg(&state->client->dev,
+					"%s(): i2c raw write 0x%04x: %d bytes\n",
+					__func__, reg, (int)val_len);
 
 	return ret;
 }
@@ -473,7 +478,7 @@ static int ds5_read(struct ds5 *state, u16 reg, u16 *val)
 				__func__, ret, reg);
 	else {
 		if (state->dfu_dev.dfu_state_flag == DS5_DFU_IDLE)
-			dev_info(&state->client->dev, "%s(): i2c read 0x%04x: 0x%x\n",
+			dev_dbg(&state->client->dev, "%s(): i2c read 0x%04x: 0x%x\n",
 					__func__, reg, *val);
 	}
 
@@ -820,7 +825,20 @@ static const struct v4l2_mbus_framefmt ds5_mbus_framefmt_template = {
 	.xfer_func = V4L2_XFER_FUNC_DEFAULT,
 };
 
-/* This is needed for .get_fmt() and if streaming is started without .set_fmt() */
+/* Get readable sensor name */
+static const char *ds5_get_sensor_name(struct ds5 *state)
+{
+	static const char *sensor_name[] = {"unknown", "RGB", "DEPTH", "Y8", "IMU"};
+	int sensor_id = state->is_rgb * 1 + state->is_depth * 2 + \
+			state->is_y8 * 3 + state->is_imu * 4;
+	if (sensor_id > sizeof(sensor_name))
+		sensor_id = 0;
+
+	return sensor_name[sensor_id];
+}
+
+/* This is needed for .get_fmt()
+ * and if streaming is started without .set_fmt() */
 static void ds5_sensor_format_init(struct ds5_sensor *sensor)
 {
 	const struct ds5_format *fmt;
@@ -830,7 +848,7 @@ static void ds5_sensor_format_init(struct ds5_sensor *sensor)
 	if (sensor->config.format)
 		return;
 
-	dev_info(sensor->sd.dev, "%s(): on pad %u\n", __func__, sensor->mux_pad);
+	dev_dbg(sensor->sd.dev, "%s(): on pad %u\n", __func__, sensor->mux_pad);
 
 	ffmt = &sensor->format;
 	*ffmt = ds5_mbus_framefmt_template;
@@ -855,11 +873,10 @@ static void ds5_sensor_format_init(struct ds5_sensor *sensor)
 
 /* No locking needed for enumeration methods */
 static int ds5_sensor_enum_mbus_code(struct v4l2_subdev *sd,
-				     struct v4l2_subdev_pad_config *cfg,
-				     struct v4l2_subdev_mbus_code_enum *mce)
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_mbus_code_enum *mce)
 {
 	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
-	//struct ds5_vchan *vchan = sensor->vchan;
 
 	if (mce->pad)
 		return -EINVAL;
@@ -873,20 +890,13 @@ static int ds5_sensor_enum_mbus_code(struct v4l2_subdev *sd,
 }
 
 static int ds5_sensor_enum_frame_size(struct v4l2_subdev *sd,
-				      struct v4l2_subdev_pad_config *cfg,
-				      struct v4l2_subdev_frame_size_enum *fse)
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
-	struct ds5 *state = v4l2_get_subdevdata(sd);
 	const struct ds5_format *fmt;
 	unsigned int i;
 
-	dev_info(sensor->sd.dev, "%s(): sensor %s \n", __func__, sensor->sd.name);
-	dev_info(sensor->sd.dev, "%s(): state->is_rgb %d\n", __func__, state->is_rgb);
-	dev_info(sensor->sd.dev, "%s(): state->is_depth %d\n", __func__, state->is_depth);
-	dev_info(sensor->sd.dev, "%s(): state->is_y8 %d\n", __func__, state->is_y8);
-	dev_info(sensor->sd.dev, "%s(): state->is_imu %d\n", __func__, state->is_imu);
-
 	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
 		if (fse->code == fmt->mbus_code)
 			break;
@@ -904,17 +914,14 @@ static int ds5_sensor_enum_frame_size(struct v4l2_subdev *sd,
 }
 
 static int ds5_sensor_enum_frame_interval(struct v4l2_subdev *sd,
-					  struct v4l2_subdev_pad_config *cfg,
-					  struct v4l2_subdev_frame_interval_enum *fie)
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_interval_enum *fie)
 {
 	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
 	const struct ds5_format *fmt;
 	const struct ds5_resolution *res;
 	unsigned int i;
 
-	//if (fie->pad)
-	//	return -EINVAL;
-
 	for (i = 0, fmt = sensor->formats; i < sensor->n_formats; i++, fmt++)
 		if (fie->code == fmt->mbus_code)
 			break;
@@ -938,14 +945,13 @@ static int ds5_sensor_enum_frame_interval(struct v4l2_subdev *sd,
 	return 0;
 }
 
-static int ds5_sensor_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,
-			      struct v4l2_subdev_format *fmt)
+static int ds5_sensor_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *fmt)
 {
 	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
 	struct ds5 *state = v4l2_get_subdevdata(sd);
 
-	//fmt->pad = sensor->mux_pad;
-
 	if (fmt->pad)
 		return -EINVAL;
 
@@ -958,16 +964,18 @@ static int ds5_sensor_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_con
 
 	mutex_unlock(&state->lock);
 
-	dev_info(sd->dev, "%s(): pad %x, code %x, res %ux%u\n", __func__, fmt->pad, fmt->format.code,
-		 fmt->format.width, fmt->format.height);
+	dev_dbg(sd->dev, "%s(): pad %x, code %x, res %ux%u\n",
+			__func__, fmt->pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
 
 	return 0;
 }
 
 /* Called with lock held */
-static const struct ds5_format *ds5_sensor_find_format(struct ds5_sensor *sensor,
-						struct v4l2_mbus_framefmt *ffmt,
-						const struct ds5_resolution **best)
+static const struct ds5_format *ds5_sensor_find_format(
+		struct ds5_sensor *sensor,
+		struct v4l2_mbus_framefmt *ffmt,
+		const struct ds5_resolution **best)
 {
 	const struct ds5_resolution *res;
 	const struct ds5_format *fmt;
@@ -978,8 +986,8 @@ static const struct ds5_format *ds5_sensor_find_format(struct ds5_sensor *sensor
 		if (fmt->mbus_code == ffmt->code)
 			break;
 	}
-	dev_info(sensor->sd.dev, "%s(): mbus_code = %x, code = %x \n", __func__,
-				 fmt->mbus_code, ffmt->code);
+	dev_dbg(sensor->sd.dev, "%s(): mbus_code = %x, code = %x \n",
+			__func__, fmt->mbus_code, ffmt->code);
 
 	if (i == sensor->n_formats)
 		/* Not found, use default */
@@ -987,7 +995,7 @@ static const struct ds5_format *ds5_sensor_find_format(struct ds5_sensor *sensor
 
 	for (i = 0, res = fmt->resolutions; i < fmt->n_resolutions; i++, res++) {
 		unsigned long delta = abs(ffmt->width * ffmt->height -
-					  res->width * res->height);
+				res->width * res->height);
 		if (delta < best_delta) {
 			best_delta = delta;
 			*best = res;
@@ -1012,11 +1020,9 @@ static int __ds5_sensor_set_fmt(struct ds5 *state, struct ds5_sensor *sensor,
 	struct v4l2_mbus_framefmt *mf;// = &fmt->format;
 	//unsigned r;
 
-	dev_info(sensor->sd.dev, "%s(): state %p\n", __func__, state);
-	dev_info(sensor->sd.dev, "%s(): sensor %p\n", __func__, sensor);
-	dev_info(sensor->sd.dev, "%s(): cfg %p\n", __func__, cfg);
-	dev_info(sensor->sd.dev, "%s(): fmt %p\n", __func__, fmt);
-	dev_info(sensor->sd.dev, "%s(): fmt->format %p\n", __func__, &fmt->format);
+	dev_dbg(sensor->sd.dev, "%s(): state %p, "
+			"sensor %p, cfg %p, fmt %p, fmt->format %p\n",
+			__func__, state, sensor, cfg, fmt,  &fmt->format);
 
 	mf = &fmt->format;
 
@@ -1034,7 +1040,8 @@ static int __ds5_sensor_set_fmt(struct ds5 *state, struct ds5_sensor *sensor,
 
 	if (cfg && fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
 		*v4l2_subdev_get_try_format(&sensor->sd, cfg, fmt->pad) = *mf;
-		dev_info(sensor->sd.dev, "%s():4l2_subdev_get_try_format ret: %p\n", __func__, cfg );
+		dev_dbg(sensor->sd.dev, "%s():4l2_subdev_get_try_format ret: %p\n",
+				__func__, cfg);
 	}
 
 	else
@@ -1045,14 +1052,16 @@ static int __ds5_sensor_set_fmt(struct ds5 *state, struct ds5_sensor *sensor,
 
 	mutex_unlock(&state->lock);
 
-	dev_info(sensor->sd.dev, "%s(): pad: %x, code: %x, %ux%u\n", __func__, fmt->pad, fmt->format.code,
-		 fmt->format.width, fmt->format.height);
+	dev_dbg(sensor->sd.dev, "%s(): pad: %x, code: %x, %ux%u\n",
+			__func__, fmt->pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
 
 	return 0;
 }
 
-static int ds5_sensor_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,
-			      struct v4l2_subdev_format *fmt)
+static int ds5_sensor_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *fmt)
 {
 	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
 	struct ds5 *state = v4l2_get_subdevdata(sd);
@@ -1167,7 +1176,9 @@ static const struct v4l2_subdev_pad_ops ds5_depth_pad_ops = {
 static int ds5_sensor_s_stream(struct v4l2_subdev *sd, int on)
 {
 	struct ds5_sensor *sensor = container_of(sd, struct ds5_sensor, sd);
-	dev_info(sensor->sd.dev, "%s(): sensor: name=%s state=%d\n", __func__, sensor->sd.name, on);
+	dev_dbg(sensor->sd.dev,
+			"%s(): sensor: name=%s state=%d\n",
+			__func__, sensor->sd.name, on);
 
 	sensor->streaming = on;
 
@@ -1229,7 +1240,7 @@ static const struct v4l2_subdev_ops ds5_imu_subdev_ops = {
 static int ds5_hw_set_auto_exposure(struct ds5 *state, u32 base, s32 val)
 {
 	if (val != V4L2_EXPOSURE_APERTURE_PRIORITY &&
-	    val != V4L2_EXPOSURE_MANUAL)
+			val != V4L2_EXPOSURE_MANUAL)
 		return -EINVAL;
 
 	/*
@@ -1318,8 +1329,11 @@ static int ds5_send_hwmc(struct ds5 *state, u16 cmdLen, struct hwm_cmd *cmd,
 	int errorCode;
 	int iter = retries;
 
-	dev_info(&state->client->dev, "%s(): HWMC header: 0x%x, magic: 0x%x, opcode: 0x%x, param1: %d, param2: %d, param3: %d, param4: %d\n",
-			__func__, cmd->header, cmd->magic_word, cmd->opcode, cmd->param1, cmd->param2, cmd->param3, cmd->param4);
+	dev_dbg(&state->client->dev,
+			"%s(): HWMC header: 0x%x, magic: 0x%x, opcode: 0x%x, "
+			"param1: %d, param2: %d, param3: %d, param4: %d\n",
+			__func__, cmd->header, cmd->magic_word, cmd->opcode,
+			cmd->param1, cmd->param2, cmd->param3, cmd->param4);
 
 	ds5_raw_write_with_check(state, 0x4900, cmd, cmdLen);
 
@@ -1332,8 +1346,9 @@ static int ds5_send_hwmc(struct ds5 *state, u16 cmdLen, struct hwm_cmd *cmd,
 
 	if (ret || status != 0) {
 		ds5_raw_read(state, 0x4900, &errorCode, 4);
-		dev_err(&state->client->dev, "%s(): HWMC failed, ret: %d, status: %x, error code: %d\n",
-					__func__, ret, status, errorCode);
+		dev_err(&state->client->dev,
+				"%s(): HWMC failed, ret: %d, status: %x, error code: %d\n",
+				__func__, ret, status, errorCode);
 		ret = -EAGAIN;
 	}
 
@@ -1344,8 +1359,8 @@ static int ds5_send_hwmc(struct ds5 *state, u16 cmdLen, struct hwm_cmd *cmd,
 				return -EAGAIN;
 		}
 
-		dev_info(&state->client->dev, "%s(): HWMC read len: %d\n",
-					__func__, *dataLen);
+		dev_dbg(&state->client->dev, "%s(): HWMC read len: %d\n",
+				__func__, *dataLen);
 		// First 4 bytes of cmd->Data after read will include opcode
 		ds5_raw_read_with_check(state, 0x4900, cmd->Data, *dataLen);
 
@@ -1406,7 +1421,7 @@ static int ds5_get_hwmc(struct ds5 *state, unsigned char *data)
 	if (tmp_len > DS5_HWMC_BUFFER_SIZE)
 		return -ENOBUFS;
 
-	dev_info(&state->client->dev,
+	dev_dbg(&state->client->dev,
 			"%s(): HWMC read len: %d, lrs_len: %d\n",
 			__func__, tmp_len, tmp_len - SIZE_OF_HW_MONITOR_HEADER);
 
@@ -1423,7 +1438,8 @@ static int ds5_get_hwmc(struct ds5 *state, unsigned char *data)
 	return 0;
 }
 
-static int ds5_set_calibration_data(struct ds5 *state, struct hwm_cmd *cmd, u16 length)
+static int ds5_set_calibration_data(struct ds5 *state,
+		struct hwm_cmd *cmd, u16 length)
 {
 	int ret;
 	int retries = 10;
@@ -1439,7 +1455,9 @@ static int ds5_set_calibration_data(struct ds5 *state, struct hwm_cmd *cmd, u16
 	} while (retries-- && status != 0);
 
 	if (ret || status != 0) {
-		dev_err(&state->client->dev, "%s(): Failed to set calibration table %d, ret: %d, fw error: %x\n",
+		dev_err(&state->client->dev,
+				"%s(): Failed to set calibration table %d,"
+				"ret: %d, fw error: %x\n",
 				__func__, cmd->param1, ret, status);
 	}
 
@@ -1459,7 +1477,7 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 	else if (state->is_imu)
 		return -EINVAL;
 
-	v4l2_dbg(1, 1, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);
+	v4l2_dbg(3, 1, sd, "ctrl: %s, value: %d\n", ctrl->name, ctrl->val);
 
 	mutex_lock(&state->lock);
 
@@ -1488,15 +1506,22 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET: {
 		struct hwm_cmd *calib_cmd;
 
-		dev_info(&state->client->dev, "%s(): DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET \n", __func__);
-		dev_info(&state->client->dev, "%s(): table id: 0x%x\n", __func__, *((u8*)ctrl->p_new.p + 2));
-		if (ctrl->p_new.p && DEPTH_CALIBRATION_ID == *((u8*)ctrl->p_new.p + 2)) {
-			calib_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 256, GFP_KERNEL);
+		dev_dbg(&state->client->dev,
+				"%s(): DS5_CAMERA_DEPTH_CALIBRATION_TABLE_SET \n",
+				__func__);
+		dev_dbg(&state->client->dev,
+				"%s(): table id: 0x%x\n",
+				__func__, *((u8*)ctrl->p_new.p + 2));
+		if (ctrl->p_new.p && DEPTH_CALIBRATION_ID ==
+				*((u8*)ctrl->p_new.p + 2)) {
+			calib_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + 256, GFP_KERNEL);
 			memcpy(calib_cmd, &set_calib_data, sizeof (set_calib_data));
 			calib_cmd->header = 276;
 			calib_cmd->param1 = DEPTH_CALIBRATION_ID;
 			memcpy(calib_cmd->Data, (u8*)ctrl->p_new.p , 256);
-			ret = ds5_set_calibration_data(state, calib_cmd, sizeof(struct hwm_cmd) + 256);
+			ret = ds5_set_calibration_data(state, calib_cmd,
+					sizeof(struct hwm_cmd) + 256);
 			devm_kfree(&state->client->dev, calib_cmd);
 		}
 		break;
@@ -1504,15 +1529,22 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET: {
 			struct hwm_cmd *calib_cmd;
 
-			dev_info(&state->client->dev, "%s(): DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET \n", __func__);
-			dev_info(&state->client->dev, "%s(): table id %d\n", __func__, *((u8*)ctrl->p_new.p + 2));
-			if (ctrl->p_new.p && COEF_CALIBRATION_ID == *((u8*)ctrl->p_new.p + 2)) {
-				calib_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 512, GFP_KERNEL);
+			dev_dbg(&state->client->dev,
+					"%s(): DS5_CAMERA_COEFF_CALIBRATION_TABLE_SET \n",
+					__func__);
+			dev_dbg(&state->client->dev,
+					"%s(): table id %d\n",
+					__func__, *((u8*)ctrl->p_new.p + 2));
+			if (ctrl->p_new.p && COEF_CALIBRATION_ID ==
+					*((u8*)ctrl->p_new.p + 2)) {
+				calib_cmd = devm_kzalloc(&state->client->dev,
+						sizeof(struct hwm_cmd) + 512, GFP_KERNEL);
 				memcpy(calib_cmd, &set_calib_data, sizeof (set_calib_data));
 				calib_cmd->header = 532;
 				calib_cmd->param1 = COEF_CALIBRATION_ID;
 				memcpy(calib_cmd->Data, (u8*)ctrl->p_new.p , 512);
-				ret = ds5_set_calibration_data(state, calib_cmd, sizeof(struct hwm_cmd) + 512);
+				ret = ds5_set_calibration_data(state, calib_cmd,
+						sizeof(struct hwm_cmd) + 512);
 				devm_kfree(&state->client->dev, calib_cmd);
 			}
 
@@ -1525,18 +1557,21 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 		ae_roi_cmd.param2 = *((u16*)ctrl->p_new.p_u16 + 1);
 		ae_roi_cmd.param3 = *((u16*)ctrl->p_new.p_u16 + 2);
 		ae_roi_cmd.param4 = *((u16*)ctrl->p_new.p_u16 + 3);
-		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), &ae_roi_cmd, false, NULL);
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				&ae_roi_cmd, false, NULL);
 		break;
 		}
 	case DS5_CAMERA_CID_AE_SETPOINT_SET: {
 		struct hwm_cmd *ae_setpoint_cmd;
 		if (ctrl->p_new.p_s32) {
-			dev_info(&state->client->dev, "%s():0x%x \n", __func__,
-					*(ctrl->p_new.p_s32));
-			ae_setpoint_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 4, GFP_KERNEL);
+			dev_dbg(&state->client->dev, "%s():0x%x \n",
+					__func__, *(ctrl->p_new.p_s32));
+			ae_setpoint_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + 4, GFP_KERNEL);
 			memcpy(ae_setpoint_cmd, &set_ae_setpoint, sizeof (set_ae_setpoint));
 			memcpy(ae_setpoint_cmd->Data, (u8*)ctrl->p_new.p_s32 , 4);
-			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + 4, ae_setpoint_cmd, false, NULL);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + 4,
+					ae_setpoint_cmd, false, NULL);
 			devm_kfree(&state->client->dev, ae_setpoint_cmd);
 		}
 		break;
@@ -1552,19 +1587,23 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 			size = *(ctrl->p_new.p_u8 + 2) << 8;
 			size |= *(ctrl->p_new.p_u8 + 3);
 
-			dev_info(&state->client->dev, "%s(): offset %x, size: %x\n",
+			dev_dbg(&state->client->dev, "%s(): offset %x, size: %x\n",
 							__func__, offset, size);
 
 
-			erb_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + size, GFP_KERNEL);
+			erb_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + size, GFP_KERNEL);
 			memcpy(erb_cmd, &erb, sizeof(struct hwm_cmd));
 			erb_cmd->param1 = offset;
 			erb_cmd->param2 = size;
-			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), erb_cmd, true, &size);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+					erb_cmd, true, &size);
 
 			if (ret) {
-				dev_err(&state->client->dev, "%s(): ERB cmd failed, ret: %d, requested size: %d, actual size: %d\n",
-								__func__, ret, erb_cmd->param2, size);
+				dev_err(&state->client->dev,
+						"%s(): ERB cmd failed, ret: %d,"
+						"requested size: %d, actual size: %d\n",
+						__func__, ret, erb_cmd->param2, size);
 				devm_kfree(&state->client->dev, erb_cmd);
 				return -EAGAIN;
 			}
@@ -1574,7 +1613,7 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 			*(ctrl->p_new.p_u8 + 3) = (size & 0x00FF);
 
 			memcpy(ctrl->p_new.p_u8 + 4, erb_cmd->Data + 4, size - 4);
-			dev_info(&state->client->dev, "%s(): 0x%x 0x%x 0x%x 0x%x \n",
+			dev_dbg(&state->client->dev, "%s(): 0x%x 0x%x 0x%x 0x%x \n",
 				__func__,
 				*(ctrl->p_new.p_u8),
 				*(ctrl->p_new.p_u8+1),
@@ -1594,23 +1633,29 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 			size = *((u8*)ctrl->p_new.p_u8 + 2) << 8;
 			size |= *((u8*)ctrl->p_new.p_u8 + 3);
 
-			dev_info(&state->client->dev, "%s():0x%x 0x%x 0x%x 0x%x\n", __func__,
+			dev_dbg(&state->client->dev, "%s():0x%x 0x%x 0x%x 0x%x\n",
+					__func__,
 					*((u8*)ctrl->p_new.p_u8),
 					*((u8*)ctrl->p_new.p_u8 + 1),
 					*((u8*)ctrl->p_new.p_u8 + 2),
 					*((u8*)ctrl->p_new.p_u8 + 3));
 
-			ewb_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + size, GFP_KERNEL);
+			ewb_cmd = devm_kzalloc(&state->client->dev,
+					sizeof(struct hwm_cmd) + size,
+					GFP_KERNEL);
 			memcpy(ewb_cmd, &ewb, sizeof (ewb));
 			ewb_cmd->header = 0x14 + size;
 			ewb_cmd->param1 = offset; // start index
 			ewb_cmd->param2 = size; // size
 			memcpy(ewb_cmd->Data, (u8*)ctrl->p_new.p_u8 + 4, size);
-			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + size, ewb_cmd, false, NULL);
+			ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd) + size,
+					ewb_cmd, false, NULL);
 
 			if (ret) {
-				dev_err(&state->client->dev, "%s(): EWB cmd failed, ret: %d, requested size: %d, actual size: %d\n",
-								__func__, ret, ewb_cmd->param2, size);
+				dev_err(&state->client->dev,
+						"%s(): EWB cmd failed, ret: %d,"
+						"requested size: %d, actual size: %d\n",
+						__func__, ret, ewb_cmd->param2, size);
 				devm_kfree(&state->client->dev, ewb_cmd);
 				return -EAGAIN;
 			}
@@ -1625,8 +1670,11 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 
 			size = *((u8*)ctrl->p_new.p_u8 + 1) << 8;
 			size |= *((u8*)ctrl->p_new.p_u8 + 0);
-			dev_info(&state->client->dev, "%s(): HWMC size %d\n", __func__, size);
-			ret = ds5_send_hwmc(state, size + 4, (struct hwm_cmd *)ctrl->p_new.p_u8, true, &dataLen);
+			dev_dbg(&state->client->dev,
+					"%s(): HWMC size %d\n",
+					__func__, size);
+			ret = ds5_send_hwmc(state, size + 4,
+					(struct hwm_cmd *)ctrl->p_new.p_u8, true, &dataLen);
 		}
 		break;
 	case DS5_CAMERA_CID_HWMC_RW:
@@ -1644,7 +1692,8 @@ static int ds5_s_ctrl(struct v4l2_ctrl *ctrl)
 	return ret;
 }
 
-static int ds5_get_calibration_data(struct ds5 *state, enum table_id id, unsigned char *table, unsigned int length)
+static int ds5_get_calibration_data(struct ds5 *state, enum table_id id,
+		unsigned char *table, unsigned int length)
 {
 	struct hwm_cmd *cmd;
 	int ret;
@@ -1652,7 +1701,8 @@ static int ds5_get_calibration_data(struct ds5 *state, enum table_id id, unsigne
 	u16 status = 2;
 	u16 table_length;
 
-	cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + length + 4, GFP_KERNEL);
+	cmd = devm_kzalloc(&state->client->dev,
+			sizeof(struct hwm_cmd) + length + 4, GFP_KERNEL);
 	memcpy(cmd, &get_calib_data, sizeof(get_calib_data));
 	cmd->param1 = id;
 	ds5_raw_write_with_check(state, 0x4900, cmd, sizeof(struct hwm_cmd));
@@ -1664,13 +1714,16 @@ static int ds5_get_calibration_data(struct ds5 *state, enum table_id id, unsigne
 	} while (ret && retries-- && status != 0);
 
 	if (ret || status != 0) {
-		dev_err(&state->client->dev, "%s(): Failed to get calibration table %d, fw error: %x\n", __func__, id, status);
+		dev_err(&state->client->dev,
+				"%s(): Failed to get calibration table %d, fw error: %x\n",
+				__func__, id, status);
 		devm_kfree(&state->client->dev, cmd);
 		return status;
 	}
 
 	// get table length from fw
-	ret = regmap_raw_read(state->regmap, 0x4908, &table_length, sizeof(table_length));
+	ret = regmap_raw_read(state->regmap, 0x4908,
+			&table_length, sizeof(table_length));
 
 	// read table
 	ds5_raw_read_with_check(state, 0x4900, cmd->Data, table_length);
@@ -1700,7 +1753,9 @@ static int ds5_gvd(struct ds5 *state, unsigned char *data)
 	} while (ret && retries-- && status != 0);
 
 	if (ret || status != 0) {
-		dev_err(&state->client->dev, "%s(): Failed to read GVD, HWM cmd status: %x\n", __func__, status);
+		dev_err(&state->client->dev,
+				"%s(): Failed to read GVD, HWM cmd status: %x\n",
+				__func__, status);
 		return status;
 	}
 
@@ -1714,9 +1769,9 @@ static int ds5_gvd(struct ds5 *state, unsigned char *data)
 static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct ds5 *state = container_of(ctrl->handler, struct ds5,
-					 ctrls.handler);
+			ctrls.handler);
 	u16 log_prepare[] = {0x0014, 0xcdab, 0x000f, 0x0000, 0x0400, 0x0000,
-			     0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
+			0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000};
 	u16 execute_cmd = 0x0001;
 	unsigned int i;
 	u32 data;
@@ -1781,7 +1836,7 @@ static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 		//       3. execute command
 		//       4. wait for ccompletion
 		ret = regmap_raw_write(state->regmap, 0x4900,
-				       log_prepare, sizeof(log_prepare));
+				log_prepare, sizeof(log_prepare));
 		if (ret < 0)
 			return ret;
 
@@ -1792,8 +1847,8 @@ static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 
 		for (i = 0; i < DS5_MAX_LOG_POLL; i++) {
 			ret = regmap_raw_read(state->regmap, 0x4904,
-					      &data, sizeof(data));
-			dev_info(&state->client->dev, "%s(): log ready 0x%x\n",
+					&data, sizeof(data));
+			dev_dbg(&state->client->dev, "%s(): log ready 0x%x\n",
 				 __func__, data);
 			if (ret < 0)
 				return ret;
@@ -1806,8 +1861,8 @@ static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 //			return -ETIMEDOUT;
 
 		ret = regmap_raw_read(state->regmap, 0x4908,
-				      &data, sizeof(data));
-		dev_info(&state->client->dev, "%s(): log size 0x%x\n",
+				&data, sizeof(data));
+		dev_dbg(&state->client->dev, "%s(): log size 0x%x\n",
 			 __func__, data);
 		if (ret < 0)
 			return ret;
@@ -1816,13 +1871,15 @@ static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 		if (data > 1024)
 			return -ENOBUFS;
 		ret = regmap_raw_read(state->regmap, 0x4900,
-				      ctrl->p_new.p_u8, data);
+				ctrl->p_new.p_u8, data);
 		break;
 	case DS5_CAMERA_DEPTH_CALIBRATION_TABLE_GET:
-		ret = ds5_get_calibration_data(state, DEPTH_CALIBRATION_ID,ctrl->p_new.p_u8, 256);
+		ret = ds5_get_calibration_data(state, DEPTH_CALIBRATION_ID,
+				ctrl->p_new.p_u8, 256);
 		break;
 	case DS5_CAMERA_COEFF_CALIBRATION_TABLE_GET:
-		ret = ds5_get_calibration_data(state, COEF_CALIBRATION_ID,ctrl->p_new.p_u8, 512);
+		ret = ds5_get_calibration_data(state, COEF_CALIBRATION_ID,
+				ctrl->p_new.p_u8, 512);
 		break;
 	case DS5_CAMERA_CID_FW_VERSION:
 		ret = ds5_read(state, DS5_FW_VERSION, &state->fw_version);
@@ -1836,9 +1893,11 @@ static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 	case DS5_CAMERA_CID_AE_ROI_GET: {
 		u16 len = 0;
 		struct hwm_cmd *ae_roi_cmd;
-		ae_roi_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 12, GFP_KERNEL);
+		ae_roi_cmd = devm_kzalloc(&state->client->dev,
+				sizeof(struct hwm_cmd) + 12, GFP_KERNEL);
 		memcpy(ae_roi_cmd, &get_ae_roi, sizeof(struct hwm_cmd));
-		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), ae_roi_cmd, true, &len);
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				ae_roi_cmd, true, &len);
 		memcpy(ctrl->p_new.p_u16, ae_roi_cmd->Data + 4, 8);
 		devm_kfree(&state->client->dev, ae_roi_cmd);
 		}
@@ -1846,11 +1905,13 @@ static int ds5_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 	case DS5_CAMERA_CID_AE_SETPOINT_GET: {
 		u16 len = 0;
 		struct hwm_cmd *ae_setpoint_cmd;
-		ae_setpoint_cmd = devm_kzalloc(&state->client->dev, sizeof(struct hwm_cmd) + 8, GFP_KERNEL);
+		ae_setpoint_cmd = devm_kzalloc(&state->client->dev,
+				sizeof(struct hwm_cmd) + 8, GFP_KERNEL);
 		memcpy(ae_setpoint_cmd, &get_ae_setpoint, sizeof(struct hwm_cmd));
-		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd), ae_setpoint_cmd, true, &len);
+		ret = ds5_send_hwmc(state, sizeof(struct hwm_cmd),
+				ae_setpoint_cmd, true, &len);
 		memcpy(ctrl->p_new.p_s32, ae_setpoint_cmd->Data + 4, 4);
-		dev_info(&state->client->dev, "%s(): 0x%x \n",
+		dev_dbg(&state->client->dev, "%s(): 0x%x \n",
 					__func__,
 					*(ctrl->p_new.p_s32));
 		devm_kfree(&state->client->dev, ae_setpoint_cmd);
@@ -2078,7 +2139,7 @@ static int ds5_mux_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	struct ds5 *state = v4l2_get_subdevdata(sd);
 
-	dev_info(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
 	if (state->dfu_dev.dfu_state_flag)
 		return -EBUSY;
 	state->dfu_dev.device_open_count++;
@@ -2090,7 +2151,7 @@ static int ds5_mux_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
 	struct ds5 *state = v4l2_get_subdevdata(sd);
 
-	dev_info(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
+	dev_dbg(sd->dev, "%s(): %s (%p)\n", __func__, sd->name, fh);
 	state->dfu_dev.device_open_count--;
 	return 0;
 };
@@ -2142,11 +2203,11 @@ static int ds5_ctrl_init(struct ds5 *state)
 				V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_EXECUTE_ON_WRITE;
 
 	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
-				V4L2_CID_EXPOSURE_AUTO,
-				V4L2_EXPOSURE_APERTURE_PRIORITY,
-				~((1 << V4L2_EXPOSURE_MANUAL) |
-				  (1 << V4L2_EXPOSURE_APERTURE_PRIORITY)),
-				V4L2_EXPOSURE_APERTURE_PRIORITY);
+			V4L2_CID_EXPOSURE_AUTO,
+			V4L2_EXPOSURE_APERTURE_PRIORITY,
+			~((1 << V4L2_EXPOSURE_MANUAL) |
+					(1 << V4L2_EXPOSURE_APERTURE_PRIORITY)),
+					V4L2_EXPOSURE_APERTURE_PRIORITY);
 
 	if (ctrls->auto_exp)
 		ctrls->auto_exp->flags |=
@@ -2189,14 +2250,20 @@ static int ds5_ctrl_init(struct ds5 *state)
 	ctrls->log = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_log, NULL);
 	ctrls->fw_version = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_fw_version, NULL);
 	ctrls->gvd = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_gvd, NULL);
-	ctrls->get_depth_calib = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_depth_calib, NULL);
-	ctrls->set_depth_calib = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_depth_calib, NULL);
-	ctrls->get_coeff_calib = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_coeff_calib, NULL);
-	ctrls->set_coeff_calib = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_coeff_calib, NULL);
+	ctrls->get_depth_calib =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_depth_calib, NULL);
+	ctrls->set_depth_calib =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_depth_calib, NULL);
+	ctrls->get_coeff_calib =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_get_coeff_calib, NULL);
+	ctrls->set_coeff_calib =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_set_coeff_calib, NULL);
 	ctrls->ae_roi_get = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_get, NULL);
 	ctrls->ae_roi_set = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_roi_set, NULL);
-	ctrls->ae_setpoint_get = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_get, NULL);
-	ctrls->ae_setpoint_set = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_set, NULL);
+	ctrls->ae_setpoint_get =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_get, NULL);
+	ctrls->ae_setpoint_set =
+			v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ae_setpoint_set, NULL);
 	ctrls->erb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_erb, NULL);
 	ctrls->ewb = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_ewb, NULL);
 	ctrls->hwmc = v4l2_ctrl_new_custom(hdl, &ds5_ctrl_hwmc, NULL);
@@ -2215,7 +2282,8 @@ static int ds5_sensor_init(struct i2c_client *c, struct ds5 *state,
 	struct media_pad *pad = &sensor->pad;
 	dev_t *dev_num = &state->client->dev.devt;
 
-	dev_info(sd->dev, "%s(): %p %s %p %p", __func__, c, c->name, state, state->client);
+	dev_dbg(sd->dev, "%s(): %p %s %p %p",
+			__func__, c, c->name, state, state->client);
 
 	v4l2_i2c_subdev_init(sd, c, ops);
 	// See tegracam_v4l2.c tegracam_v4l2subdev_register()
@@ -2248,14 +2316,15 @@ static int ds5_sensor_register(struct ds5 *state, struct ds5_sensor *sensor)
 		return ret;
 	}
 
-	ret = media_create_pad_link(entity, 0, &state->mux.sd.subdev.entity, sensor->mux_pad,
-				       MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	ret = media_create_pad_link(entity, 0,
+			&state->mux.sd.subdev.entity, sensor->mux_pad,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
 	if (ret < 0) {
 		dev_err(sd->dev, "%s(): %d: %d\n", __func__, __LINE__, ret);
 		goto e_sd;
 	}
 
-	dev_info(sd->dev, "%s(): 0 -> %d\n", __func__, sensor->mux_pad);
+	dev_dbg(sd->dev, "%s(): 0 -> %d\n", __func__, sensor->mux_pad);
 
 	return 0;
 
@@ -2268,7 +2337,7 @@ e_sd:
 static void ds5_sensor_remove(struct ds5_sensor *sensor)
 {
 	v4l2_device_unregister_subdev(&sensor->sd);
-// FIXME: test rmmod, unbind, init failures to make sure the entity is always freed
+
 	media_entity_cleanup(&sensor->sd.entity);
 }
 
@@ -2277,34 +2346,34 @@ static int ds5_depth_init(struct i2c_client *c, struct ds5 *state)
 	/* Which mux pad we're connecting to */
 	state->depth.sensor.mux_pad = DS5_MUX_PAD_DEPTH;
 	return ds5_sensor_init(c, state, &state->depth.sensor,
-			       &ds5_depth_subdev_ops, "depth");
+			&ds5_depth_subdev_ops, "depth");
 }
 
 static int ds5_motion_t_init(struct i2c_client *c, struct ds5 *state)
 {
 	state->motion_t.sensor.mux_pad = DS5_MUX_PAD_MOTION_T;
 	return ds5_sensor_init(c, state, &state->motion_t.sensor,
-			       &ds5_motion_t_subdev_ops, "motion detection");
+			&ds5_motion_t_subdev_ops, "motion detection");
 }
 
 static int ds5_rgb_init(struct i2c_client *c, struct ds5 *state)
 {
 	state->rgb.sensor.mux_pad = DS5_MUX_PAD_RGB;
 	return ds5_sensor_init(c, state, &state->rgb.sensor,
-			       &ds5_rgb_subdev_ops, "rgb");
+			&ds5_rgb_subdev_ops, "rgb");
 }
 
 static int ds5_imu_init(struct i2c_client *c, struct ds5 *state)
 {
 	state->imu.sensor.mux_pad = DS5_MUX_PAD_IMU;
 	return ds5_sensor_init(c, state, &state->imu.sensor,
-			       &ds5_imu_subdev_ops, "imu");
+			&ds5_imu_subdev_ops, "imu");
 }
 
 /* No locking needed */
 static int ds5_mux_enum_mbus_code(struct v4l2_subdev *sd,
-				  struct v4l2_subdev_pad_config *cfg,
-				  struct v4l2_subdev_mbus_code_enum *mce)
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_mbus_code_enum *mce)
 {
 	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
 	struct v4l2_subdev_mbus_code_enum tmp = *mce;
@@ -2326,7 +2395,7 @@ static int ds5_mux_enum_mbus_code(struct v4l2_subdev *sd,
 		break;
 	case DS5_MUX_PAD_EXTERNAL:
 		if (mce->index >= state->motion_t.sensor.n_formats +
-		    state->depth.sensor.n_formats)
+				state->depth.sensor.n_formats)
 			return -EINVAL;
 
 		/*
@@ -2366,8 +2435,8 @@ static int ds5_mux_enum_mbus_code(struct v4l2_subdev *sd,
 
 /* No locking needed */
 static int ds5_mux_enum_frame_size(struct v4l2_subdev *sd,
-				   struct v4l2_subdev_pad_config *cfg,
-				   struct v4l2_subdev_frame_size_enum *fse)
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
 	struct v4l2_subdev_frame_size_enum tmp = *fse;
@@ -2430,8 +2499,8 @@ static int ds5_mux_enum_frame_size(struct v4l2_subdev *sd,
 
 /* No locking needed */
 static int ds5_mux_enum_frame_interval(struct v4l2_subdev *sd,
-				       struct v4l2_subdev_pad_config *cfg,
-				       struct v4l2_subdev_frame_interval_enum *fie)
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_frame_interval_enum *fie)
 {
 	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
 	struct v4l2_subdev_frame_interval_enum tmp = *fie;
@@ -2441,8 +2510,9 @@ static int ds5_mux_enum_frame_interval(struct v4l2_subdev *sd,
 
 	tmp.pad = 0;
 
-	dev_info(state->depth.sensor.sd.dev, "%s(): pad %d code %x width %d height %d\n", __func__,
-				pad, tmp.code, tmp.width, tmp.height);
+	dev_dbg(state->depth.sensor.sd.dev,
+			"%s(): pad %d code %x width %d height %d\n",
+			__func__, pad, tmp.code, tmp.width, tmp.height);
 
 	if (state->is_depth)
 		pad = DS5_MUX_PAD_DEPTH;
@@ -2497,7 +2567,7 @@ static int ds5_mux_enum_frame_interval(struct v4l2_subdev *sd,
 
 /* No locking needed */
 static int ds5_mux_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,
-			   struct v4l2_subdev_format *fmt)
+		struct v4l2_subdev_format *fmt)
 {
 	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
 	struct v4l2_subdev_format tmp = *fmt;
@@ -2521,8 +2591,9 @@ static int ds5_mux_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config
 	//else
 	//	pad = DS5_MUX_PAD_RGB;
 
-	dev_info(sd->dev, "%s(): pad: %x %x: %ux%u\n", __func__, pad, fmt->format.code,
-		 fmt->format.width, fmt->format.height);
+	dev_dbg(sd->dev, "%s(): pad: %x %x: %ux%u\n",
+			__func__, pad, fmt->format.code,
+			fmt->format.width, fmt->format.height);
 
 	switch (pad) {
 	case DS5_MUX_PAD_MOTION_T:
@@ -2561,7 +2632,7 @@ static int ds5_mux_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config
 
 /* No locking needed */
 static int ds5_mux_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg,
-			   struct v4l2_subdev_format *fmt)
+		struct v4l2_subdev_format *fmt)
 {
 	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
 	struct v4l2_subdev_format tmp = *fmt;
@@ -2569,7 +2640,7 @@ static int ds5_mux_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config
 	u32 pad = fmt->pad;
 	int ret;
 
-	dev_info(sd->dev, "%s(): %u %p\n", __func__, pad, state->mux.last_set);
+	dev_dbg(sd->dev, "%s(): %u %p\n", __func__, pad, state->mux.last_set);
 
 	if (state->is_depth)
 		pad = DS5_MUX_PAD_DEPTH;
@@ -2613,7 +2684,7 @@ static int ds5_mux_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config
 
 /* Video ops */
 static int ds5_mux_g_frame_interval(struct v4l2_subdev *sd,
-				    struct v4l2_subdev_frame_interval *fi)
+		struct v4l2_subdev_frame_interval *fi)
 {
 	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
 	struct ds5_sensor *sensor = NULL;
@@ -2626,8 +2697,8 @@ static int ds5_mux_g_frame_interval(struct v4l2_subdev *sd,
 	fi->interval.numerator = 1;
 	fi->interval.denominator = sensor->config.framerate;
 
-	dev_info(sd->dev, "%s(): %s %u\n", __func__, sd->name,
-		 fi->interval.denominator);
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name,
+			fi->interval.denominator);
 
 	return 0;
 }
@@ -2647,7 +2718,7 @@ static u16 __ds5_probe_framerate(const struct ds5_resolution *res, u16 target)
 }
 
 static int ds5_mux_s_frame_interval(struct v4l2_subdev *sd,
-				    struct v4l2_subdev_frame_interval *fi)
+		struct v4l2_subdev_frame_interval *fi)
 {
 	struct ds5 *state = container_of(sd, struct ds5, mux.sd.subdev);
 	struct ds5_sensor *sensor = NULL;
@@ -2664,7 +2735,7 @@ static int ds5_mux_s_frame_interval(struct v4l2_subdev *sd,
 	fi->interval.numerator = 1;
 	fi->interval.denominator = framerate;
 
-	dev_info(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
+	dev_dbg(sd->dev, "%s(): %s %u\n", __func__, sd->name, framerate);
 
 	return 0;
 }
@@ -2698,7 +2769,8 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 		return -EINVAL;
 	}
 
-	dev_dbg(&state->client->dev, "s_stream for stream %s, on = %d\n", state->mux.last_set->sd.name, on);
+	dev_dbg(&state->client->dev, "s_stream for stream %s, on = %d\n",
+			state->mux.last_set->sd.name, on);
 
 	restore_val = state->mux.last_set->streaming;
 	state->mux.last_set->streaming = on;
@@ -2707,10 +2779,6 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 		ret = ds5_configure(state);
 		if (ret)
 			goto restore_s_state;
-		/* TODO do not apply this to current QS, improve regression deviation
-		 * WA to prevent simultaneous multi-stream starting failure sometimes.
-		 * This should be replaced by a proper fix in cam fw later. */
-		/* msleep_range(100 + 10 * stream_id); */
 
 		ret = ds5_write(state, DS5_START_STOP_STREAM,
 				DS5_STREAM_START | stream_id);
@@ -2722,7 +2790,7 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 			ds5_read(state, stream_status_base, &streaming);
 			ds5_read(state, config_status_base, &status);
 			if ((status & DS5_STATUS_STREAMING) &&
-			    streaming == DS5_STREAM_STREAMING)
+					streaming == DS5_STREAM_STREAMING)
 				break;
 
 			msleep_range(DS5_START_POLL_TIME);
@@ -2741,11 +2809,6 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 				i * DS5_START_POLL_TIME);
 		}
 	} else {
-		/* TODO do not apply this to current QS, improve regression deviation
-		 * WA to prevent simultaneous multi-stream starting failure sometimes.
-		 * This should be replaced by a proper fix in cam fw later. */
-		/* msleep_range(100 + 10 * stream_id); */
-
 		ret = ds5_write(state, DS5_START_STOP_STREAM,
 				DS5_STREAM_STOP | stream_id);
 		if (ret < 0)
@@ -2754,15 +2817,20 @@ static int ds5_mux_s_stream(struct v4l2_subdev *sd, int on)
 
 	ds5_read(state, config_status_base, &status);
 	ds5_read(state, stream_status_base, &streaming);
-	dev_dbg(&state->client->dev, "streaming %x status 0x%04x\n",
-		 streaming, status);
+	dev_info(&state->client->dev,
+			"%s %s, stream_status 0x%x:%x, config_status 0x%x:%x\n",
+			ds5_get_sensor_name(state),
+			(on)?"START":"STOP",
+			stream_status_base, streaming,
+			config_status_base, status);
 
 	return ret;
 
 restore_s_state:
 	ds5_read(state, config_status_base, &status);
-	dev_err(&state->client->dev, "stream toggle failed! %x status 0x%04x\n",
-		 restore_val, status);
+	dev_err(&state->client->dev,
+			"%s stream toggle failed! %x status 0x%04x\n",
+			ds5_get_sensor_name(state) ,restore_val, status);
 
 	state->mux.last_set->streaming = restore_val;
 
@@ -2919,7 +2987,7 @@ static int ds5_hw_init(struct i2c_client *c, struct ds5 *state)
 
 	ret = ds5_read(state, DS5_MIPI_CONF_STATUS, &mipi_status);
 
-	dev_info(sd->dev, "%s(): %d phandle %x node %s status %x\n", __func__, __LINE__,
+	dev_dbg(sd->dev, "%s(): %d phandle %x node %s status %x\n", __func__, __LINE__,
 		 c->dev.of_node->phandle, c->dev.of_node->full_name, mipi_status);
 
 	return ret;
@@ -3017,10 +3085,10 @@ static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
 	if (ret < 0)
 		return ret;
 
-	dev_info(&client->dev, "%s(): cfg0 %x %ux%u cfg0_md %x %ux%u\n", __func__,
+	dev_dbg(&client->dev, "%s(): cfg0 %x %ux%u cfg0_md %x %ux%u\n", __func__,
 		 cfg0, dw, dh, cfg0_md, yw, yh);
 
-	dev_info(&client->dev, "%s(): cfg1 %x %ux%u cfg1_md %x %ux%u\n", __func__,
+	dev_dbg(&client->dev, "%s(): cfg1 %x %ux%u cfg1_md %x %ux%u\n", __func__,
 		 cfg1, dw, dh, cfg1_md, yw, yh);
 
 	sensor = &state->depth.sensor;
@@ -3045,22 +3113,23 @@ static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
 	switch (dev_type) {
 	case DS5_DEVICE_TYPE_D45X:
 	case DS5_DEVICE_TYPE_D43X: {
-		unsigned int *calib_resolutions_size = (unsigned int *)&(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].n_resolutions);
-		const struct ds5_resolution** calib_resolutions = (const struct ds5_resolution**)
-					    &(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].resolutions);
+		unsigned int *calib_resolutions_size =
+				(unsigned int *)&(
+						sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1]
+										.n_resolutions);
+		const struct ds5_resolution** calib_resolutions =
+				(const struct ds5_resolution**)
+				&(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1]
+								.resolutions);
 		*calib_resolutions_size = ARRAY_SIZE(d43x_calibration_sizes),
-		*calib_resolutions = d43x_calibration_sizes;
+				*calib_resolutions = d43x_calibration_sizes;
 		break;
-	}
+		}
 	case DS5_DEVICE_TYPE_D46X: {
-		dev_info(&client->dev, "%s(): DS5_DEVICE_TYPE_D46X for calib\n", __func__);
-		//unsigned int *calib_resolutions_size = (unsigned int *)&(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].n_resolutions);
-		//const struct ds5_resolution** calib_resolutions = (const struct ds5_resolution**)
-		//			    &(sensor->formats[ARRAY_SIZE(ds5_y_formats_ds5u)-1].resolutions);
-		//*calib_resolutions_size = ARRAY_SIZE(d46x_calibration_sizes),
-		//*calib_resolutions = d46x_calibration_sizes;
+		dev_dbg(&client->dev, "%s(): DS5_DEVICE_TYPE_D46X for calib\n",
+				__func__);
 		break;
-	}
+		}
 	}
 
 	sensor = &state->rgb.sensor;
@@ -3080,10 +3149,6 @@ static int ds5_fixed_configuration(struct i2c_client *client, struct ds5 *state)
 	}
 	sensor->mux_pad = DS5_MUX_PAD_RGB;
 
-	/*sensor->formats = &ds5_onsemi_rgb_format;
-	sensor->n_formats = DS5_RGB_N_FORMATS;
-	sensor->mux_pad = DS5_MUX_PAD_RGB;*/
-
 	sensor = &state->imu.sensor;
 	sensor->formats = ds5_imu_formats;
 	sensor->n_formats = 1;
@@ -3168,7 +3233,9 @@ static int ds5_dfu_wait_for_status(struct ds5 *state)
 		ds5_read(state, 0x5000, &status);
 		if (status == 0x0001 || status == 0x0002)
 		{
-			dev_err(&state->client->dev, "%s(): dfu failed status(0x%4x)\n", __func__, status);
+			dev_err(&state->client->dev,
+					"%s(): dfu failed status(0x%4x)\n",
+					__func__, status);
 			ret = -EREMOTEIO;
 			break;
 		}
@@ -3186,7 +3253,8 @@ static int ds5_dfu_switch_to_dfu(struct ds5 *state)
 	int i = DS5_START_MAX_COUNT;
 	u16 status;
 
-	ds5_raw_write_with_check(state, 0x4900, &cmd_switch_to_dfu, sizeof(cmd_switch_to_dfu));
+	ds5_raw_write_with_check(state, 0x4900,
+			&cmd_switch_to_dfu, sizeof(cmd_switch_to_dfu));
 	ds5_write_with_check(state, 0x490c, 0x01); /* execute cmd */
 	/*Wait for DFU fw to boot*/
 	do {
@@ -3196,7 +3264,8 @@ static int ds5_dfu_switch_to_dfu(struct ds5 *state)
 	return ret;
 };
 
-static int ds5_dfu_wait_for_get_dfu_status(struct ds5 *state,enum dfu_fw_state exp_state)
+static int ds5_dfu_wait_for_get_dfu_status(struct ds5 *state,
+		enum dfu_fw_state exp_state)
 {
 	int ret = 0;
 	u16 status,dfu_state_len = 0x0000;
@@ -3207,32 +3276,39 @@ static int ds5_dfu_wait_for_get_dfu_status(struct ds5 *state,enum dfu_fw_state e
 		do {
 			ds5_read_with_check(state, 0x5000, &status);
 			if (status == 0x0001) {
-				dev_err(&state->client->dev, "%s(): Write status error I2C_STATUS_ERROR(1)\n", __func__);
+				dev_err(&state->client->dev,
+						"%s(): Write status error I2C_STATUS_ERROR(1)\n",
+						__func__);
 				return -EINVAL;
 			} else
 				if (status == 0x0002 && dfu_wr_wait_msec)
 					msleep_range(dfu_wr_wait_msec);
-					//dev_notice(&state->client->dev, "%s():waiting (%x)\n", __func__, dfu_wr_wait_msec);
 
 		} while (status);
 
 		ds5_read_with_check(state, 0x5004, &dfu_state_len);
 		if (dfu_state_len != DFU_WAIT_RET_LEN) {
-			dev_err(&state->client->dev, "%s(): Wrong answer len (%d)\n", __func__, dfu_state_len);
+			dev_err(&state->client->dev,
+					"%s(): Wrong answer len (%d)\n", __func__, dfu_state_len);
 			return -EINVAL;
 		}
 		ds5_raw_read_with_check(state, 0x4e00, &dfu_asw_buf, DFU_WAIT_RET_LEN);
 		if (dfu_asw_buf[0]) {
-			dev_err(&state->client->dev, "%s(): Wrong dfu_status (%d)\n", __func__, dfu_asw_buf[0]);
+			dev_err(&state->client->dev,
+					"%s(): Wrong dfu_status (%d)\n", __func__, dfu_asw_buf[0]);
 			return -EINVAL;
 		}
-		dfu_wr_wait_msec = (((unsigned int)dfu_asw_buf[3]) << 16) | (((unsigned int)dfu_asw_buf[2]) << 8) | dfu_asw_buf[1];
+		dfu_wr_wait_msec = (((unsigned int)dfu_asw_buf[3]) << 16)
+						| (((unsigned int)dfu_asw_buf[2]) << 8)
+						| dfu_asw_buf[1];
 	} while (dfu_asw_buf[4] == dfuDNBUSY && exp_state == dfuDNLOAD_IDLE);
 
 
-	if  (dfu_asw_buf[4] != exp_state) {
-		dev_notice(&state->client->dev, "%s(): Wrong dfu_state (%d) while expected(%d)\n", __func__, dfu_asw_buf[4], exp_state);
-		ret =  -EINVAL;
+	if (dfu_asw_buf[4] != exp_state) {
+		dev_notice(&state->client->dev,
+				"%s(): Wrong dfu_state (%d) while expected(%d)\n",
+				__func__, dfu_asw_buf[4], exp_state);
+		ret = -EINVAL;
 	}
 	return ret;
 };
@@ -3251,7 +3327,9 @@ static int ds5_dfu_get_dev_info(struct ds5 *state, struct __fw_status *buf)
 	if (len == sizeof(struct __fw_status)) {
 		ds5_raw_read_with_check(state, 0x4e00, buf, len);
 	} else {
-		dev_err(&state->client->dev, "%s(): Wrong state size (%d)\n", __func__, len);
+		dev_err(&state->client->dev,
+				"%s(): Wrong state size (%d)\n",
+				__func__, len);
 		ret = -EINVAL;
 	}
 	return ret;
@@ -3266,14 +3344,18 @@ static int ds5_dfu_detach(struct ds5 *state)
 	ret = ds5_dfu_wait_for_get_dfu_status(state, dfuIDLE);
 	if (!ret)
 		ret = ds5_dfu_get_dev_info(state, &buf);
-	dev_notice(&state->client->dev, "%s():DFU ver (0x%x) recieved\n", __func__, buf.DFU_version);
-	dev_notice(&state->client->dev, "%s():FW last version (0x%x) recieved\n", __func__, buf.FW_lastVersion);
-	dev_notice(&state->client->dev, "%s():FW status (%s)\n", __func__, buf.DFU_isLocked ? "locked" : "unlocked");
+	dev_notice(&state->client->dev, "%s():DFU ver (0x%x) recieved\n",
+			__func__, buf.DFU_version);
+	dev_notice(&state->client->dev, "%s():FW last version (0x%x) recieved\n",
+			__func__, buf.FW_lastVersion);
+	dev_notice(&state->client->dev, "%s():FW status (%s)\n",
+			__func__, buf.DFU_isLocked ? "locked" : "unlocked");
 	return ret;
 };
 
 /* When a process reads from our device, this gets called. */
-static ssize_t ds5_dfu_device_read(struct file *flip, char __user *buffer, size_t len, loff_t *offset)
+static ssize_t ds5_dfu_device_read(struct file *flip,
+		char __user *buffer, size_t len, loff_t *offset)
 {
 	struct ds5 *state = flip->private_data;
 	u16 fw_ver;
@@ -3298,7 +3380,8 @@ e_dfu_read_failed:
 	return ret;
 };
 
-static ssize_t ds5_dfu_device_write(struct file *flip, const char __user *buffer, size_t len, loff_t *offset)
+static ssize_t ds5_dfu_device_write(struct file *flip,
+		const char __user *buffer, size_t len, loff_t *offset)
 {
 	struct ds5 *state = flip->private_data;
 	int ret = 0;
@@ -3310,14 +3393,16 @@ static ssize_t ds5_dfu_device_write(struct file *flip, const char __user *buffer
 	case DS5_DFU_OPEN:
 		ret = ds5_dfu_switch_to_dfu(state);
 		if (ret < 0) {
-			dev_err(&state->client->dev, "%s(): Switch to dfu failed (%d)\n", __func__, ret);
+			dev_err(&state->client->dev, "%s(): Switch to dfu failed (%d)\n",
+					__func__, ret);
 			goto dfu_write_error;
 		}
 		/*no break - procceed to recovery*/
 	case DS5_DFU_RECOVERY:
 		ret = ds5_dfu_detach(state);
 		if (ret < 0) {
-			dev_err(&state->client->dev, "%s(): Detach failed (%d)\n", __func__, ret);
+			dev_err(&state->client->dev, "%s(): Detach failed (%d)\n",
+					__func__, ret);
 			goto dfu_write_error;
 		}
 		state->dfu_dev.dfu_state_flag = DS5_DFU_IN_PROGRESS;
@@ -3329,11 +3414,12 @@ static ssize_t ds5_dfu_device_write(struct file *flip, const char __user *buffer
 		unsigned int dfu_part_blocks = len % DFU_BLOCK_SIZE;
 
 		while (dfu_full_blocks--) {
-			if(copy_from_user(state->dfu_dev.dfu_msg , buffer, DFU_BLOCK_SIZE)) {
+			if(copy_from_user(state->dfu_dev.dfu_msg, buffer, DFU_BLOCK_SIZE)) {
 				ret = -EFAULT;
 				goto dfu_write_error;
 			}
-			ret = ds5_raw_write(state, 0x4a00, state->dfu_dev.dfu_msg, DFU_BLOCK_SIZE);
+			ret = ds5_raw_write(state, 0x4a00,
+					state->dfu_dev.dfu_msg, DFU_BLOCK_SIZE);
 			if (ret < 0)
 				goto dfu_write_error;
 			ret = ds5_dfu_wait_for_get_dfu_status (state, dfuDNLOAD_IDLE);
@@ -3346,7 +3432,8 @@ static ssize_t ds5_dfu_device_write(struct file *flip, const char __user *buffer
 				goto dfu_write_error;
 		}
 		if (dfu_part_blocks) {
-			ret = ds5_raw_write(state, 0x4a00, state->dfu_dev.dfu_msg, dfu_part_blocks);
+			ret = ds5_raw_write(state, 0x4a00,
+					state->dfu_dev.dfu_msg, dfu_part_blocks);
 			if (!ret) {
 				ret = ds5_dfu_wait_for_get_dfu_status (state, dfuDNLOAD_IDLE);
 			}
@@ -3358,12 +3445,14 @@ static ssize_t ds5_dfu_device_write(struct file *flip, const char __user *buffer
 				goto dfu_write_error;
 			state->dfu_dev.dfu_state_flag = DS5_DFU_DONE;
 		}
-		dev_notice(&state->client->dev, "%s(): DFU block (%d) bytes written\n", __func__, (int)len);
+		dev_notice(&state->client->dev, "%s(): DFU block (%d) bytes written\n",
+				__func__, (int)len);
 		break;
 	}
 	default:
-		dev_err(&state->client->dev, "%s(): Wrong state (%d)\n", __func__, state->dfu_dev.dfu_state_flag);
-		ret =  -EINVAL;
+		dev_err(&state->client->dev, "%s(): Wrong state (%d)\n",
+				__func__, state->dfu_dev.dfu_state_flag);
+		ret = -EINVAL;
 		goto dfu_write_error;
 
 	};
@@ -3379,23 +3468,25 @@ dfu_write_error:
 
 static int ds5_dfu_device_open(struct inode *inode, struct file *file)
 {
-	struct ds5 *state = container_of(inode->i_cdev, struct ds5, dfu_dev.ds5_cdev);
+	struct ds5 *state = container_of(inode->i_cdev, struct ds5,
+			dfu_dev.ds5_cdev);
 	struct i2c_adapter *parent = i2c_parent_is_i2c_adapter(
 			state->client->adapter);
 
 	if (state->dfu_dev.device_open_count)
 		return -EBUSY;
 	state->dfu_dev.device_open_count++;
-	if (state->dfu_dev.dfu_state_flag  != DS5_DFU_RECOVERY)
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
 		state->dfu_dev.dfu_state_flag = DS5_DFU_OPEN;
-	state->dfu_dev.dfu_msg = devm_kzalloc(&state->client->dev, DFU_BLOCK_SIZE, GFP_KERNEL);
+	state->dfu_dev.dfu_msg = devm_kzalloc(&state->client->dev,
+			DFU_BLOCK_SIZE, GFP_KERNEL);
 	file->private_data = state;
 
 	/* get i2c controller and set dfu bus clock rate */
 	while (parent && i2c_parent_is_i2c_adapter(parent))
 		parent = i2c_parent_is_i2c_adapter(state->client->adapter);
 
-	dev_info(&state->client->dev, "%s(): i2c-%d bus_clk = %d, set %d\n",
+	dev_dbg(&state->client->dev, "%s(): i2c-%d bus_clk = %d, set %d\n",
 			__func__,
 			i2c_adapter_id(parent),
 			i2c_get_adapter_bus_clk_rate(parent),
@@ -3406,23 +3497,14 @@ static int ds5_dfu_device_open(struct inode *inode, struct file *file)
 	return 0;
 };
 
-static int ds5_v4l_init(struct i2c_client *c,struct ds5 *state)
+static int ds5_v4l_init(struct i2c_client *c, struct ds5 *state)
 {
-	u16 fw_ver;
-	u16 fw_build;
 	int ret;
 
 	ret = ds5_parse_cam(c, state);
 	if (ret < 0)
 		return ret;
 
-	ds5_read_with_check(state, DS5_FW_VERSION, &fw_ver);
-	dev_info(&c->dev, "%s(): D4XX firmware version %x\n", __func__, fw_ver);
-	ds5_read_with_check(state, DS5_FW_BUILD, &fw_build);
-	dev_info(&c->dev, "%s(): D4XX firmware build %x\n", __func__, fw_build);
-	state->fw_version = fw_ver;
-	state->fw_build = fw_build;
-
 	ret = ds5_depth_init(c, state);
 	if (ret < 0)
 		return ret;
@@ -3476,9 +3558,10 @@ static int ds5_dfu_device_release(struct inode *inode, struct file *file)
 			state->client->adapter);
 
 	state->dfu_dev.device_open_count--;
-	if (state->dfu_dev.dfu_state_flag  != DS5_DFU_RECOVERY)
+	if (state->dfu_dev.dfu_state_flag != DS5_DFU_RECOVERY)
 		state->dfu_dev.dfu_state_flag = DS5_DFU_IDLE;
-	if (state->dfu_dev.dfu_state_flag == DS5_DFU_DONE && state->dfu_dev.init_v4l_f)
+	if (state->dfu_dev.dfu_state_flag == DS5_DFU_DONE
+			&& state->dfu_dev.init_v4l_f)
 		ds5_v4l_init(state->client, state);
 	state->dfu_dev.init_v4l_f = 0;
 	if (state->dfu_dev.dfu_msg)
@@ -3489,7 +3572,7 @@ static int ds5_dfu_device_release(struct inode *inode, struct file *file)
 	while (parent && i2c_parent_is_i2c_adapter(parent))
 		parent = i2c_parent_is_i2c_adapter(state->client->adapter);
 
-	dev_info(&state->client->dev, "%s(): i2c-%d bus_clk %d, restore to %d\n",
+	dev_dbg(&state->client->dev, "%s(): i2c-%d bus_clk %d, restore to %d\n",
 			__func__, i2c_adapter_id(parent),
 			i2c_get_adapter_bus_clk_rate(parent),
 			state->dfu_dev.bus_clk_rate);
@@ -3499,7 +3582,7 @@ static int ds5_dfu_device_release(struct inode *inode, struct file *file)
 };
 
 static const struct file_operations ds5_device_file_ops = {
-	.owner  = THIS_MODULE,
+	.owner = THIS_MODULE,
 	.read = &ds5_dfu_device_read,
 	.write = &ds5_dfu_device_write,
 	.open = &ds5_dfu_device_open,
@@ -3518,15 +3601,15 @@ static int ds5_chrdev_init(struct i2c_client *c, struct ds5 *state)
 	dev_t *dev_num = &c->dev.devt;
 	int ret;
 
-	dev_info(&c->dev, "%s()\n", __func__);
+	dev_dbg(&c->dev, "%s()\n", __func__);
 	/* Request the kernel for N_MINOR devices */
 	ret = alloc_chrdev_region(dev_num, 0, 1, DS5_DRIVER_NAME_DFU);
 	if (ret < 0)
 		return ret;
-	//dev_info(&c->dev, "%s(): <Major, Minor>: <%d, %d>\n", __func__, MAJOR(*dev_num), MINOR(*dev_num));
 
 	if (!atomic_cmpxchg (&primary_chardev, 0, MAJOR(*dev_num))) {
-		dev_info(&c->dev, "%s(): <Major, Minor>: <%d, %d>\n", __func__, MAJOR(*dev_num), MINOR(*dev_num));
+		dev_dbg(&c->dev, "%s(): <Major, Minor>: <%d, %d>\n",
+				__func__, MAJOR(*dev_num), MINOR(*dev_num));
 		/* Create a class : appears at /sys/class */
 		*ds5_class = class_create(THIS_MODULE, DS5_DRIVER_NAME_CLASS);
 		if (IS_ERR(*ds5_class)) {
@@ -3538,27 +3621,21 @@ static int ds5_chrdev_init(struct i2c_client *c, struct ds5 *state)
 		g_ds5_class = *ds5_class;
 	} else
 		*ds5_class = g_ds5_class;
-        /* Associate the cdev with a set of file_operations */
-        cdev_init(ds5_cdev, &ds5_device_file_ops);
-        /* Build up the current device number. To be used further */
-        *dev_num = MKDEV(MAJOR(*dev_num), MINOR(*dev_num));
-        /* Create a device node for this device. Look, the class is
-         * being used here. The same class is associated with N_MINOR
-         * devices. Once the function returns, device nodes will be
-         * created as /dev/my_dev0, /dev/my_dev1,... You can also view
-         * the devices under /sys/class/my_driver_class.
-         */
+	/* Associate the cdev with a set of file_operations */
+	cdev_init(ds5_cdev, &ds5_device_file_ops);
+	/* Build up the current device number. To be used further */
+	*dev_num = MKDEV(MAJOR(*dev_num), MINOR(*dev_num));
+	/* Create a device node for this device. */
 	sprintf (dev_name, "%s%d", DS5_DRIVER_NAME_DFU, MAJOR(*dev_num));
 	chr_dev = device_create(*ds5_class, NULL, *dev_num, NULL, dev_name);
-        if (IS_ERR(chr_dev)) {
+	if (IS_ERR(chr_dev)) {
 		ret = PTR_ERR(chr_dev);
 		dev_err(&c->dev,"Could not create device\n");
 		class_destroy(*ds5_class);
 		unregister_chrdev_region(0, 1);
 		return ret;
 	}
-        /* Now make the device live for the users to access */
-        cdev_add(ds5_cdev, *dev_num, 1);
+	cdev_add(ds5_cdev, *dev_num, 1);
 	return 0;
 };
 
@@ -3567,7 +3644,7 @@ static int ds5_chrdev_remove(struct ds5 *state)
 	struct class* *ds5_class = &state->dfu_dev.ds5_class;
 	dev_t *dev_num = &state->client->dev.devt;
 
-	dev_info(&state->client->dev, "%s()\n", __func__);
+	dev_dbg(&state->client->dev, "%s()\n", __func__);
 	unregister_chrdev_region(*dev_num, 1);
 	device_destroy(*ds5_class, *dev_num);
 	if (atomic_cmpxchg (&primary_chardev, MAJOR(*dev_num), 0) == MAJOR(*dev_num))
@@ -3584,15 +3661,11 @@ static ssize_t ds5_fw_ver_show(struct device *dev,
 	struct ds5 *state = container_of(i2c_get_clientdata(c),
 			struct ds5, mux.sd.subdev);
 
-	const char *sensor_name[] = {"unknown", "RGB", "DEPTH", "Y8", "IMU"};
-	int sensor_id = state->is_rgb * 1 + state->is_depth * 2 + \
-			state->is_y8 * 3 + state->is_imu * 4;
-
 	ds5_read(state, DS5_FW_VERSION, &state->fw_version);
 	ds5_read(state, DS5_FW_BUILD, &state->fw_build);
 
 	return sprintf(buf, "D4XX Sensor: %s, Version: %d.%d.%d.%d\n",
-			sensor_name[sensor_id],
+			ds5_get_sensor_name(state),
 			(state->fw_version >> 8) & 0xff, state->fw_version & 0xff,
 			(state->fw_build >> 8) & 0xff, state->fw_build & 0xff);
 }
@@ -3603,7 +3676,7 @@ static DEVICE_ATTR_RO(ds5_fw_ver);
 struct dev_ds5_reg_attribute {
 	struct device_attribute attr;
 	u16 reg;	// register
-	u8  valid;	// validity of above data
+	u8 valid;	// validity of above data
 };
 
 /** Read DS5 register.
@@ -3635,7 +3708,7 @@ static ssize_t ds5_read_reg_show(struct device *dev,
 	return n;
 }
 
-/** Read DS5 register - Store  reg to attr struct pointer
+/** Read DS5 register - Store reg to attr struct pointer
  * ds5_read_reg_show will actually read register from ds5 while
  * ds5_read_reg_store will store module, offset and length
  */
@@ -3658,7 +3731,7 @@ static ssize_t ds5_read_reg_store(struct device *dev,
 
 #define DS5_RW_REG_ATTR(_name) \
 		struct dev_ds5_reg_attribute dev_attr_##_name = { \
-				__ATTR(_name,  S_IRUGO | S_IWUSR, \
+				__ATTR(_name, S_IRUGO | S_IWUSR, \
 						ds5_read_reg_show, ds5_read_reg_store), \
 						0, 0 }
 
@@ -3740,7 +3813,8 @@ static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
 		goto e_regulator;
 	ret = ds5_read(state, 0x5020, &rec_state);
 	if (ret < 0) {
-		dev_err(&c->dev, "%s(): cannot communicate with D4XX: %d\n", __func__, ret);
+		dev_err(&c->dev, "%s(): cannot communicate with D4XX: %d\n",
+				__func__, ret);
 		goto e_chardev;
 	}
 
@@ -3766,10 +3840,13 @@ static int ds5_probe(struct i2c_client *c, const struct i2c_device_id *id)
 	if (!err && !strncmp(str, "IMU", strlen("IMU")))
 		state->is_imu = 1;
 
-	dev_info(&c->dev, "%s(): state->is_rgb %d\n", __func__, state->is_rgb);
-	dev_info(&c->dev, "%s(): state->is_depth %d\n", __func__, state->is_depth);
-	dev_info(&c->dev, "%s(): state->is_y8 %d\n", __func__, state->is_y8);
-	dev_info(&c->dev, "%s(): state->is_imu %d\n", __func__, state->is_imu);
+	ds5_read_with_check(state, DS5_FW_VERSION, &state->fw_version);
+	ds5_read_with_check(state, DS5_FW_BUILD, &state->fw_build);
+
+	dev_info(&c->dev, "D4XX Sensor: %s, firmware build: %d.%d.%d.%d\n",
+			ds5_get_sensor_name(state),
+			(state->fw_version >> 8) & 0xff, state->fw_version & 0xff,
+			(state->fw_build >> 8) & 0xff, state->fw_build & 0xff);
 
 	ret = ds5_v4l_init(c, state);
 	if (ret < 0)
@@ -3803,7 +3880,8 @@ static int ds5_remove(struct i2c_client *c)
 {
 	struct ds5 *state = container_of(i2c_get_clientdata(c), struct ds5, mux.sd.subdev);
 
-	dev_info(&c->dev, "%s()\n", __func__);
+	dev_info(&c->dev, "D4XX remove %s\n",
+			ds5_get_sensor_name(state));
 	if (state->vcc)
 		regulator_disable(state->vcc);
 //	gpio_free(state->pwdn_gpio);
@@ -3846,4 +3924,4 @@ MODULE_AUTHOR( "Guennadi Liakhovetski <guennadi.liakhovetski@intel.com>,\n\
 				Shikun Ding <shikun.ding@intel.com>");
 MODULE_AUTHOR("Dmitry Perchanov <dmitry.perchanov@intel.com>");
 MODULE_LICENSE("GPL v2");
-MODULE_VERSION("1.0.1.11");
+MODULE_VERSION("1.0.1.12");
-- 
2.37.1

